<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Record and Think!">
<meta property="og:type" content="website">
<meta property="og:title" content="Schwimmer&#39;s Blog">
<meta property="og:url" content="https://schwimmer.github.io/page/28/index.html">
<meta property="og:site_name" content="Schwimmer&#39;s Blog">
<meta property="og:description" content="Record and Think!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Schwimmer&#39;s Blog">
<meta name="twitter:description" content="Record and Think!">





  
  
  <link rel="canonical" href="https://schwimmer.github.io/page/28/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Schwimmer's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143240576-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-143240576-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Schwimmer's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/08/12/机器学习/NLP/Gensim-Tutorials/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/12/机器学习/NLP/Gensim-Tutorials/" class="post-title-link" itemprop="url">Gensim-Tutorials</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-08-12T11:49:53+08:00">2017-08-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-01 23:21:31" itemprop="dateModified" datetime="2018-02-01T23:21:31+08:00">2018-02-01</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/08/12/机器学习/NLP/Gensim-Tutorials/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/08/12/机器学习/NLP/Gensim-Tutorials/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://radimrehurek.com/gensim/tutorial.html" target="_blank" rel="noopener">http://radimrehurek.com/gensim/tutorial.html</a></p>
<p>Gensim 使用Python标准logging模块来记录log，使用方法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(format=&apos;%(asctime)s : %(levelname)s : %(message)s&apos;, level=logging.INFO)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/08/12/机器学习/NLP/NLP代码片段/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/08/12/机器学习/NLP/NLP代码片段/" class="post-title-link" itemprop="url">NLP代码片段</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-08-12T11:49:53+08:00">2017-08-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-31 10:28:31" itemprop="dateModified" datetime="2018-03-31T10:28:31+08:00">2018-03-31</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/08/12/机器学习/NLP/NLP代码片段/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/08/12/机器学习/NLP/NLP代码片段/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="根据标点拆分句子"><a href="#根据标点拆分句子" class="headerlink" title="根据标点拆分句子"></a>根据标点拆分句子</h1><p><code>[AtomSplit.java](../../../../gitlab/user-gene/nlp/src/main/java/com/buzzinate/nlp/segment/AtomSplit.java)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">splitSentences</span><span class="params">(String text)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (Term term: Segment.split(text, ToAnalysis.USE_USER_DEFINE)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sentenceNatures.contains(term.getNatrue().natureStr) &amp;&amp; !isWhiteSpace(term.getName())) &#123;</span><br><span class="line">				<span class="keyword">if</span> (term.getOffe() &gt; last) &#123;</span><br><span class="line">					String snippet = text.substring(last, term.getOffe()).trim();  </span><br><span class="line">					<span class="keyword">if</span> (snippet.length() &gt; <span class="number">0</span>) result.add(snippet);</span><br><span class="line">				&#125;</span><br><span class="line">				last = term.getOffe() + term.getName().length();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (text.length() &gt; last) &#123;</span><br><span class="line">			String snippet = text.substring(last, text.length()).trim();  </span><br><span class="line">			<span class="keyword">if</span> (snippet.length() &gt; <span class="number">0</span>) result.add(snippet);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isWhiteSpace</span><span class="params">(String term)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> term.length() == <span class="number">1</span> &amp;&amp; (Character.isWhitespace(term.charAt(<span class="number">0</span>)) || term.charAt(<span class="number">0</span>) == <span class="string">'-'</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="给每个字符标记类型"><a href="#给每个字符标记类型" class="headerlink" title="给每个字符标记类型"></a>给每个字符标记类型</h1><p><code>[AtomSplit.java](../../../../gitlab/user-gene/nlp/src/main/java/com/buzzinate/nlp/segment/AtomSplit.java)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给每个字符标记类型，如</span></span><br><span class="line"><span class="comment"> * [2011(AT_NUM), -(AT_PUNC), 34(AT_NUM), -(AT_PUNC), 43(AT_NUM),  (AT_PUNC), 为(AT_CHINESE), 中(AT_CHINESE), 国(AT_CHINESE)]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Atom&gt; <span class="title">split</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">	List&lt;Atom&gt; result = <span class="keyword">new</span> ArrayList&lt;Atom&gt;();</span><br><span class="line">	<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">	AtomType t = AtomType.AT_LETTER;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">char</span> ch = text.charAt(i);</span><br><span class="line">		<span class="keyword">if</span> (TextUtil.isAlphaOrDigit(ch) || ch == <span class="string">'\''</span> || ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == last) &#123;</span><br><span class="line">				t = AtomType.AT_LETTER;</span><br><span class="line">				<span class="keyword">if</span> (Character.isDigit(ch)) t = AtomType.AT_NUM;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLetter(ch)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; last) result.add(<span class="keyword">new</span> Atom(text.substring(last, i), t));</span><br><span class="line">			result.add(<span class="keyword">new</span> Atom(text.substring(i, i+<span class="number">1</span>), AtomType.AT_CHINESE));</span><br><span class="line">			last = i + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; last) result.add(<span class="keyword">new</span> Atom(text.substring(last, i), t));</span><br><span class="line">			<span class="keyword">if</span> (t != AtomType.AT_LETTER || !isConnectChar(ch)) result.add(<span class="keyword">new</span> Atom(text.substring(i, i+<span class="number">1</span>), AtomType.AT_PUNC));</span><br><span class="line">			last = i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (text.length() &gt; last) result.add(<span class="keyword">new</span> Atom(text.substring(last, text.length()), t));</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="判断字符串的语言"><a href="#判断字符串的语言" class="headerlink" title="判断字符串的语言"></a>判断字符串的语言</h1><p>有两个开源的项目可以使用。一个是Apache Tika，一个是language-detection。language-detection是google Code上开源的一个语言检测软件包，不折不扣的日货，但使用起来非常方便，其project链接如下：<a href="http://code.google.com/p/language-detection" target="_blank" rel="noopener">http://code.google.com/p/language-detection</a>。基本上，你只需要引用langdetect.jar和其依赖的jsonic-1.3.0.jar（也是日货）即可</p>
<p><code>/rocket-iaudience-api/src/main/java/com/iclick/rocket/iaudience/api/common/LanguageDetectUtil.java</code></p>
<h2 id="判断中文字符"><a href="#判断中文字符" class="headerlink" title="判断中文字符"></a>判断中文字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character.isLetter()</span><br></pre></td></tr></table></figure>
<h2 id="判断是否为英文或数字"><a href="#判断是否为英文或数字" class="headerlink" title="判断是否为英文或数字"></a>判断是否为英文或数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlphaOrDigit</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="去除停用词"><a href="#去除停用词" class="headerlink" title="去除停用词"></a>去除停用词</h1><p>java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; wordSet = new ArrayList&lt;String&gt;();</span><br><span class="line">// 自动去除停用词</span><br><span class="line">		for (Term term : NotionalTokenizer.segment(simplePhrase)) &#123;</span><br><span class="line">			wordSet.add(term.word);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>python参考gensim</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">documents = [&quot;Human machine interface for lab abc computer applications&quot;,</span><br><span class="line">             &quot;A survey of user opinion of computer system response time&quot;,</span><br><span class="line">             &quot;The EPS user interface management system&quot;,</span><br><span class="line">             &quot;System and human system engineering testing of EPS&quot;,              </span><br><span class="line">             &quot;Relation of user perceived response time to error measurement&quot;,</span><br><span class="line">             &quot;The generation of random binary unordered trees&quot;,</span><br><span class="line">             &quot;The intersection graph of paths in trees&quot;,</span><br><span class="line">             &quot;Graph minors IV Widths of trees and well quasi ordering&quot;,</span><br><span class="line">             &quot;Graph minors A survey&quot;]</span><br><span class="line">#停用词</span><br><span class="line">stoplist = set(&apos;for a of the and to in&apos;.split())</span><br><span class="line">texts = [ [word for word in document.lower().split() if word not in stoplist ]</span><br><span class="line">         for document in documents ]</span><br><span class="line">         </span><br><span class="line">#删除仅出现一次的词</span><br><span class="line">from collections import defaultdict</span><br><span class="line">frequency = defaultdict(int)</span><br><span class="line">for text in texts:</span><br><span class="line">    for token in text:</span><br><span class="line">        frequency[token] += 1</span><br><span class="line">texts = [[token for token in text if frequency[token] &gt; 1 ] for text in texts]</span><br></pre></td></tr></table></figure>
<h1 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h1><p>python用jieba</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">sentences = [<span class="string">"我喜欢吃土豆"</span>,<span class="string">"土豆是个百搭的东西"</span>,<span class="string">"我不喜欢今天雾霾的北京"</span>]</span><br><span class="line">words=[]</span><br><span class="line"><span class="keyword">for</span> doc <span class="keyword">in</span> sentences:</span><br><span class="line"><span class="comment"># 结巴分词返回的是一个generator，要用list()转成list</span></span><br><span class="line">    words.append(list(jieba.cut(doc)))</span><br><span class="line"><span class="keyword">print</span> words</span><br></pre></td></tr></table></figure>
<p>java用hanlp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; wordSet = new ArrayList&lt;String&gt;();</span><br><span class="line">// 自动去除停用词</span><br><span class="line">		for (Term term : NotionalTokenizer.segment(simplePhrase)) &#123;</span><br><span class="line">			wordSet.add(term.word);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h1 id="英文词干化"><a href="#英文词干化" class="headerlink" title="英文词干化"></a>英文词干化</h1>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/模型评估与选择/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/模型评估与选择/" class="post-title-link" itemprop="url">模型评估与选择</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-29 21:43:42" itemprop="dateModified" datetime="2018-01-29T21:43:42+08:00">2018-01-29</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/模型评估与选择/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/模型评估与选择/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、模型评估方法"><a href="#1、模型评估方法" class="headerlink" title="1、模型评估方法"></a>1、模型评估方法</h1><blockquote>
<p>可重复采样：<strong>在训练集小</strong>，难以划分训练/测试集是有用。此外，能产生多个不同训练集，对<strong>集成学习</strong>等方法有很大的好处。但是会改变初始数据集分布。</p>
<p>在<strong>初始数据量足够</strong>时，用留出法或者交叉验证法。</p>
</blockquote>
<h2 id="1-1-留出法Hold-out"><a href="#1-1-留出法Hold-out" class="headerlink" title="1.1 留出法Hold-out"></a>1.1 留出法Hold-out</h2><p>将数据集D分成两个互斥的集合。</p>
<p>训练/测试集尽量保证数据一致性，用分层采样，正负样本同比例。</p>
<p>由于单次估计结果往往不可靠，使用留出法时，一般要采用若干次随机划分，重复进行实验后取平均值作为评估值。      ‘</p>
<h2 id="1-2-交叉验证法"><a href="#1-2-交叉验证法" class="headerlink" title="1.2 交叉验证法"></a>1.2 交叉验证法</h2><p>将D分成k个大小相似的互斥子集，每个子集用分层采样得到。</p>
<p>每次用k-1个子集的并集作为训练集，余下的子集作为测试集。这样获得k组训练/测试集。最终返回是k个测试结果的均值。</p>
<p>常用10折交叉验证。</p>
<h2 id="1-3-可重复采样"><a href="#1-3-可重复采样" class="headerlink" title="1.3 可重复采样"></a>1.3 可重复采样</h2><p>bootstrapping sampling：给定包含m个样本的数据集D，我们进行采样产生数据集$D’$，每次随机从D中挑选一个样本，将其拷贝放入$D’$，再将样本放回D。重复m次，得到包含m个样本的$D’$。</p>
<p>样本在m次采样中始终不被采到的概率是$(1-\frac 1 m)^m$，取极限得到</p>
<script type="math/tex; mode=display">
{\lim_{m \mapsto \infty  }}(1-\frac 1 m)^m  \mapsto \frac 1 e\approx0.368</script><p>即通过bootstrapping，D中有36.8%的样本未出现在$D’$中，于是可以将$D’$作为训练集，$D-D’$作为测试集，这样可以有1/3个未出现在训练集的样本用于测试。测试结果称为“包外估计”（out-of-bag estimate）。</p>
<h2 id="1-4-调参"><a href="#1-4-调参" class="headerlink" title="1.4 调参"></a>1.4 调参</h2><blockquote>
<p>我们在模型评估时往往用来确定算法和参数。当这些确定后，要用所有的D再训练一次，才是最终的模型。</p>
</blockquote>
<h1 id="2、性能度量"><a href="#2、性能度量" class="headerlink" title="2、性能度量"></a>2、性能度量</h1><p>回归最常用的是“均方误差”（mean squared error）</p>
<script type="math/tex; mode=display">
E(f;D) = \frac 1 m \sum_{i=1}^m(f(x_i)-y_i )^2</script><p>更一般的，对于数据分布D和概率密度函数$p(\cdot )$，均方误差可描述为</p>
<script type="math/tex; mode=display">
E(f;D) = \int_{x \in D}(f(x)-y)^2p(x)dx</script><p>分类的性能度量更复杂</p>
<h2 id="2-1-错误率和精度"><a href="#2-1-错误率和精度" class="headerlink" title="2.1 错误率和精度"></a>2.1 错误率和精度</h2><p>错误率：分类错误的样本占总样本的比例</p>
<p>精度：分类正确的样本占总样本的比例</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/模型集成/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/模型集成/" class="post-title-link" itemprop="url">模型集成</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-11 09:26:22" itemprop="dateModified" datetime="2018-02-11T09:26:22+08:00">2018-02-11</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/模型集成/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/模型集成/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jiqizhixin.com/articles/2018-01-14-8" target="_blank" rel="noopener">每个Kaggle冠军的获胜法门：揭秘Python中的模型集成</a></p>
<p><img src="https://image.jiqizhixin.com/uploads/wangeditor/c897487a-bf02-4023-9355-24c747d7ef62/43133image%20(1" alt="">.png)</p>
<p>Example Schematics of an ensemble.  An input array X is fed through two proprocessing pipelines and then to a set of base learners f(i). The ensemble combines all base learner predictions into a final prediction array P. </p>
<p>By the end of the post, you will:</p>
<ul>
<li>understand the fundamentals of ensembles</li>
<li>know how to code them</li>
<li>understand the main pitfalls and drawbacks of ensembles</li>
</ul>
<h2 id="Predicting-Republican-and-Democratic-donations"><a href="#Predicting-Republican-and-Democratic-donations" class="headerlink" title="Predicting Republican and Democratic donations"></a>Predicting Republican and Democratic donations</h2><p>we’ll use a data set on U.S. political contributions. The <a href="https://github.com/fivethirtyeight/data/tree/master/science-giving" target="_blank" rel="noopener">original data set</a> was prepared by <a href="https://fivethirtyeight.com/contributors/ben-wieder/" target="_blank" rel="noopener">Ben Wieder</a> at <a href="https://fivethirtyeight.com/" target="_blank" rel="noopener">FiveThirtyEight</a>, who dug around the U.S. government’s political contribution registry and found that when <a href="https://fivethirtyeight.com/features/when-scientists-donate-to-politicians-its-usually-to-democrats/" target="_blank" rel="noopener">scientists donate to politician, it’s usually to Democrats</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">### Import data</span></span><br><span class="line"><span class="comment"># Always good to set a seed for reproducibility</span></span><br><span class="line">SEED = <span class="number">222</span></span><br><span class="line">np.random.seed(SEED)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'input.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Training and test set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_test</span><span class="params">(test_size=<span class="number">0.95</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Split Data into train and test sets."""</span></span><br><span class="line">    y = <span class="number">1</span> * (df.cand_pty_affiliation == <span class="string">"REP"</span>)</span><br><span class="line">    X = df.drop([<span class="string">"cand_pty_affiliation"</span>], axis=<span class="number">1</span>)</span><br><span class="line">    X = pd.get_dummies(X, sparse=<span class="keyword">True</span>)</span><br><span class="line">    X.drop(X.columns[X.std() == <span class="number">0</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> train_test_split(X, y, test_size=test_size, random_state=SEED)</span><br><span class="line"></span><br><span class="line">xtrain, xtest, ytrain, ytest = get_train_test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A look at the data</span></span><br><span class="line">print(<span class="string">"\nExample data:"</span>)</span><br><span class="line">df.head()</span><br><span class="line"></span><br><span class="line">df.cand_pty_affiliation.value_counts(normalize=<span class="keyword">True</span>).plot(</span><br><span class="line">    kind=<span class="string">"bar"</span>, title=<span class="string">"Share of No. donations"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>This claim is based on the observation on the share of donations being made to Republicans and Democrats. However, there’s plenty more that can be said: for instance, which scientific discipline is most likely to make a Republican donation, and which state is most likely to make Democratic donations? We will go one step further and <em>predict</em> whether a donation is most likely to be a to a Republican or Democrat.</p>
<h2 id="What-is-an-ensemble"><a href="#What-is-an-ensemble" class="headerlink" title="What is an ensemble?"></a>What is an ensemble?</h2><p>Combining predictions from several models averages out idiosyncratic errors and yield better overall predictions.</p>
<p>How to combine predictions?</p>
<p>Machine learning is remarkably similar in classification problems: <strong>taking the most common class label prediction is equivalent to a majority voting rule</strong>. But there are many other ways to combine predictions, and more generally we can use a <strong>model to <em>learn</em></strong> how to best combine predictions.</p>
<h3 id="Understanding-ensembles-by-combining-decision-trees"><a href="#Understanding-ensembles-by-combining-decision-trees" class="headerlink" title="Understanding ensembles by combining decision trees"></a>Understanding ensembles by combining decision trees</h3><p>The deeper the tree, the more complex the patterns it can capture, but the <strong>more prone</strong> to overfitting it will be. Because of this, we will need an alternative way of building complex models of decision trees, and an ensemble of different decision trees is one such way.</p>
<p>We’ll use the below helper function to visualize our decision rules:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pydotplus  <span class="comment"># you can install pydotplus with: pip install pydotplus </span></span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_graph</span><span class="params">(clf, feature_names)</span>:</span></span><br><span class="line">    <span class="string">"""Print decision tree."""</span></span><br><span class="line">    graph = export_graphviz(</span><br><span class="line">        clf,</span><br><span class="line">        label=<span class="string">"root"</span>,</span><br><span class="line">        proportion=<span class="keyword">True</span>,</span><br><span class="line">        impurity=<span class="keyword">False</span>, </span><br><span class="line">        out_file=<span class="keyword">None</span>, </span><br><span class="line">        feature_names=feature_names,</span><br><span class="line">        class_names=&#123;<span class="number">0</span>: <span class="string">"D"</span>, <span class="number">1</span>: <span class="string">"R"</span>&#125;,</span><br><span class="line">        filled=<span class="keyword">True</span>,</span><br><span class="line">        rounded=<span class="keyword">True</span></span><br><span class="line">    )</span><br><span class="line">    graph = pydotplus.graph_from_dot_data(graph)  </span><br><span class="line">    <span class="keyword">return</span> Image(graph.create_png())</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/集成学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/集成学习/" class="post-title-link" itemprop="url">集成学习</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-16 16:41:49" itemprop="dateModified" datetime="2018-08-16T16:41:49+08:00">2018-08-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/集成学习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/集成学习/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>个体学习器一般是弱学习器。</p>
<blockquote>
<p> 弱学习器是指泛华性能略优于随机猜测的学习器，例如二分上略高于50%的学习器。</p>
</blockquote>
<p>要获得好的集成，个体学习器应“好而不同”，即个体学习器要有一定的<strong>准确性和多样性</strong>（学习器之间有差异）。</p>
<p>理论上，假设个体学习器的误差是相互独立，那么随着学习器数量增大，集成的错误率将指数下降，最终趋向于零。</p>
<p>但实际上不可能相互独立。且<strong>准确性和多样性本身就是矛盾的</strong>，追求准确性就要牺牲多样性。所以<strong>如何产生并结合“好而不同”的学习器，是集成学习研究的核心</strong>。</p>
<p>根据集成的方式不同，</p>
<p>1）个体学习器存在强依赖性，必须串行生成，如Boosting；</p>
<p>2）个体学习器间不存在强依赖关系，可同时并行生成，如Bagging和随机森林。</p>
<h1 id="mic或stacking方法"><a href="#mic或stacking方法" class="headerlink" title="mic或stacking方法"></a>mic或stacking方法</h1><p><a href="https://blog.csdn.net/sb19931201/article/details/56315689?locationNum=1&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/sb19931201/article/details/56315689?locationNum=1&amp;fps=1</a> 从这篇帖子来</p>
<p><a href="https://blog.csdn.net/a358463121/article/details/53054686#t18" target="_blank" rel="noopener">https://blog.csdn.net/a358463121/article/details/53054686#t18</a></p>
<p><a href="https://zhuanlan.zhihu.com/jlbookworm" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/jlbookworm</a></p>
<p><a href="https://blog.csdn.net/wstcjf/article/details/77989963" target="_blank" rel="noopener">https://blog.csdn.net/wstcjf/article/details/77989963</a> 文章的思路有点问题？</p>
<p><a href="https://blog.csdn.net/xiaoliuzz/article/details/79298841" target="_blank" rel="noopener">https://blog.csdn.net/xiaoliuzz/article/details/79298841</a></p>
<p><a href="https://blog.csdn.net/yc1203968305/article/details/73526615" target="_blank" rel="noopener">https://blog.csdn.net/yc1203968305/article/details/73526615</a></p>
<p><a href="https://www.cnblogs.com/zhizhan/p/5051881.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhizhan/p/5051881.html</a></p>
<p><a href="https://mlwave.com/kaggle-ensembling-guide/" target="_blank" rel="noopener">https://mlwave.com/kaggle-ensembling-guide/</a></p>
<h1 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h1><p><a href="http://tech.ifeng.com/a/20170929/44704115_0.shtml" target="_blank" rel="noopener">Kaggle机器学习之模型融合（stacking）心得</a></p>
<p><a href="https://www.kaggle.com/arthurtok/introduction-to-ensembling-stacking-in-python" target="_blank" rel="noopener">Introduction to Ensembling/Stacking in Python</a> </p>
<p><a href="https://www.kdnuggets.com/2017/02/stacking-models-imropved-predictions.html" target="_blank" rel="noopener">Stacking Models for Improved Predictions</a></p>
<h2 id="使用sklearn进行集成学习——理论"><a href="#使用sklearn进行集成学习——理论" class="headerlink" title="使用sklearn进行集成学习——理论"></a><a href="https://www.cnblogs.com/jasonfreak/p/5657196.html" target="_blank" rel="noopener">使用sklearn进行集成学习——理论</a></h2><p>1 前言<br>2 集成学习是什么？<br>3 偏差和方差<br>　　3.1 模型的偏差和方差是什么？<br>　　3.2 bagging的偏差和方差<br>　　3.3 boosting的偏差和方差<br>　　3.4 模型的独立性<br>　　3.5 小结<br>4 Gradient Boosting<br>　　4.1 拟合残差<br>　　4.2 拟合反向梯度<br>　　　　4.2.1 契机：引入损失函数<br>　　　　4.2.2 难题一：任意损失函数的最优化<br>　　　　4.2.3 难题二：无法对测试样本计算反向梯度<br>　　4.3 常见的损失函数<br>　　4.4 步子太大容易扯着蛋：缩减<br>　　4.5 初始模型<br>　　4.5 Gradient Tree Boosting<br>　　4.6 小结<br>5 总结<br>6 参考资料</p>
<hr>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>　　很多人在竞赛（Kaggle，天池等）或工程实践中使用了集成学习（例如，RF、GTB等），确实也取得了不错的效果，在保证准确度的同时也提升了模型防止过拟合的能力。但是，我们真的用对了集成学习吗？</p>
<p>　　sklearn提供了sklearn.ensemble库，支持众多集成学习算法和模型。恐怕大多数人使用这些工具时，要么使用默认参数，要么根据模型在测试集上的性能试探性地进行调参（当然，完全不懂的参数还是不动算了），要么将调参的工作丢给调参算法（网格搜索等）。这样并不能真正地称为“会”用sklearn进行集成学习。</p>
<p>　　我认为，学会调参是进行集成学习工作的前提。然而，第一次遇到这些算法和模型时，肯定会被其丰富的参数所吓到，要知道，教材上教的伪代码可没这么多参数啊！！！没关系，暂时，我们只要记住一句话：参数可分为两种，一种是影响模型在训练集上的准确度或影响防止过拟合能力的参数；另一种不影响这两者的其他参数。模型在样本总体上的准确度（后简称准确度）由其在训练集上的准确度及其防止过拟合的能力所共同决定，所以在调参时，我们主要对第一种参数进行调整，最终达到的效果是：模型在训练集上的准确度和防止过拟合能力的大和谐！</p>
<p>　　本篇博文将详细阐述模型参数背后的理论知识，在下篇博文中，我们将对最热门的两个模型Random Forrest和Gradient Tree Boosting（含分类和回归，所以共4个模型）进行具体的参数讲解。如果你实在无法静下心来学习理论，你也可以在下篇博文中找到最直接的调参指导，虽然我不赞同这么做。</p>
<hr>
<h1 id="2-集成学习是什么？"><a href="#2-集成学习是什么？" class="headerlink" title="2 集成学习是什么？"></a>2 集成学习是什么？</h1><p>　　我们还是花一点时间来说明一下集成学习是什么，如果对此有一定基础的同学可以跳过本节。简单来说，集成学习是一种技术框架，其按照不同的思路来组合基础模型，从而达到其利断金的目的。</p>
<p>　　目前，有三种常见的集成学习框架：bagging，boosting和stacking。国内，南京大学的周志华教授对集成学习有很深入的研究，其在09年发表的一篇概述性论文<a href="http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/springerEBR09.pdf" target="_blank" rel="noopener">《</a><a href="http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/springerEBR09.pdf" target="_blank" rel="noopener">Ensemble Learning》</a>对这三种集成学习框架有了明确的定义，概括如下：</p>
<p> 　　bagging：从训练集从进行子抽样组成每个基模型所需要的子训练集，对所有基模型预测的结果进行综合产生最终的预测结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717135005498-1140287801.jpg" alt="img"></p>
<p>　　boosting：训练过程为阶梯状，基模型按次序一一进行训练（实现上可以做到并行），基模型的训练集按照某种策略每次都进行一定的转化。对所有基模型预测的结果进行线性综合产生最终的预测结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717135023373-1810846145.jpg" alt="img"></p>
<p>　　stacking：将训练好的所有基模型对训练基进行预测，第j个基模型对第i个训练样本的预测值将作为新的训练集中第i个样本的第j个特征值，最后基于新的训练集进行训练。同理，预测的过程也要先经过所有基模型的预测形成新的测试集，最后再对测试集进行预测：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160716073722420-208134951.jpg" alt="img"></p>
<p>　　有了这些基本概念之后，直觉将告诉我们，由于不再是单一的模型进行预测，所以模型有了“集思广益”的能力，也就不容易产生过拟合现象。但是，直觉是不可靠的，接下来我们将从模型的偏差和方差入手，彻底搞清楚这一问题。</p>
<hr>
<h1 id="3-偏差和方差"><a href="#3-偏差和方差" class="headerlink" title="3 偏差和方差"></a>3 偏差和方差</h1><p>　　广义的偏差（bias）描述的是预测值和真实值之间的差异，方差（variance）描述距的是预测值作为随机变量的离散程度。<a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" target="_blank" rel="noopener">《Understanding the Bias-Variance Tradeoff》</a>当中有一副图形象地向我们展示了偏差和方差的关系：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160716124330623-527064401.jpg" alt="img"></p>
<h2 id="3-1-模型的偏差和方差是什么？"><a href="#3-1-模型的偏差和方差是什么？" class="headerlink" title="3.1 模型的偏差和方差是什么？"></a>3.1 模型的偏差和方差是什么？</h2><p>　　模型的偏差是一个相对来说简单的概念：训练出来的模型在训练集上的准确度。</p>
<p>　　要解释模型的方差，首先需要重新审视模型：模型是随机变量。设样本容量为n的训练集为随机变量的集合(X1, X2, …, Xn)，那么模型是以这些随机变量为输入的随机变量函数（其本身仍然是随机变量）：F(X1, X2, …, Xn)。抽样的随机性带来了模型的随机性。</p>
<p>　　定义随机变量的值的差异是计算方差的前提条件，通常来说，我们遇到的都是数值型的随机变量，数值之间的差异再明显不过（减法运算）。但是，模型的差异性呢？我们可以理解模型的差异性为模型的结构差异，例如：线性模型中权值向量的差异，树模型中树的结构差异等。在研究模型方差的问题上，我们并不需要对方差进行定量计算，只需要知道其概念即可。</p>
<p>　　研究模型的方差有什么现实的意义呢？我们认为方差越大的模型越容易过拟合：假设有两个训练集A和B，经过A训练的模型Fa与经过B训练的模型Fb差异很大，这意味着Fa在类A的样本集合上有更好的性能，而Fb反之，这便是我们所说的过拟合现象。</p>
<p>　　我们常说集成学习框架中的基模型是弱模型，通常来说弱模型是偏差高（在训练集上准确度低）方差小（防止过拟合能力强）的模型。但是，并不是所有集成学习框架中的基模型都是弱模型。bagging和stacking中的基模型为强模型（偏差低方差高），boosting中的基模型为弱模型。</p>
<p>　　在bagging和boosting框架中，通过计算基模型的期望和方差，我们可以得到模型整体的期望和方差。为了简化模型，我们假设基模型的权重、方差及两两间的相关系数相等。由于bagging和boosting的基模型都是线性组成的，那么有：</p>
<p> <img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160716145131217-650617034.png" alt="img"></p>
<h2 id="3-2-bagging的偏差和方差"><a href="#3-2-bagging的偏差和方差" class="headerlink" title="3.2 bagging的偏差和方差"></a>3.2 bagging的偏差和方差</h2><p>　　对于bagging来说，每个基模型的权重等于1/m且期望近似相等（子训练集都是从原训练集中进行子抽样），故我们可以进一步化简得到：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160716145206701-383430284.png" alt="img"></p>
<p>　　根据上式我们可以看到，整体模型的期望近似于基模型的期望，这也就意味着整体模型的偏差和基模型的偏差近似。同时，整体模型的方差小于等于基模型的方差（当相关性为1时取等号），随着基模型数（m）的增多，整体模型的方差减少，从而防止过拟合的能力增强，模型的准确度得到提高。但是，模型的准确度一定会无限逼近于1吗？并不一定，当基模型数增加到一定程度时，方差公式第二项的改变对整体方差的作用很小，防止过拟合的能力达到极限，这便是准确度的极限了。另外，在此我们还知道了为什么bagging中的基模型一定要为强模型，否则就会导致整体模型的偏差度低，即准确度低。</p>
<p>　　Random Forest是典型的基于bagging框架的模型，其在bagging的基础上，进一步降低了模型的方差。Random Fores中基模型是树模型，在树的内部节点分裂过程中，不再是将所有特征，而是随机抽样一部分特征纳入分裂的候选项。这样一来，基模型之间的相关性降低，从而在方差公式中，第一项显著减少，第二项稍微增加，整体方差仍是减少。</p>
<h2 id="3-3-boosting的偏差和方差"><a href="#3-3-boosting的偏差和方差" class="headerlink" title="3.3 boosting的偏差和方差"></a>3.3 boosting的偏差和方差</h2><p>　　对于boosting来说，基模型的训练集抽样是强相关的，那么模型的相关系数近似等于1，故我们也可以针对boosting化简公式为：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717142500264-1717908455.png" alt="img"></p>
<p>　　通过观察整体方差的表达式，我们容易发现，若基模型不是弱模型，其方差相对较大，这将导致整体模型的方差很大，即无法达到防止过拟合的效果。因此，boosting框架中的基模型必须为弱模型。</p>
<p>　　因为基模型为弱模型，导致了每个基模型的准确度都不是很高（因为其在训练集上的准确度不高）。随着基模型数的增多，整体模型的期望值增加，更接近真实值，因此，整体模型的准确度提高。但是准确度一定会无限逼近于1吗？仍然并不一定，因为训练过程中准确度的提高的主要功臣是整体模型在训练集上的准确度提高，而随着训练的进行，整体模型的方差变大，导致防止过拟合的能力变弱，最终导致了准确度反而有所下降。</p>
<p>　　基于boosting框架的Gradient Tree Boosting模型中基模型也为树模型，同Random Forrest，我们也可以对特征进行随机抽样来使基模型间的相关性降低，从而达到减少方差的效果。</p>
<h2 id="3-4-模型的独立性"><a href="#3-4-模型的独立性" class="headerlink" title="3.4 模型的独立性"></a>3.4 模型的独立性</h2><p>　　聪明的读者这时肯定要问了，如何衡量基模型的独立性？我们说过，抽样的随机性决定了模型的随机性，如果两个模型的训练集抽样过程不独立，则两个模型则不独立。这时便有一个天大的陷阱在等着我们：bagging中基模型的训练样本都是独立的随机抽样，但是基模型却不独立呢？</p>
<p>　　我们讨论模型的随机性时，抽样是针对于样本的整体。而bagging中的抽样是针对于训练集（整体的子集），所以并不能称其为对整体的独立随机抽样。那么到底bagging中基模型的相关性体现在哪呢？在知乎问答<a href="https://www.zhihu.com/question/26760839" target="_blank" rel="noopener">《为什么说bagging是减少variance，而boosting是减少bias?》</a>中请教用户<a href="https://www.zhihu.com/people/guo-ni-he" target="_blank" rel="noopener">“过拟合”</a>后，我总结bagging的抽样为两个过程：</p>
<ol>
<li>样本抽样：整体模型F(X1, X2, …, Xn)中各输入随机变量（X1, X2, …, Xn）对样本的抽样</li>
<li>子抽样：从整体模型F(X1, X2, …, Xn)中随机抽取若干输入随机变量成为基模型的输入随机变量</li>
</ol>
<p>　　假若在子抽样的过程中，两个基模型抽取的输入随机变量有一定的重合，那么这两个基模型对整体样本的抽样将不再独立，这时基模型之间便具有了相关性。</p>
<h2 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h2><p>　　还记得调参的目标吗：模型在训练集上的准确度和防止过拟合能力的大和谐！为此，我们目前做了一些什么工作呢？</p>
<ol>
<li>使用模型的偏差和方差来描述其在训练集上的准确度和防止过拟合的能力</li>
<li>对于bagging来说，整体模型的偏差和基模型近似，随着训练的进行，整体模型的方差降低</li>
<li>对于boosting来说，整体模型的初始偏差较高，方差较低，随着训练的进行，整体模型的偏差降低（虽然也不幸地伴随着方差增高），当训练过度时，因方差增高，整体模型的准确度反而降低</li>
<li>整体模型的偏差和方差与基模型的偏差和方差息息相关</li>
</ol>
<p>　　这下总算有点开朗了，那些让我们抓狂的参数，现在可以粗略地分为两类了：控制整体训练过程的参数和基模型的参数，这两类参数都在影响着模型在训练集上的准确度以及防止过拟合的能力。</p>
<hr>
<h1 id="4-Gradient-Boosting"><a href="#4-Gradient-Boosting" class="headerlink" title="4 Gradient Boosting"></a>4 Gradient Boosting</h1><p>　　对基于Gradient Boosting框架的模型的进行调试时，我们会遇到一个重要的概念：损失函数。在本节中，我们将把损失函数的“今生来世”讲个清楚！</p>
<p>　　基于boosting框架的整体模型可以用线性组成式来描述，其中h<a href="x">i</a>为基模型与其权值的乘积：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717144731264-398372888.png" alt="img"></p>
<p>　　根据上式，整体模型的训练目标是使预测值F(x)逼近真实值y，也就是说要让每一个基模型的预测值逼近各自要预测的部分真实值。由于要同时考虑所有基模型，导致了整体模型的训练变成了一个非常复杂的问题。所以，研究者们想到了一个贪心的解决手段：每次只训练一个基模型。那么，现在改写整体模型为迭代式：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717144844795-1514741556.png" alt="img"></p>
<p>　　这样一来，每一轮迭代中，只要集中解决一个基模型的训练问题：使F<a href="x">i</a>逼近真实值y。</p>
<h2 id="4-1-拟合残差"><a href="#4-1-拟合残差" class="headerlink" title="4.1 拟合残差"></a>4.1 拟合残差</h2><p>　　使F<a href="x">i</a>逼近真实值，其实就是使h<a href="x">i</a>逼近真实值和上一轮迭代的预测值F<a href="x">i-1</a>之差，即残差（y-F<a href="x">i-1</a>）。最直接的做法是构建基模型来拟合残差，在博文<a href="http://blog.csdn.net/w28971023/article/details/8240756" target="_blank" rel="noopener">《GBDT（MART） 迭代决策树入门教程 | 简介》</a>中，作者举了一个生动的例子来说明通过基模型拟合残差，最终达到整体模型F(x)逼近真实值。</p>
<p>　　研究者发现，残差其实是最小均方损失函数的关于预测值的反向梯度：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717152356576-837065946.png" alt="img"></p>
<p>　　也就是说，若F<a href="x">i-1</a>加上拟合了反向梯度的h<a href="x">i</a>得到F<a href="x">i</a>，该值可能将导致平方差损失函数降低，预测的准确度提高！这显然不是巧合，但是研究者们野心更大，希望能够创造出一种对任意损失函数都可行的训练方法，那么仅仅拟合残差是不恰当的了。</p>
<h2 id="4-2-拟合反向梯度"><a href="#4-2-拟合反向梯度" class="headerlink" title="4.2 拟合反向梯度"></a>4.2 拟合反向梯度</h2><h3 id="4-2-1-契机：引入任意损失函数"><a href="#4-2-1-契机：引入任意损失函数" class="headerlink" title="4.2.1 契机：引入任意损失函数"></a>4.2.1 契机：引入任意损失函数</h3><p>　　引入任意损失函数后，我们可以定义整体模型的迭代式如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717155418592-692164582.png" alt="img"></p>
<p>　　在这里，损失函数被定义为<a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%87%BD" target="_blank" rel="noopener">泛函</a>。</p>
<h3 id="4-2-2-难题一：任意损失函数的最优化"><a href="#4-2-2-难题一：任意损失函数的最优化" class="headerlink" title="4.2.2 难题一：任意损失函数的最优化"></a>4.2.2 难题一：任意损失函数的最优化</h3><p>　　对任意损失函数（且是泛函）的最优化是困难的。我们需要打破思维的枷锁，将整体损失函数L’定义为n元普通函数（n为样本容量），损失函数L定义为2元普通函数（记住！！！这里的损失函数不再是泛函！！！）：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717161734873-1080465986.png" alt="img"></p>
<p>　　我们不妨使用<a href="https://en.wikipedia.org/wiki/Method_of_steepest_descent" target="_blank" rel="noopener">梯度最速下降法</a>来解决整体损失函数L’最小化的问题，先求整体损失函数的反向梯度：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717161743857-1762234391.png" alt="img"></p>
<p>　　假设已知样本x的当前预测值为F<a href="x">i-1</a>，下一步将预测值按照反向梯度，依照步长为r[i]，进行更新：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717162353389-352979333.png" alt="img"></p>
<p>　　步长r[i]不是固定值，而是设计为：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717162221748-1981866230.png" alt="img"></p>
<h3 id="4-2-3-难题二：无法对测试样本计算反向梯度"><a href="#4-2-3-难题二：无法对测试样本计算反向梯度" class="headerlink" title="4.2.3 难题二：无法对测试样本计算反向梯度"></a>4.2.3 难题二：无法对测试样本计算反向梯度</h3><p>　　问题又来了，由于测试样本中y是未知的，所以无法求反向梯度。这正是Gradient Boosting框架中的基模型闪亮登场的时刻！在第i轮迭代中，我们创建训练集如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717162908686-1639692645.png" alt="img"></p>
<p>　　也就是说，让基模型拟合反向梯度函数，这样我们就可以做到只输入x这一个参数，就可求出其对应的反向梯度了（当然，通过基模型预测出来的反向梯度并不是准确的，这也提供了泛化整体模型的机会）。</p>
<p>　　综上，假设第i轮迭代中，根据新训练集训练出来的基模型为f<a href="x">i</a>，那么最终的迭代公式为：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717171931342-64219972.png" alt="img"></p>
<h2 id="4-3-常见的损失函数"><a href="#4-3-常见的损失函数" class="headerlink" title="4.3 常见的损失函数"></a>4.3 常见的损失函数</h2><p>　　ls：最小均方回归中用到的损失函数。在之前我们已经谈到，从拟合残差的角度来说，残差即是该损失函数的反向梯度值（所以又称反向梯度为伪残差）。不同的是，从拟合残差的角度来说，步长是无意义的。该损失函数是sklearn中Gradient Tree Boosting回归模型默认的损失函数。</p>
<p>　　deviance：<a href="http://www.duzelong.com/wordpress/201507/archives1326/" target="_blank" rel="noopener">逻辑回归</a>中用到的损失函数。熟悉逻辑回归的读者肯定还记得，逻辑回归本质是求极大似然解，其认为样本服从几何分布，样本属于某类别的概率可以logistic函数表达。所以，如果该损失函数可用在多类别的分类问题上，故其是sklearn中Gradient Tree Boosting分类模型默认的损失函数。</p>
<p>　　exponential：指数损失函数，表达式为：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717164817170-1319916901.png" alt="img"></p>
<p>　　对该损失函数求反向梯度得：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717165216123-16910201.png" alt="img"></p>
<p>　　这时，在第i轮迭代中，新训练集如下：</p>
<p> <img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717165246186-1781792701.png" alt="img"></p>
<p>　　脑袋里有什么东西浮出水面了吧？让我们看看<a href="http://breezedeus.github.io/2015/07/12/breezedeus-adaboost-exponential-loss.html" target="_blank" rel="noopener">Adaboost算法</a>中，第i轮迭代中第j个样本权值的更新公式：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717170109811-1251363012.png" alt="img"></p>
<p>　　样本的权值什么时候会用到呢？计算第i轮损失函数的时候会用到：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717170902529-315971230.png" alt="img"></p>
<p>　　让我们再回过头来，看看使用指数损失函数的Gradient Boosting计算第i轮损失函数：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717171050389-2042221750.png" alt="img"></p>
<p>　　天呐，两个公式就差了一个对权值的归一项。这并不是巧合，当损失函数是指数损失时，Gradient Boosting相当于二分类的Adaboost算法。是的，指数损失仅能用于二分类的情况。</p>
<h2 id="4-4-步子太大容易扯着蛋：缩减"><a href="#4-4-步子太大容易扯着蛋：缩减" class="headerlink" title="4.4 步子太大容易扯着蛋：缩减"></a>4.4 步子太大容易扯着蛋：缩减</h2><p>　　缩减也是一个相对显见的概念，也就是说使用Gradient Boosting时，每次学习的步长缩减一点。这有什么好处呢？缩减思想认为每次走一小步，多走几次，更容易逼近真实值。如果步子迈大了，使用最速下降法时，容易迈过最优点。将缩减代入迭代公式：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717172203889-897514111.png" alt="img"></p>
<p> 　　缩减需要配合基模型数一起使用，当缩减率v降低时，基模型数要配合增大，这样才能提高模型的准确度。</p>
<h2 id="4-5-初始模型"><a href="#4-5-初始模型" class="headerlink" title="4.5 初始模型"></a>4.5 初始模型</h2><p>　　还有一个不那么起眼的问题，初始模型F<a href="x">0</a>是什么呢？如果没有定义初始模型，整体模型的迭代式一刻都无法进行！所以，我们定义初始模型为：</p>
<p><img src="https://images2015.cnblogs.com/blog/927391/201607/927391-20160717172644920-1113326686.png" alt="img"></p>
<p>　　根据上式可知，对于不同的损失函数来说，初始模型也是不一样的。对所有的样本来说，根据初始模型预测出来的值都一样。</p>
<h2 id="4-5-Gradient-Tree-Boosting"><a href="#4-5-Gradient-Tree-Boosting" class="headerlink" title="4.5 Gradient Tree Boosting"></a>4.5 Gradient Tree Boosting</h2><p>　　终于到了备受欢迎的Gradient Tree Boosting模型了！但是，可讲的却已经不多了。我们已经知道了该模型的基模型是树模型，并且可以通过对特征的随机抽样进一步减少整体模型的方差。我们可以在维基百科的<a href="https://en.wikipedia.org/wiki/Gradient_boosting" target="_blank" rel="noopener">Gradient Boosting</a>词条中找到其伪代码实现。</p>
<h2 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h2><p>　　到此，读者应当很清楚Gradient Boosting中的损失函数有什么意义了。要说偏差描述了模型在训练集准确度，则损失函数则是描述该准确度的间接量纲。也就是说，模型采用不同的损失函数，其训练过程会朝着不同的方向进行！</p>
<hr>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>　　磨刀不误砍柴功，我们花了这么多时间来学习必要的理论，我强调一次：必要的理论！集成学习模型的调参工作的核心就是找到合适的参数，能够使整体模型在训练集上的准确度和防止过拟合的能力达到协调，从而达到在样本总体上的最佳准确度。有了本文的理论知识铺垫，在下篇中，我们将对Random Forest和Gradient Tree Boosting中的每个参数进行详细阐述，同时也有一些小试验证明我们的结论。</p>
<hr>
<h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6 参考资料"></a>6 参考资料</h1><ol>
<li><a href="http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/springerEBR09.pdf" target="_blank" rel="noopener">《</a><a href="http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/springerEBR09.pdf" target="_blank" rel="noopener">Ensemble Learning》</a></li>
<li><a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" target="_blank" rel="noopener">《Understanding the Bias-Variance Tradeoff》</a></li>
<li><a href="https://www.zhihu.com/question/26760839" target="_blank" rel="noopener">《为什么说bagging是减少variance，而boosting是减少bias?》</a></li>
<li><a href="http://blog.csdn.net/w28971023/article/details/8240756" target="_blank" rel="noopener">《GBDT（MART） 迭代决策树入门教程 | 简介》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%87%BD" target="_blank" rel="noopener">泛函</a></li>
<li><a href="https://en.wikipedia.org/wiki/Method_of_steepest_descent" target="_blank" rel="noopener">梯度最速下降法</a></li>
<li><a href="http://www.duzelong.com/wordpress/201507/archives1326/" target="_blank" rel="noopener">《logistic regression(二分类、多分类)》</a></li>
<li><a href="http://breezedeus.github.io/2015/07/12/breezedeus-adaboost-exponential-loss.html" target="_blank" rel="noopener">《Adaboost与指数损失》</a></li>
</ol>
<h2 id="使用sklearn进行集成学习——实践"><a href="#使用sklearn进行集成学习——实践" class="headerlink" title="使用sklearn进行集成学习——实践"></a><a href="https://www.cnblogs.com/jasonfreak/p/5720137.html" target="_blank" rel="noopener">使用sklearn进行集成学习——实践</a></h2><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>1 Random Forest和Gradient Tree Boosting参数详解<br>2 如何调参？<br>　　2.1 调参的目标：偏差和方差的协调<br>　　2.2 参数对整体模型性能的影响<br>　　2.3 一个朴实的方案：贪心的坐标下降法<br>　　　　2.3.1 Random Forest调参案例：Digit Recognizer<br>　　　　　　2.3.1.1 调整过程影响类参数<br>　　　　　　2.3.1.2 调整子模型影响类参数<br>　　　　2.3.2 Gradient Tree Boosting调参案例：Hackathon3.x<br>　　　　　　2.3.2.1 调整过程影响类参数<br>　　　　　　2.3.2.2 调整子模型影响类参数<br>　　　　　　2.3.2.3 杀一记回马枪<br>　　2.4 “局部最优解”（温馨提示：看到这里有彩蛋！）<br>　　2.5 类别不均衡的陷阱<br>3 总结<br>4 参考资料</p>
<hr>
<h1 id="1-Random-Forest和Gradient-Tree-Boosting参数详解"><a href="#1-Random-Forest和Gradient-Tree-Boosting参数详解" class="headerlink" title="1 Random Forest和Gradient Tree Boosting参数详解"></a>1 Random Forest和Gradient Tree Boosting参数详解</h1><p>　　在sklearn.ensemble库中，我们可以找到Random Forest分类和回归的实现：RandomForestClassifier和RandomForestRegression，Gradient Tree Boosting分类和回归的实现：GradientBoostingClassifier和GradientBoostingRegression。有了这些模型后，立马上手操练起来？少侠请留步！且听我说一说，使用这些模型时常遇到的问题：</p>
<ul>
<li>明明模型调教得很好了，可是效果离我的想象总有些偏差？——模型训练的第一步就是要定好目标，往错误的方向走太多也是后退。</li>
<li>凭直觉调了某个参数，可是居然没有任何作用，有时甚至起到反作用？——定好目标后，接下来就是要确定哪些参数是影响目标的，其对目标是正影响还是负影响，影响的大小。</li>
<li>感觉训练结束遥遥无期，sklearn只是个在小数据上的玩具？——虽然sklearn并不是基于分布式计算环境而设计的，但我们还是可以通过某些策略提高训练的效率。</li>
<li>模型开始训练了，但是训练到哪一步了呢？——饱暖思淫欲啊，目标，性能和效率都得了满足后，我们有时还需要有别的追求，例如训练过程的输出，袋外得分计算等等。</li>
</ul>
<p>　　通过总结这些常见的问题，我们可以把模型的参数分为4类：目标类、性能类、效率类和附加类。下表详细地展示了4个模型参数的意义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>类型</strong></th>
<th><strong>RandomForestClassifier</strong></th>
<th><strong>RandomForestRegressor</strong></th>
<th><strong>GradientBoostingClassifier</strong></th>
<th><strong>GradientBoostingRegressor</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>loss</td>
<td>目标</td>
<td></td>
<td></td>
<td>损失函数● exponential：模型等同AdaBoost★ deviance：和Logistic Regression的损失函数一致</td>
<td>损失函数● exponential：模型等同AdaBoost★ deviance：和Logistic Regression的损失函数一致</td>
</tr>
<tr>
<td>alpha</td>
<td>目标</td>
<td></td>
<td></td>
<td>损失函数为huber或quantile的时，alpha为损失函数中的参数</td>
<td>损失函数为huber或quantile的时，alpha为损失函数中的参数</td>
</tr>
<tr>
<td>class_weight</td>
<td>目标</td>
<td>类别的权值</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>n_estimators</td>
<td>性能</td>
<td>子模型的数量● int：个数★ 10：默认值</td>
<td>子模型的数量● int：个数★ 10：默认值</td>
<td>子模型的数量● int：个数★ 100：默认值</td>
<td>子模型的数量● int：个数★ 100：默认值</td>
</tr>
<tr>
<td>learning_rate</td>
<td>性能</td>
<td></td>
<td></td>
<td>学习率（缩减）</td>
<td>学习率（缩减）</td>
</tr>
<tr>
<td>criterion</td>
<td>性能</td>
<td>判断节点是否继续分裂采用的计算方法● entropy★ gini</td>
<td>判断节点是否继续分裂采用的计算方法★ mse</td>
<td></td>
<td></td>
</tr>
<tr>
<td>max_features</td>
<td>性能</td>
<td>节点分裂时参与判断的最大特征数● int：个数● float：占所有特征的百分比★ auto：所有特征数的开方● sqrt：所有特征数的开方● log2：所有特征数的log2值● None：等于所有特征数</td>
<td>节点分裂时参与判断的最大特征数● int：个数● float：占所有特征的百分比★ auto：所有特征数的开方● sqrt：所有特征数的开方● log2：所有特征数的log2值● None：等于所有特征数</td>
<td>节点分裂时参与判断的最大特征数● int：个数● float：占所有特征的百分比● auto：所有特征数的开方● sqrt：所有特征数的开方● log2：所有特征数的log2值★ None：等于所有特征数</td>
<td>节点分裂时参与判断的最大特征数● int：个数● float：占所有特征的百分比● auto：所有特征数的开方● sqrt：所有特征数的开方● log2：所有特征数的log2值★ None：等于所有特征数</td>
</tr>
<tr>
<td>max_depth</td>
<td>性能</td>
<td>最大深度，如果max_leaf_nodes参数指定，则忽略● int：深度★ None：树会生长到所有叶子都分到一个类，或者某节点所代表的样本数已小于min_samples_split</td>
<td>最大深度，如果max_leaf_nodes参数指定，则忽略● int：深度★ None：树会生长到所有叶子都分到一个类，或者某节点所代表的样本数已小于min_samples_split</td>
<td>最大深度，如果max_leaf_nodes参数指定，则忽略● int：深度★ 3：默认值</td>
<td>最大深度，如果max_leaf_nodes参数指定，则忽略● int：深度★ 3：默认值</td>
</tr>
<tr>
<td>min_samples_split</td>
<td>性能</td>
<td>分裂所需的最小样本数● int：样本数★ 2：默认值</td>
<td>分裂所需的最小样本数● int：样本数★ 2：默认值</td>
<td>分裂所需的最小样本数● int：样本数★ 2：默认值</td>
<td>分裂所需的最小样本数● int：样本数★ 2：默认值</td>
</tr>
<tr>
<td>min_samples_leaf</td>
<td>性能</td>
<td>叶节点最小样本数● int：样本数★ 1：默认值</td>
<td>叶节点最小样本数● int：样本数★ 1：默认值</td>
<td>叶节点最小样本数● int：样本数★ 1：默认值</td>
<td>叶节点最小样本数● int：样本数★ 1：默认值</td>
</tr>
<tr>
<td>min_weight_fraction_leaf</td>
<td>性能</td>
<td>叶节点最小样本权重总值● float：权重总值★ 0：默认值</td>
<td>叶节点最小样本权重总值● float：权重总值★ 0：默认值</td>
<td>叶节点最小样本权重总值● float：权重总值★ 0：默认值</td>
<td>叶节点最小样本权重总值● float：权重总值★ 0：默认值</td>
</tr>
<tr>
<td>max_leaf_nodes</td>
<td>性能</td>
<td>最大叶节点数● int：个数★ None：不限制叶节点数</td>
<td>最大叶节点数● int：个数★ None：不限制叶节点数</td>
<td>最大叶节点数● int：个数★ None：不限制叶节点数</td>
<td>最大叶节点数● int：个数★ None：不限制叶节点数</td>
</tr>
<tr>
<td>bootstrap</td>
<td>性能</td>
<td>是否bootstrap对样本抽样● False：子模型的样本一致，子模型间强相关★ True：默认值</td>
<td>是否bootstrap对样本抽样● False：子模型的样本一致，子模型间强相关★ True：默认值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>subsample</td>
<td>性能</td>
<td></td>
<td></td>
<td>子采样率● float：采样率★ 1.0：默认值</td>
<td>子采样率● float：采样率★ 1.0：默认值</td>
</tr>
<tr>
<td>init</td>
<td>性能</td>
<td></td>
<td></td>
<td>初始子模型</td>
<td>初始子模型</td>
</tr>
<tr>
<td>n_jobs</td>
<td>效率</td>
<td>并行数● int：个数● -1：跟CPU核数一致★ 1:默认值</td>
<td>并行数● int：个数● -1：跟CPU核数一致★ 1:默认值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>warm_start</td>
<td>效率</td>
<td>是否热启动，如果是，则下一次训练是以追加树的形式进行● bool：热启动★ False：默认值</td>
<td>是否热启动，如果是，则下一次训练是以追加树的形式进行● bool：热启动★ False：默认值</td>
<td>是否热启动，如果是，则下一次训练是以追加树的形式进行● bool：热启动★ False：默认值</td>
<td>是否热启动，如果是，则下一次训练是以追加树的形式进行● bool：热启动★ False：默认值</td>
</tr>
<tr>
<td>presort</td>
<td>效率</td>
<td></td>
<td></td>
<td>是否预排序,预排序可以加速查找最佳分裂点，对于稀疏数据不管用● Bool★ auto：非稀疏数据则预排序，若稀疏数据则不预排序</td>
<td>是否预排序,预排序可以加速查找最佳分裂点，对于稀疏数据不管用● Bool★ auto：非稀疏数据则预排序，若稀疏数据则不预排序</td>
</tr>
<tr>
<td>oob_score</td>
<td>附加</td>
<td>是否计算<a href="http://scikit-learn.org/stable/auto_examples/ensemble/plot_ensemble_oob.html" target="_blank" rel="noopener">袋外得分</a>★ False：默认值</td>
<td>是否计算<a href="http://scikit-learn.org/stable/auto_examples/ensemble/plot_ensemble_oob.html" target="_blank" rel="noopener">袋外得分</a>★ False：默认值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>random_state</td>
<td>附加</td>
<td>随机器对象</td>
<td>随机器对象</td>
<td>随机器对象</td>
<td>随机器对象</td>
</tr>
<tr>
<td>verbose</td>
<td>附加</td>
<td>日志冗长度● int：冗长度★ 0：不输出训练过程● 1：偶尔输出● &gt;1：对每个子模型都输出</td>
<td>日志冗长度● int：冗长度★ 0：不输出训练过程● 1：偶尔输出● &gt;1：对每个子模型都输出</td>
<td>日志冗长度● int：冗长度★ 0：不输出训练过程● 1：偶尔输出● &gt;1：对每个子模型都输出</td>
<td>日志冗长度● int：冗长度★ 0：不输出训练过程● 1：偶尔输出● &gt;1：对每个子模型都输出</td>
</tr>
</tbody>
</table>
</div>
<p><em># ★：默认值</em></p>
<p>　　不难发现，基于bagging的Random Forest模型和基于boosting的Gradient Tree Boosting模型有不少共同的参数，然而某些参数的默认值又相差甚远。在<a href="http://www.cnblogs.com/jasonfreak/p/5657196.html" target="_blank" rel="noopener">《使用sklearn进行集成学习——理论》</a>一文中，我们对bagging和boosting两种集成学习技术有了初步的了解。Random Forest的子模型都拥有较低的偏差，整体模型的训练过程旨在降低方差，故其需要较少的子模型（n_estimators默认值为10）且子模型不为弱模型（max_depth的默认值为None），同时，降低子模型间的相关度可以起到减少整体模型的方差的效果（max_features的默认值为auto）。另一方面，Gradient Tree Boosting的子模型都拥有较低的方差，整体模型的训练过程旨在降低偏差，故其需要较多的子模型（n_estimators默认值为100）且子模型为弱模型（max_depth的默认值为3），但是降低子模型间的相关度不能显著减少整体模型的方差（max_features的默认值为None）。</p>
<hr>
<h1 id="2-如何调参？"><a href="#2-如何调参？" class="headerlink" title="2 如何调参？"></a>2 如何调参？</h1><p>　　聪明的读者应当要发问了：”博主，就算你列出来每个参数的意义，然并卵啊！我还是不知道无从下手啊！”</p>
<p>　　参数分类的目的在于缩小调参的范围，首先我们要明确训练的目标，把目标类的参数定下来。接下来，我们需要根据数据集的大小，考虑是否采用一些提高训练效率的策略，否则一次训练就三天三夜，法国人孩子都生出来了。然后，我们终于进入到了重中之重的环节：调整那些影响整体模型性能的参数。</p>
<h2 id="2-1-调参的目标：偏差和方差的协调"><a href="#2-1-调参的目标：偏差和方差的协调" class="headerlink" title="2.1 调参的目标：偏差和方差的协调"></a>2.1 调参的目标：偏差和方差的协调</h2><p>　　同样在<a href="http://www.cnblogs.com/jasonfreak/p/5657196.html" target="_blank" rel="noopener">《使用sklearn进行集成学习——理论》</a>中，我们已讨论过偏差和方差是怎样影响着模型的性能——准确度。调参的目标就是为了达到整体模型的偏差和方差的大和谐！进一步，这些参数又可分为两类：过程影响类及子模型影响类。在子模型不变的前提下，某些参数可以通过改变训练的过程，从而影响模型的性能，诸如：“子模型数”（n_estimators）、“学习率”（learning_rate）等。另外，我们还可以通过改变子模型性能来影响整体模型的性能，诸如：“最大树深度”（max_depth）、“分裂条件”（criterion）等。正由于bagging的训练过程旨在降低方差，而boosting的训练过程旨在降低偏差，过程影响类的参数能够引起整体模型性能的大幅度变化。一般来说，在此前提下，我们继续微调子模型影响类的参数，从而进一步提高模型的性能。</p>
<h2 id="2-2-参数对整体模型性能的影响"><a href="#2-2-参数对整体模型性能的影响" class="headerlink" title="2.2 参数对整体模型性能的影响"></a>2.2 参数对整体模型性能的影响</h2><p>　　假设模型是一个多元函数F，其输出值为模型的准确度。我们可以固定其他参数，从而对某个参数对整体模型性能的影响进行分析：是正影响还是负影响，影响的单调性？</p>
<p>　　对Random Forest来说，增加“子模型数”（n_estimators）可以明显降低整体模型的方差，且不会对子模型的偏差和方差有任何影响。模型的准确度会随着“子模型数”的增加而提高。由于减少的是整体模型方差公式的第二项，故准确度的提高有一个上限。在不同的场景下，“分裂条件”（criterion）对模型的准确度的影响也不一样，该参数需要在实际运用时灵活调整。调整“最大叶节点数”（max_leaf_nodes）以及“最大树深度”（max_depth）之一，可以粗粒度地调整树的结构：叶节点越多或者树越深，意味着子模型的偏差越低，方差越高；同时，调整“分裂所需最小样本数”（min_samples_split）、“叶节点最小样本数”（min_samples_leaf）及“叶节点最小权重总值”（min_weight_fraction_leaf），可以更细粒度地调整树的结构：分裂所需样本数越少或者叶节点所需样本越少，也意味着子模型越复杂。一般来说，我们总采用bootstrap对样本进行子采样来降低子模型之间的关联度，从而降低整体模型的方差。适当地减少“分裂时考虑的最大特征数”（max_features），给子模型注入了另外的随机性，同样也达到了降低子模型之间关联度的效果。但是一味地降低该参数也是不行的，因为分裂时可选特征变少，模型的偏差会越来越大。在下图中，我们可以看到这些参数对Random Forest整体模型性能的影响：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160731184710919-487730249.jpg" alt="img"></p>
<p>　　对Gradient Tree Boosting来说，“子模型数”（n_estimators）和“学习率”（learning_rate）需要联合调整才能尽可能地提高模型的准确度：想象一下，A方案是走4步，每步走3米，B方案是走5步，每步走2米，哪个方案可以更接近10米远的终点？同理，子模型越复杂，对应整体模型偏差低，方差高，故“最大叶节点数”（max_leaf_nodes）、“最大树深度”（max_depth）等控制子模型结构的参数是与Random Forest一致的。类似“分裂时考虑的最大特征数”（max_features），降低“子采样率”（subsample），也会造成子模型间的关联度降低，整体模型的方差减小，但是当子采样率低到一定程度时，子模型的偏差增大，将引起整体模型的准确度降低。还记得“初始模型”（init）是什么吗？不同的损失函数有不一样的初始模型定义，通常，初始模型是一个更加弱的模型（以“平均”情况来预测），虽说支持自定义，大多数情况下保持默认即可。在下图中，我们可以看到这些参数对Gradient Tree Boosting整体模型性能的影响：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160731184748841-69767136.jpg" alt="img"></p>
<h2 id="2-3-一个朴实的方案：贪心的坐标下降法"><a href="#2-3-一个朴实的方案：贪心的坐标下降法" class="headerlink" title="2.3 一个朴实的方案：贪心的坐标下降法"></a>2.3 一个朴实的方案：贪心的坐标下降法</h2><p>　　到此为止，我们终于知道需要调整哪些参数，对于单个参数，我们也知道怎么调整才能提升性能。然而，表示模型的函数F并不是一元函数，这些参数需要共同调整才能得到全局最优解。也就是说，把这些参数丢给调参算法（诸如Grid Search）咯？对于小数据集，我们还能这么任性，但是参数组合爆炸，在大数据集上，或许我的子子孙孙能够看到训练结果吧。实际上网格搜索也不一定能得到全局最优解，而另一些研究者从解优化问题的角度尝试解决调参问题。</p>
<p>　　<a href="https://zh.wikipedia.org/wiki/%E5%9D%90%E6%A0%87%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">坐标下降法</a>是一类优化算法，其最大的优势在于不用计算待优化的目标函数的梯度。我们最容易想到一种特别朴实的类似于坐标下降法的方法，与坐标下降法不同的是，其不是循环使用各个参数进行调整，而是贪心地选取了对整体模型性能影响最大的参数。参数对整体模型性能的影响力是动态变化的，故每一轮坐标选取的过程中，这种方法在对每个坐标的下降方向进行一次直线搜索（line search）。首先，找到那些能够提升整体模型性能的参数，其次确保提升是单调或近似单调的。这意味着，我们筛选出来的参数是对整体模型性能有正影响的，且这种影响不是偶然性的，要知道，训练过程的随机性也会导致整体模型性能的细微区别，而这种区别是不具有单调性的。最后，在这些筛选出来的参数中，选取影响最大的参数进行调整即可。</p>
<p>　　无法对整体模型性能进行量化，也就谈不上去比较参数影响整体模型性能的程度。是的，我们还没有一个准确的方法来量化整体模型性能，只能通过交叉验证来近似计算整体模型性能。然而交叉验证也存在随机性，假设我们以验证集上的平均准确度作为整体模型的准确度，我们还得关心在各个验证集上准确度的变异系数，如果变异系数过大，则平均值作为整体模型的准确度也是不合适的。在接下来的案例分析中，我们所谈及的整体模型性能均是指平均准确度，请各位留心。</p>
<h3 id="2-3-1-Random-Forest调参案例：Digit-Recognizer"><a href="#2-3-1-Random-Forest调参案例：Digit-Recognizer" class="headerlink" title="2.3.1 Random Forest调参案例：Digit Recognizer"></a>2.3.1 Random Forest调参案例：Digit Recognizer</h3><p>　　在这里，我们选取Kaggle上101教学赛中的<a href="https://www.kaggle.com/c/digit-recognizer" target="_blank" rel="noopener">Digit Recognizer</a>作为案例来演示对RandomForestClassifier调参的过程。当然，我们也不要傻乎乎地手工去设定不同的参数，然后训练模型。借助sklearn.grid_search库中的GridSearchCV类，不仅可以自动化调参，同时还可以对每一种参数组合进行交叉验证计算平均准确度。</p>
<h4 id="2-3-1-1-调整过程影响类参数"><a href="#2-3-1-1-调整过程影响类参数" class="headerlink" title="2.3.1.1 调整过程影响类参数"></a>2.3.1.1 调整过程影响类参数</h4><p>　　首先，我们需要对过程影响类参数进行调整，而Random Forest的过程影响类参数只有“子模型数”（n_estimators）。“子模型数”的默认值为10，在此基础上，我们以10为单位，考察取值范围在1至201的调参情况：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730162932106-838038825.png" alt="img"></p>
<p><em># 左图为模型在验证集上的平均准确度，右图为准确度的变异系数。横轴为参数的取值。</em></p>
<p>　　通过上图我们可以看到，随着“子模型数”的增加，整体模型的方差减少，其防止过拟合的能力增强，故整体模型的准确度提高。当“子模型数”增加到40以上时，准确度的提升逐渐不明显。考虑到训练的效率，最终我们选择“子模型数”为200。此时，在Kaggle上提交结果，得分为：0.96500，很凑合。</p>
<h4 id="2-3-1-2-调整子模型影响类参数"><a href="#2-3-1-2-调整子模型影响类参数" class="headerlink" title="2.3.1.2 调整子模型影响类参数"></a>2.3.1.2 调整子模型影响类参数</h4><p>　　在设定“子模型数”（n_estimators）为200的前提下，我们依次对子模型影响类的参数对整体模型性能的影响力进行分析。</p>
<p>　　对“分裂条件”（criterion）分别取值gini和entropy，得到调参结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730165700763-1666232416.png" alt="img"></p>
<p>　　显见，在此问题中，“分裂条件”保持默认值gini更加合适。</p>
<p>　　对“分裂时参与判断的最大特征数”（max_feature）以1为单位，设定取值范围为28至47，得到调参结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730170223903-942174073.png" alt="img"></p>
<p>　　</p>
<p>　　“分裂时参与判断的最大特征数”的默认值auto，即总特征数（sqrt(784)=28）的开方。通过提升该参数，整体模型的准确度得到了提升。可见，该参数的默认值过小，导致了子模型的偏差过大，从而整体模型的偏差过大。同时，我们还注意到，该参数对整体模型性能的影响是近似单调的：从28到38，模型的准确度逐步抖动提升。所以，我们可考虑将该参数纳入下一步的调参工作。</p>
<p>　　对“最大深度”（max_depth）以10为单位，设定取值范围为10到100，得到调参结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730171248153-89195782.png" alt="img"></p>
<p>　　随着树的深度加深，子模型的偏差减少，整体模型的准确度得到提升。从理论上来说，子模型训练的后期，随着方差增大，子模型的准确度稍微降低，从而影响整体模型的准确度降低。看图中，似乎取值范围从40到60的情况可以印证这一观点。不妨以1为单位，设定取值范围为40到59，更加细致地分析：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730171849434-652571651.png" alt="img"></p>
<p>　　有点傻眼了，怎么跟预想的不太一样？为什么模型准确度的变化在40到59之间没有鲜明的“规律”了？要分析这个问题，我们得先思考一下，少一层子节点对子模型意味着什么？若少的那一层给原子模型带来的是方差增大，则新子模型会准确度提高；若少的那一层给原子模型带来的是偏差减小，则新子模型会准确度降低。所以，细粒度的层次变化既可能使整体模型的准确度提升，也可能使整体模型的准确度降低。从而也说明了，该参数更适合进行粗粒度的调整。在训练的现阶段，“抖动”现象的发生说明，此时对该参数的调整已不太合适了。</p>
<p>　　对“分裂所需的最小样本数”（min_samples_split）以1为单位，设定取值范围为2到11，得到调参的结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730173505919-181940029.png" alt="img"></p>
<p>　　我们看到，随着分裂所需的最小样本数的增加，子模型的结构变得越来越简单，理论上来说，首先应当因方差减小导致整体模型的准确度提升。但是，在训练的现阶段，子模型的偏差增大的幅度比方差减小的幅度更大，所以整体模型的准确度持续下降。该参数的默认值为2，调参后，最优解保持2不变。</p>
<p>　　对“叶节点最小样本数”（min_samples_leaf）以1为单位，设定取值范围为1到10，得到调参结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730174140309-373143237.png" alt="img"></p>
<p>　　同“分裂所需的最小样本数”，该参数也在调参后，保持最优解1不变。</p>
<p>　　对“最大叶节点数”（max_leaf_nodes）以100为单位，设定取值范围为2500到3400，得到调参结果如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160730174432372-770058569.png" alt="img"></p>
<p>　　类似于“最大深度”，该参数的增大会带来模型准确的提升，可是由于后期“不规律”的抖动，我们暂时不进行处理。</p>
<p>　　通过对以上参数的调参情况，我们可以总结如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值准确度</th>
<th>调整后最佳准确度</th>
<th>提升幅度</th>
</tr>
</thead>
<tbody>
<tr>
<td>分裂条件（criterion）</td>
<td>0.964023809524</td>
<td>0.964023809524</td>
<td>0</td>
</tr>
<tr>
<td>分裂时参与判断的最大特征数（max_feature）</td>
<td>0.963380952381</td>
<td>0.964428571429</td>
<td>0.00104762</td>
</tr>
<tr>
<td>最大深度（max_depth）</td>
<td></td>
<td></td>
<td>抖动</td>
</tr>
<tr>
<td>分裂所需的最小样本数（min_samples_split）</td>
<td>0.963976190476</td>
<td>0.963976190476</td>
<td>0</td>
</tr>
<tr>
<td>叶节点最小样本数（min_samples_leaf）</td>
<td>0.963595238095</td>
<td>0.963595238095</td>
<td>0</td>
</tr>
<tr>
<td>最大叶节点数（max_leaf_nodes）</td>
<td></td>
<td></td>
<td>抖动</td>
</tr>
</tbody>
</table>
</div>
<p>　　接下来，我们固定分裂时参与判断的最大特征（max_features）为38，在Kaggle上提交一次结果：0.96671，比上一次调参好了0.00171，基本与我们预期的提升效果一致。</p>
<p>　　还需要继续下一轮坐标下降式调参吗？一般来说没有太大的必要，在本轮中出现了两个发生抖动现象的参数，而其他参数的调整均没有提升整体模型的性能。还是得老调重弹：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。在DR竞赛中，与其期待通过对RandomForestClassifier调参来进一步提升整体模型的性能，不如挖掘出更有价值的特征，或者使用自带特征挖掘技能的模型（正如此题，图分类的问题更适合用神经网络来学习）。但是，在这里，我们还是可以自信地说，通过贪心的坐标下降法，比那些用网格搜索法穷举所有参数组合，自以为得到最优解的朋友们更进了一步。</p>
<h3 id="2-3-2-Gradient-Tree-Boosting调参案例：Hackathon3-x"><a href="#2-3-2-Gradient-Tree-Boosting调参案例：Hackathon3-x" class="headerlink" title="2.3.2 Gradient Tree Boosting调参案例：Hackathon3.x"></a>2.3.2 Gradient Tree Boosting调参案例：Hackathon3.x</h3><p>　　在这里，我们选取Analytics Vidhya上的<a href="https://datahack.analyticsvidhya.com/contest/data-hackathon-3x/" target="_blank" rel="noopener">Hackathon3.x</a>作为案例来演示对GradientBoostingClassifier调参的过程。</p>
<h4 id="2-3-2-1-调整过程影响类参数"><a href="#2-3-2-1-调整过程影响类参数" class="headerlink" title="2.3.2.1 调整过程影响类参数"></a>2.3.2.1 调整过程影响类参数</h4><p>　　GradientBoostingClassifier的过程影响类参数有“子模型数”（n_estimators）和“学习率”（learning_rate），我们可以使用GridSearchCV找到关于这两个参数的最优解。慢着！这里留了一个很大的陷阱：“子模型数”和“学习率”带来的性能提升是不均衡的，在前期会比较高，在后期会比较低，如果一开始我们将这两个参数调成最优，这样很容易陷入一个“局部最优解”。在目标函数都不确定的情况下（如是否凸？），谈局部最优解就是耍流氓，本文中“局部最优解”指的是调整各参数都无明显性能提升的一种状态，所以打了引号。下图中展示了这个两个参数的调参结果：</p>
<p><img src="http://images2015.cnblogs.com/blog/927391/201607/927391-20160731161516950-670327363.png" alt="img"></p>
<p><em># 图中颜色越深表示整体模型的性能越高</em></p>
<p>　　在此，我们先直觉地选择“子模型数”为60，“学习率”为0.1，此时的整体模型性能（平均准确度为0.8253）不是最好，但是也不差，良好水准。</p>
<h4 id="2-3-2-2-调整子模型影响类参数"><a href="#2-3-2-2-调整子模型影响类参数" class="headerlink" title="2.3.2.2 调整子模型影响类参数"></a>2.3.2.2 调整子模型影响类参数</h4><p>　　对子模型影响类参数的调整与Random Forest类似。最终我们对参数的调整如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>子模型数n_estimators</th>
<th>学习率learning_rate</th>
<th>叶节点最小样本数min_samples_leaf</th>
<th>最大深度max_depth</th>
<th>子采样率subsample</th>
<th>分裂时参与判断的最大特征数max_feature</th>
</tr>
</thead>
<tbody>
<tr>
<td>60</td>
<td>0.1</td>
<td>12</td>
<td>4</td>
<td>0.77</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>　　到此，整体模型性能为0.8313，与workbench（0.8253）相比，提升了约0.006。</p>
<h4 id="2-3-2-3-杀一记回马枪"><a href="#2-3-2-3-杀一记回马枪" class="headerlink" title="2.3.2.3 杀一记回马枪"></a>2.3.2.3 杀一记回马枪</h4><p>　　还记得一开始我们对“子模型数”（n_estimators）和“学习率”（learning_rate）手下留情了吗？现在我们可以回过头来，调整这两个参数，调整的方法为成倍地放大“子模型数”，对应成倍地缩小“学习率”（learning_rate）。通过该方法，本例中整体模型性能又提升了约0.002。</p>
<h2 id="2-4-“局部最优解”"><a href="#2-4-“局部最优解”" class="headerlink" title="2.4 “局部最优解”"></a>2.4 “局部最优解”</h2><p>　　目前来说，在调参工作中，广泛使用的仍是一些经验法则。<a href="https://www.analyticsvidhya.com/blog/author/aarshay/" target="_blank" rel="noopener">Aarshay Jain</a>对Gradient Tree Boosting总结了一套<a href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" target="_blank" rel="noopener">调参方法</a>，其核心思想在于：对过程影响类参数进行调整，毕竟它们对整体模型性能的影响最大，然后依据经验，在其他参数中选择对整体模型性能影响最大的参数，进行下一步调参。这种方法的关键是依照对整体模型性能的影响力给参数排序，然后按照该顺序对的参数进行调整。如何衡量参数对整体模型性能的影响力呢？基于经验，Aarshay提出他的见解：“最大叶节点数”（max_leaf_nodes）和“最大树深度”（max_depth）对整体模型性能的影响大于“分裂所需最小样本数”（min_samples_split）、“叶节点最小样本数”（min_samples_leaf）及“叶节点最小权重总值”（min_weight_fraction_leaf），而“分裂时考虑的最大特征数”（max_features）的影响力最小。</p>
<p>　　Aarshay提出的方法和贪心的坐标下降法最大的区别在于前者在调参之前就依照对整体模型性能的影响力给参数排序，而后者是一种“很自然”的贪心过程。还记得2.3.2.1小节中我们讨论过“子模型数”（n_estimators）和“学习率”（learning_rate）的调参问题吗？同理，贪心的坐标下降法容易陷入“局部最优解”。对Random Forest调参时会稍微好一点，因为当“子模型数”调到最佳状态时，有时就只剩下诸如““分裂时参与判断的最大特征数”等Aarshay认为影响力最小的参数可调了。但是，对Gradient Tree Boosting调参时，遇到“局部最优解”的可能性就大得多。</p>
<p>　　Aarshay同样对Hackathon3.x进行了调参试验，由于特征提取方式的差异，参数赋值相同的情况下，本文的整体模型性能仍与其相差0.007左右（唉，不得不再说一次，特征工程真的很重要）。首先，在过程影响类参数的选择上，Aarshay的方法与贪心的坐标下降法均选择了“子模型数”为60，“学习率”为0.1。接下来，Aarshay按照其定义的参数对整体模型性能的影响力，按序依次对参数进行调整。当子模型影响类参数确定完成后，Aarshay的方法提升了约0.008的整体模型性能，略胜于贪心的坐标下降法的0.006。但是，回过头来继续调试“子模型数”和“学习率”之后，Aarshay的方法又提升了约0.01的整体模型性能，远胜于贪心的坐标下降法的0.002。</p>
<p>　　诶！诶！诶！少侠请住手！你说我为什么要在这篇博文中介绍这种“无用”的贪心的坐标下降法？首先，这种方法很容易凭直觉就想到。人们往往花了很多的时间去搞懂模型的参数是什么含义，对整体模型性能有什么影响，搞懂这些已经不易了，所以接下来很多人选择了最直观的贪心的坐标下降法。通过一个实例，我们更容易记住这种方法的局限性。除了作为反面教材，贪心的坐标下降法就没有意义了吗？不难看到，Aarshay的方法仍有改进的地方，在依次对参数进行调整时，还是需要像贪心的坐标下降法中一样对参数的“动态”影响力进行分析一下，如果这种影响力是“抖动”的，可有可无的，那么我们就不需要对该参数进行调整。</p>
<h2 id="2-5-类别不均衡的陷阱"><a href="#2-5-类别不均衡的陷阱" class="headerlink" title="2.5 类别不均衡的陷阱"></a>2.5 类别不均衡的陷阱</h2><p>　　哈哈哈，这篇博文再次留了个陷阱，此段文字并不是跟全文一起发布！有人要说了，按照我的描述，Aarshay的调参试验不可再现啊！其实，我故意没说Aarshay的另一个关键处理：调参前的参数初始值。因为Hackathon3.x是一个类别不均衡的问题，所以如果直接先调试“最大深度”（max_depth），会发现其会保持默认值3作为最优解，而后面的调参中，“分裂所需最小样本数”（min_samples_split）、“叶节点最小样本数”（min_samples_leaf）再怎么调都没有很大作用。这是因为，正例样本远远小于反例，所以在低深度时，子模型就可能已经对正例过拟合了。所以，在类别不均衡时，只有先确定“叶节点最小样本数”（min_samples_leaf），再确定“分裂所需最小样本数”（min_samples_split），才能确定“最大深度”。而Aarshay设定的初始值，则以经验和直觉避开了这个险恶的陷阱。</p>
<p>　　如果实在觉得经验和直觉不靠谱，我还尝试了一种策略：首先，我们需要初步地调一次“子采样率”（subsample）和“分裂时考虑的最大特征数”（max_features），在此基础上依次调好“叶节点最小样本数”（min_samples_leaf）、“分裂所需最小样本数”（min_samples_split）以及“最大深度”（max_depth）。然后，按照Aarshay的方法，按影响力从大到小再调一次。通过这种方法，整体模型性能在未等比缩放过程影响类参数前，已达到约0.8352左右，比workbench相比，提升了约0.1，与Aarshay的调参试验差不多，甚至更好一点点。</p>
<p>　　回过头来，我们再次看看贪心的坐标下降法是怎么掉入这个陷阱的。在确定过程影响类参数后，贪心的坐标下降法按照“动态”的对整体模型性能的影响力大小，选择了“叶节点最小样本数”进行调参。这一步看似和上一段的描述是一致的，但是，一般来说，含随机性（“子采样率”和“分裂时考虑的最大特征数”先初步调过）的“叶节点最小样本数”要大于无随机性。举个例来说，因为增加了随机性，导致了子采样后，某子样本中只有一个正例，且其可以通过唯一的特征将其分类，但是这个特征并不是所有正例的共性，所以此时就要求“叶节点最小样本数”需要比无随机性时大。对贪心的坐标下降来说，“子采样率”和“分裂时考虑的最大特征数”在当下，对整体模型性能的影响比不上“叶节点最小样本数”，所以栽了个大跟头。</p>
<hr>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>　　在这篇博文中，我一反常态，花了大部分时间去试验和说明一个有瑕疵的方案。数据挖掘的工作中的方法和技巧，有很大一部分暂时还未被严谨地证明，所以有很大部分人，特别是刚入门的小青年们（也包括曾经的我），误以为其是一门玄学。实际上，尽管没有被严谨地证明，我们还是可以通过试验、分析，特别是与现有方法进行对比，得到一个近似的合理性论证。</p>
<p>　　另外，小伙伴们你们有什么独到的调参方法吗？请不要有丝毫吝啬，狠狠地将你们的独门绝技全释放在我身上吧，请大胆留言，残酷批评！</p>
<hr>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4 参考资料"></a>4 参考资料</h2><ol>
<li><a href="http://www.cnblogs.com/jasonfreak/p/5657196.html" target="_blank" rel="noopener">《使用sklearn进行集成学习——理论》</a></li>
<li><a href="https://www.analyticsvidhya.com/blog/2016/02/complete-guide-parameter-tuning-gradient-boosting-gbm-python/" target="_blank" rel="noopener">Complete Guide to Parameter Tuning in Gradient Boosting (GBM) in Python</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9D%90%E6%A0%87%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">坐标下降法</a></li>
<li><a href="https://www.kaggle.com/c/digit-recognizer" target="_blank" rel="noopener">Digit Recognizer</a></li>
<li><a href="https://datahack.analyticsvidhya.com/contest/data-hackathon-3x/" target="_blank" rel="noopener">Hackathon3.x</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/面试刷题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/面试刷题/" class="post-title-link" itemprop="url">面试刷题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/面试刷题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/面试刷题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><a href="https://zhuanlan.zhihu.com/p/29965072" target="_blank" rel="noopener">那些深度学习《面试》你可能需要知道的</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29969587" target="_blank" rel="noopener">如何准备机器学习工程师的面试 ？</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/mp/homepage%3F__biz%3DMzI4MTQ2NjU5NA%3D%3D%26hid%3D1%26sn%3D93c4875b14fa5ad6f174829b2b8b4463%26scene%3D18%26devicetype%3DiPhone%2BOS9.3.5%26version%3D16051327%26lang%3Dzh_CN%26nettype%3D3G%2B%26ascene%3D7%26session_us%3Dgh_58f9504ddd59%26fontScale%3D100%26pass_ticket%3Dg8f%252FuIJqlsyfsGEdnZPm0SWWYRiZWOQHMp6bSSJ39kpkzb%252BgyByne%252BKNjMf%252Fo4pp%26wx_header%3D1%26scene%3D1" target="_blank" rel="noopener">七月在线实验室—-BAT机器学习面试题</a></li>
<li><a href="https://www.zhihu.com/question/23259302" target="_blank" rel="noopener">如何准备机器学习工程师的面试 ？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27238249" target="_blank" rel="noopener">读完这21个机器学习面试问题和答案，入职率提升99%</a></li>
<li><a href="https://www.zhihu.com/question/25565713#answer-8243688" target="_blank" rel="noopener">国内互联网公司机器学习数据挖掘类的职位面试主要考察什么方面的东西？</a></li>
<li>….等等</li>
</ol>
<p>如何判断一个而链表中是否有环？<br>给定一棵二叉查找树中的两个元素，求它们的最近公共祖先。<br>给一个栈排序<br>基于比较的排序算法的时间复杂度是什么？证明？<br>如何求一个带权图中两个结点直接按的最短路径？如果有些权值是负的怎么办？<br>求一个字符串中所有的回文子串。<br>对这些问题你都要能够推导你的解法的时间和空间复杂度（大 O 表示法），并且尽量用最低的复杂度解决。<br><strong>只有通过大量的练习才能将这些不同类型的问题烂熟于胸，从而在面试中迅速地给出一个高效的解法。常用的算法面试准备平台有 InterviewBit、LeetCode、Interview Cake、Pramp、<a href="http://interviewing.io/" target="_blank" rel="noopener">http://interviewing.io</a> 等。</strong></p>
<p>概率论和统计典型问题</p>
<p>给出一个群体中男性和女性各自的平均身高，求整个群体的平均身高。<br>一次调查表明意大利三分之一的汽车都是法拉利，并且在那之中一半的车都是红色的。如果你在意大利的街头看到一辆红色的汽车驶来，请问它是法拉利的可能性有多大？<br>你试图找出在自己的网站上放置版头的最佳方案。变量包括版头的尺寸（大、中、小）以及放置的位置（顶部、中间、底部）。假定需要 95% 的置信水平，请问你至少需要多少次访问和点击来确定某个方案比其他的组合都要好？<br><strong>很多机器学习算法都以概率论和统计作为理论基础。对于这些基础知识有清晰的概念是极为重要的。当然同时你也要能够将这些抽象的概念与现实联系起来。</strong><br>数据建模和评估典型问题</p>
<p>一位农民想搞明白是什么因素影响了他的牛奶产量。他记录了每天的气温（30 - 40 度）、湿度（60 - 90%）、饲料消耗（2000 - 2500 千克）以及牛奶产量（500 - 1000 升）。<br>假设问题是要预测每天的牛奶产量，你会如何处理数据并建立模型？<br>这是一个什么类型的机器学习问题？<br>你的公司在开发一个面部表情识别系统。这个系统接受 1920 x 1080 的图片作为输入，并告诉用户图片中的人脸处于以下哪种情绪状态：平常、高兴、悲伤、愤怒和恐惧。当图片中没有人脸时系统要能够分辨这种情况。<br>这是一个什么类型的机器学习问题？<br>如果每个像素点由 3 个值来表示（RGB），那么输入数据的原始维度有多大？有办法降维吗？<br>如何对系统的输出进行编码？为什么？<br>过去几个世纪的气象数据展现出一种循环的气温模式：一会升高一会下降。对于这样的数据（一个年平均气温的序列），你会如何建模并预测未来 5 年的平均气温？<br>你在一家在线新闻网站工作，需要从各处收集文本，并将不同来源的内容聚集成一篇报道。你会如何设计这样一个系统？会用到哪些机器学习技术？<br><strong>应用机器学习算法和库</strong></p>
<p>你用一个给定的数据集训练一个单隐层的神经网络，发现网络的权值在训练中强烈地震荡（有时在负值和正值之间变化）。为了解决这个问题你需要调整哪个参数？<br>支持向量机的训练在本质上是在最优化哪个值？<br>LASSO 回归用 L1-norm 作为惩罚项，而岭回归（Ridge Regression）则使用 L2-norm 作为惩罚项。这两者哪个更有可能得到一个稀疏（某些项的系数为 0）的模型？<br>在用反向传播法训练一个 10 层的神经网络时，你发现前 3 层的权值完全没有变化，而 4 ~ 6 层的权值则变化得非常慢。这是为什么？如何解决？<br>你手上有一个关于小麦产出的数据集，包括年降雨量 R、平均海拔 A 以及小麦产量 O。你经过初步分析认为产量跟年降雨量的平方以及平均海报的对数之间存在关系，即：O = β_0 + β_1 x R^2 + β_2 x log(A)。能用线性回归求出系数 β 吗？<br>你可以通过像 Kaggle 比赛那样的数据科学和机器学习挑战来了解各种各样的问题和它们之间的细微差别。多多参加这些比赛，并尝试应用不同的机器学习模型。<br>软件工程和系统设计典型问题</p>
<p>你有一个电商网站，当用户点击一个商品打开详情页面时，你想基于商品特征和用户的购买历史为用户推荐 5 个其他的商品显示在页面的底部。你需要哪些服务和数据表来实现这个功能？请写一个查询语句或一段过程式代码来返回所要推荐的 5 个商品。<br>对于 YouTube 那样的在线视频网站，你会收集哪些数据来衡量用户的参与度和视频的人气度？<br>一个简单的垃圾邮件检测系统是这样的：它每次处理一封邮件，统计不同单词的出现频率（Term frequency），并将这些频率与之前已经被标注为垃圾 / 正常邮件的那些频率进行比较。现在需要对这系统进行拓展来处理海量的邮件流量，请设计一个 Map-Reduce 方案在一个集群上部署这个系统。<br>你要生成一个实时的热力图，来展示用户正在浏览和点击一个网页的哪些部分。在客户端和服务端分别需要哪些组件 / 服务 / API 来实现这个功能？</p>
<p><a href="http://blog.csdn.net/u010496169/article/details/73743973" target="_blank" rel="noopener">机器学习岗位面试问题汇总 之 集成学习</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/工具和环境/Hexo + Github 搭建博客入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/工具和环境/Hexo + Github 搭建博客入门/" class="post-title-link" itemprop="url">Hexo + Github 搭建博客入门</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-04 10:07:47" itemprop="dateModified" datetime="2019-07-04T10:07:47+08:00">2019-07-04</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/工具和环境/" itemprop="url" rel="index"><span itemprop="name">工具和环境</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/工具和环境/Hexo + Github 搭建博客入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/工具和环境/Hexo + Github 搭建博客入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、安装node-js"><a href="#1、安装node-js" class="headerlink" title="1、安装node.js"></a>1、安装node.js</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository ppa:chris-lea/node.js</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install nodejs</span></span><br><span class="line"><span class="meta">#</span><span class="bash">原方法没有这一步，但是后面的操作会提示npm <span class="built_in">command</span> not found</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install npm</span></span><br></pre></td></tr></table></figure>
<h1 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo npm install hexo -g</span></span><br></pre></td></tr></table></figure>
<p>如果是mac，要用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo --no-optional</span><br></pre></td></tr></table></figure>
<p>不然会报错<strong>Error: Cannot find module ‘./build/Release/DTraceProviderBindings’] code: ‘MODULE_NOT_FOUND’</strong>这个错误。</p>
<p>如果报权限错误，需要用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure>
<h1 id="3、初始博客的根目录"><a href="#3、初始博客的根目录" class="headerlink" title="3、初始博客的根目录"></a>3、初始博客的根目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/myblog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure>
<p>mac的根目录在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/david/david/myblog</span><br></pre></td></tr></table></figure>
<h1 id="4、在github上新建仓库"><a href="#4、在github上新建仓库" class="headerlink" title="4、在github上新建仓库"></a>4、在github上新建仓库</h1><p>名称必须是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitusername.github.io</span><br></pre></td></tr></table></figure>
<p>我的就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Schwimmer.github.io</span><br></pre></td></tr></table></figure>
<p>并将本地的SSH KEY添加到git上（略）</p>
<h1 id="5、让博客可以发布到git"><a href="#5、让博客可以发布到git" class="headerlink" title="5、让博客可以发布到git"></a>5、让博客可以发布到git</h1><p>1）安装hexo-deployer-Git（不然会出现ERROR Deployer not found: git）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>2） 配置你hexo博客根目录下的_config.yml文件(应该是最下面一行，修改成你的github)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Schwimmer/Schwimmer.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<blockquote>
<p> tips</p>
<p> 冒号后面一定要跟空格</p>
</blockquote>
<h1 id="6、hexo常用命令"><a href="#6、hexo常用命令" class="headerlink" title="6、hexo常用命令"></a>6、hexo常用命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清除缓存</span><br><span class="line">hexo new &quot;title&quot; #新建文章</span><br><span class="line">hexo g #生成html，或hexo generate</span><br><span class="line">hexo s #在本地启动服务，启动后访问localhost:4000就可以打开，或hexo server</span><br><span class="line">hexo d #发布到git，发布后访问https://schwimmer.github.io/就可以打开，或hexo deploy</span><br></pre></td></tr></table></figure>
<blockquote>
<p> tips</p>
<p> 我目前用的新建文章的方法，就是直接在source/_posts/下面新建md文件</p>
<p> 可以偷懒写成</p>
<p> cd ~/myblog</p>
<p> hexo clean;hexo g;hexo s</p>
<p> 或</p>
<p> hexo clean;hexo g;hexo d</p>
</blockquote>
<h1 id="支持数学公式"><a href="#支持数学公式" class="headerlink" title="支持数学公式"></a>支持数学公式</h1><p>Next 7的版本中，数学公式可以直接开启配置</p>
<h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Math Equations Render Support</span><br><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Default(true) will load mathjax/katex script on demand</span><br><span class="line">  # That is it only render those page who has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  engine: mathjax</span><br><span class="line">  #engine: katex</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) needed to full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    # Use 2.7.5 as default, jsdelivr as default CDN, works everywhere even in China</span><br><span class="line">    cdn: //cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br><span class="line">    # For direct link to MathJax.js with CloudFlare CDN (cdnjs.cloudflare.com)</span><br><span class="line">    #cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML</span><br><span class="line"></span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    #mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3</span><br><span class="line">    #mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) needed to full Katex support.</span><br><span class="line">  katex:</span><br><span class="line">    # Use 0.7.1 as default, jsdelivr as default CDN, works everywhere even in China</span><br><span class="line">    cdn: //cdn.jsdelivr.net/npm/katex@0.7.1/dist/katex.min.css</span><br><span class="line">    # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China</span><br><span class="line">    #cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css</span><br><span class="line"></span><br><span class="line">    copy_tex:</span><br><span class="line">      # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span><br><span class="line">      enable: false</span><br><span class="line">      copy_tex_js: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js</span><br><span class="line">      copy_tex_css: //cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css</span><br></pre></td></tr></table></figure>
<h1 id="8、安装主题"><a href="#8、安装主题" class="headerlink" title="8、安装主题"></a>8、安装主题</h1><p>转自：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT主题安装教程</a></p>
<h1 id="9、文章阅读计数"><a href="#9、文章阅读计数" class="headerlink" title="9、文章阅读计数"></a>9、文章阅读计数</h1><p>转自：<a href="http://www.jianshu.com/p/702a7aec4d00" target="_blank" rel="noopener">Hexo添加不蒜子和LeanCloud统计无标题文章</a></p>
<p>找到站点的<code>themes/next/layout/_partials</code>目录下的<code>footer.swig</code>文件。插入代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">  &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; -</span><br><span class="line">  &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</span><br><span class="line">    NexT.&#123;&#123; theme.scheme &#125;&#125;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"># 此位置插入以下代码</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次&amp;nbsp&amp;nbsp&amp;nbsp</span><br><span class="line">本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10、增加图片"><a href="#10、增加图片" class="headerlink" title="10、增加图片"></a>10、增加图片</h1><p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自dalao：<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">dalao的git</a></p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个<strong>同名的文件夹</strong></p>
<p>4 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<p><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></p>
<p><strong>注意：</strong>xxxx是这个md文件的名字，也是同名文件夹的名字，你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<h1 id="11、sitemap-插件"><a href="#11、sitemap-插件" class="headerlink" title="11、sitemap 插件"></a>11、sitemap 插件</h1><p><a href="https://www.jianshu.com/p/86557c34b671" target="_blank" rel="noopener">Hexo Seo优化让你的博客在google搜索排名第一</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;google-site-verification&quot; content=&quot;Mx7Ikp0IpBtTbSpHDTBV0_CMJA-E8CLn8NRIrwyq5m4&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;ZBTsWx4NdC&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h1 id="12、首页显示文章摘要"><a href="#12、首页显示文章摘要" class="headerlink" title="12、首页显示文章摘要"></a>12、首页显示文章摘要</h1><ul>
<li>进入hexo博客项目的themes/next目录</li>
<li>用文本编辑器打开_config.yml文件</li>
<li>搜索”auto_excerpt”,找到如下部分：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommand.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>
<ul>
<li>把enable改为对应的false改为true，然后<code>hexo d -g</code>，再进主页，问题就解决了！</li>
</ul>
<h1 id="13、启用分类和标签"><a href="#13、启用分类和标签" class="headerlink" title="13、启用分类和标签"></a>13、启用分类和标签</h1><p>1、在博客的开头要加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: Hexo + Github 搭建博客入门</span><br><span class="line">date: 2017-07-12 11:49:53</span><br><span class="line">categories: &quot;工具和环境&quot;</span><br><span class="line">tags: </span><br><span class="line"> - hexo</span><br><span class="line">description:</span><br></pre></td></tr></table></figure>
<p>2、修改主题配置文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  categories: /categories</span><br><span class="line">  #about: /about</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure>
<p>3、hexo加上page</p>
<p>如分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>然后打开<code>source/categories/index.md</code>，增加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>增加标签也是一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>然后打开<code>source/tags/index.md</code>，增加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>谷歌与百度的站点地图，前者适用于其他搜索引擎，用来手动提交以增加收录</p>
<p>安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap@1 --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap@0.1.1 --save</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code>添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure>
<p>谷歌的<code>sitemap.xml</code>不需要写到配置文件中，自动生效。</p>
<p>在主页后面加<code>/baidusitemap.xml</code>可以看到baidusitemap（谷歌同理），将该网址它提交给百度搜索：<a href="http://zhanzhang.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">百度站长平台</a>，贴吧账号无法在这里使用。</p>
<p>不过由于Github禁止了百度爬虫，百度无法抓取其中的URL：</p>
<h1 id="添加搜索"><a href="#添加搜索" class="headerlink" title="添加搜索"></a>添加搜索</h1><p>Local search no need any external 3rd-party services and can be extra indexed by search engines. That search method recommended for most users.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Install <code>hexo-generator-searchdb</code> by run following command in site root dir:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h2 id="hexo-配置"><a href="#hexo-配置" class="headerlink" title="hexo 配置"></a>hexo 配置</h2><p>Edit site config file and add following content:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo/_config.yml</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<h2 id="themes-配置"><a href="#themes-配置" class="headerlink" title="themes 配置"></a>themes 配置</h2><p>Edit theme config file to enable Local Search:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">next/_config.yml</span><br><span class="line"></span><br><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # unescape html strings to the readable one</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure>
<h1 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h1><h3 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h3><p>Disqus is a global comment system that improves discussion on websites and connects conversations across the web.</p>
<ol>
<li><p>Create an account and log into Disqus. Once logged in, click the <code>GET STARTED</code> button on the homepage, then select <code>I want to install Disqus on my site</code> option and you will see the <code>Create a new site</code> interface.</p>
</li>
<li><p>Enter your <code>Website Name</code>, which will serve as your Disqus shortname, and select a Category from the drop-down menu. Then click <code>Create Site</code> button.</p>
</li>
<li><p>Choose <code>I don&#39;t see my platform listed, install manually with Universal Code</code>, configure Disqus for your site, and click <code>Complete Setup</code> button.</p>
</li>
<li><p>Set the value<code>enable</code> to <code>true</code>, add the obtained Disqus shortname (<code>shortname</code>), and edit other configurations in <code>disqus</code> section in the theme config file as following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next/_config.yml</span><br><span class="line">disqus:</span><br><span class="line">  enable: false</span><br><span class="line">  shortname: your-short-disqus-name</span><br><span class="line">  count: true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h1><p>Edit <code>busuanzi_count</code> option in theme config file.<br>When <code>enable: true</code>, global setting is enabled. If <code>site_uv</code>, <code>site_pv</code>, <code>page_pv</code> are all <code>false</code>, Busuanzi only counts but never shows.</p>
<h1 id="绑定代码到Coding"><a href="#绑定代码到Coding" class="headerlink" title="绑定代码到Coding"></a>绑定代码到Coding</h1><p>创建coding仓库</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4093388-383ab28e2c2b2e84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>上传公钥</p>
<p><a href="https://coding.net/user/account/setting/keys" target="_blank" rel="noopener">https://coding.net/user/account/setting/keys</a></p>
<p>测试SSH Key 是否配置成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure>
<p>用来部署Hexo博客的Coding项目地址为：<code>git@git.coding.net:ddxy1986/DavidXu-Blog</code></p>
<p>deploy的配置改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    github: git@github.com:Schwimmer/Schwimmer.github.io.git</span><br><span class="line">    coding: git@git.coding.net:ddxy1986/DavidXu-Blog</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h2 id="配置Coding项目的Pages服务"><a href="#配置Coding项目的Pages服务" class="headerlink" title="配置Coding项目的Pages服务"></a>配置Coding项目的Pages服务</h2><h3 id="开启Coding项目的Pages服务"><a href="#开启Coding项目的Pages服务" class="headerlink" title="开启Coding项目的Pages服务"></a>开启Coding项目的Pages服务</h3><p><img src="https://upload-images.jianshu.io/upload_images/4093388-1ab23c0ef7e753ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<h1 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h1><h2 id="启动时报错"><a href="#启动时报错" class="headerlink" title="启动时报错"></a>启动时报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Error: Warning: Permanently added &apos;github.com,192.30.253.112&apos; (RSA) to the list of known hosts.</span><br><span class="line">sign_and_send_pubkey: signing failed: agent refused operation</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure>
<p>处理是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">$ ssh-add</span><br></pre></td></tr></table></figure>
<h2 id="生成html时报错"><a href="#生成html时报错" class="headerlink" title="生成html时报错"></a>生成html时报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">end of the stream or a document separator is expected</span><br></pre></td></tr></table></figure>
<h2 id="更新next主题后，菜单不是中文也不是英文"><a href="#更新next主题后，菜单不是中文也不是英文" class="headerlink" title="更新next主题后，菜单不是中文也不是英文"></a>更新next主题后，菜单不是中文也不是英文</h2><p>next主题的所有语言配置文件都在\themes\next\languages文件夹下，原来中文对应的是zh-Hans.yml，更新之后变成了<code>zh-CN.yml</code>。</p>
<p>而语言的配置信息再主目录的_config.yml文件，于是找到这里</p>
<p><img src="/.io//pic/377adab44aed2e73180cc7b68e01a18b86d6fa47.jpg" alt="img"></p>
<p>将其改为<code>zh-CN</code>，解决问题。</p>
<h2 id="安装npm报错"><a href="#安装npm报错" class="headerlink" title="安装npm报错"></a>安装npm报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: EACCES: permission denied, access &apos;/Users/david/david/myblog/node_modules/babel-polyfill/node_modules/core-js&apos;</span><br></pre></td></tr></table></figure>
<p>用了sudu命令也依旧报错。</p>
<p>解决方案是</p>
<p>you can fix that error by allowing unsafe perms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm config set unsafe-perm=true</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://github.com/Microsoft/WSL/issues/14" target="_blank" rel="noopener">https://github.com/Microsoft/WSL/issues/14</a></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://blog.csdn.net/kesarchen/article/details/50579550" target="_blank" rel="noopener">ubuntu下使用hexo搭建博客</a> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/读书/计算机程序的构造和解释/CH3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/" class="post-title-link" itemprop="url">第三章 模块化、对象和状态</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 16:02:58" itemprop="dateModified" datetime="2019-06-28T16:02:58+08:00">2019-06-28</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/读书/计算机程序的构造和解释/CH3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三章-模块化、对象和状态"><a href="#第三章-模块化、对象和状态" class="headerlink" title="第三章 模块化、对象和状态"></a>第三章 模块化、对象和状态</h1><h2 id="前两章回顾"><a href="#前两章回顾" class="headerlink" title="前两章回顾"></a>前两章回顾</h2><ol>
<li>如何组合<strong>基本过程</strong>和<strong>基本数据</strong></li>
<li>如何构造各种<strong>复合对象</strong>(组合过程/数据)</li>
<li><strong>抽象</strong>在控制和处理程序复杂性中的重要作用</li>
</ol>
<blockquote>
<p>简单问题1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cons、car和cdr的含义</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>简单问题2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ;写出以下函数的等价lambda表达式</span><br><span class="line">&gt; (define (add a b)</span><br><span class="line">&gt;   (+ a b))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但对于程序设计而言，上面这三种手段还不够用，有效设计大型系统，还需要一些组织系统的原则，这体现在下面两方面：</p>
<ol>
<li>只有高效算法，不足以构造出良好的大型系统</li>
<li>系统的功能分解，结构组织和管理与算法一样重要(或更甚之)</li>
</ol>
<p>在大型系统的复杂性问题上，仅学会抽象的思维还不够，还需要一些能帮我们<strong>构造模块化的大型系统的策略</strong>。在这一章，会学习两种组织策略。</p>
<ul>
<li><strong>基于对象的策略</strong></li>
</ul>
<blockquote>
<p>真实系统中的对象随着时间的进展不断变化，模拟它们的系统对象也吸引相应地变化</p>
</blockquote>
<ul>
<li><strong>基于流处理的策略</strong></li>
</ul>
<blockquote>
<p>关注流过系统的信息流</p>
</blockquote>
<h2 id="3-1-赋值和局部状态"><a href="#3-1-赋值和局部状态" class="headerlink" title="3.1 赋值和局部状态"></a>3.1 赋值和局部状态</h2><h3 id="3-1-1-局部状态变量"><a href="#3-1-1-局部状态变量" class="headerlink" title="3.1.1 局部状态变量"></a>3.1.1 局部状态变量</h3><blockquote>
<p>例子：银行取钱</p>
</blockquote>
<p>用withdraw表示该行为，入参amount表示取钱的数量，若账户有足够的钱，返回余额；否则返回Insufficient funds。</p>
<p>为了实现withdraw，我们用一个变量balance表示余额，withdraw检查balance是否够amount，如果是，</p>
<p><code>balance -= amount</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> balance <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">withdraw</span> amount)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</span><br><span class="line">      (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</span><br><span class="line">             balance)</span><br><span class="line">      <span class="string">"Insufficient funds"</span>))</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</span><br><span class="line"><span class="string">"Insufficient funds"</span></span><br></pre></td></tr></table></figure>
<p>其中，set的语法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(set! &lt;name&gt; &lt;new-value&gt; )</span><br></pre></td></tr></table></figure>
<p>begin描述对表达式的求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(begin &lt;exp1&gt;&lt;exp2&gt;...&lt;expk&gt;)</span><br></pre></td></tr></table></figure>
<p>按顺序求值，并返回最后一个表达式的值。</p>
<p>可以看出，这里的balance是全局变量，在哪里都能读取或修改这个值。如果将其作为局部变量，就只能通过withdraw来访问balance，这样才能更准确的模拟balance这个概念。</p>
<p>于是将其转为局部变量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> new-withdraw</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">balance</span> <span class="number">100</span>))</span><br><span class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">      (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</span><br><span class="line">          (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</span><br><span class="line">             balance)</span><br><span class="line">      <span class="string">"Insufficient funds"</span>))))</span><br></pre></td></tr></table></figure>
<p>其中，let创建一个包含局部变量的环境，并设初始值。</p>
<p>make-withdraw创建一种”提款处理器”，它的形参balance描述了有关账户的初始值。(把balance当形参传入)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</span><br><span class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</span><br><span class="line">               balance)</span><br><span class="line">        <span class="string">"Insufficient funds"</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> W1 (<span class="name">make-withdraw</span> <span class="number">100</span>))</span><br><span class="line">(<span class="name">define</span> W2 (<span class="name">make-withdraw</span> <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">&gt; (<span class="name">W1</span> <span class="number">50</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line">&gt; (<span class="name">W2</span> <span class="number">60</span>)</span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>可以看出，W1和W2是完全独立的对象，每个都有自己的局部状态变量balance。</p>
<p>再创建一个存钱的对象make-account</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</span><br><span class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</span><br><span class="line">               balance)</span><br><span class="line">        <span class="string">"Insufficient funds"</span>))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</span><br><span class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</span><br><span class="line">    balance)</span><br><span class="line"></span><br><span class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) withdraw)</span><br><span class="line">          ((<span class="name">eq</span>? m 'deposit) deposit)</span><br><span class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></span><br><span class="line">                       m))))</span><br><span class="line"></span><br><span class="line">  dispatch)</span><br></pre></td></tr></table></figure>
<p>对make-account的每次调用都会设置好一个带有balance的环境，在这个环境中，定义了能访问balance的过程deposit和withdraw，另外还有一个过程dispatch，它以一个字符串作为输入，返回这两个局部过程之一。</p>
<p>该过程可以这样使用</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="name">define</span> acc (<span class="name">make-account</span> <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">; 对acc的每次调用将返回局部定义的过程</span></span><br><span class="line">&gt; (<span class="name">acc</span> 'withdraw)</span><br><span class="line">#&lt;procedure:withdraw&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">; 这个过程随后被应用于给定的amount</span></span><br><span class="line">&gt; ((<span class="name">acc</span> 'withdraw) <span class="number">50</span>)</span><br><span class="line"><span class="number">50</span></span><br><span class="line"></span><br><span class="line">&gt; ((<span class="name">acc</span> 'withdraw) <span class="number">60</span>)</span><br><span class="line"><span class="string">"Insufficient funds"</span></span><br><span class="line"></span><br><span class="line">&gt; ((<span class="name">acc</span> 'deposit) <span class="number">40</span>)</span><br><span class="line"><span class="number">90</span></span><br><span class="line"></span><br><span class="line">&gt; ((<span class="name">acc</span> 'withdraw) <span class="number">60</span>)</span><br><span class="line"><span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 这样将产生另一个完全独立的对象，维护自己的局部balance</span></span><br><span class="line">&gt; (<span class="name">define</span> acc2 (<span class="name">make-account</span> <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-引进赋值带来的利益"><a href="#3-1-2-引进赋值带来的利益" class="headerlink" title="3.1.2 引进赋值带来的利益"></a>3.1.2 引进赋值带来的利益</h3><blockquote>
<p>例子：考虑设计一个过程rand，每次被调用就返回一个随机整数</p>
</blockquote>
<p>“随机”是指，对rand的反复调用将产生出一系列的数，这一序列具有均匀分布的统计性质。</p>
<p>假设现在有一个过程rand-update，如果给定一个数x1，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x2 = (rand-update x1)</span><br><span class="line">x3 = (rand-update x2)</span><br></pre></td></tr></table></figure>
<p>得到序列x1, x2, x3…将具有我们希望的性质</p>
<p>可以将rand时限为一个带局部状态变量x的过程，初始化为某个固定值random-init，对rand的每次调用算出当前x的rand-update值，返回作为随机数，并将其更新为x的新值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> random-init <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">rand-update</span> x)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">a</span> <span class="number">27</span>) (<span class="name">b</span> <span class="number">26</span>) (<span class="name">m</span> <span class="number">127</span>))</span><br><span class="line">    (<span class="name">modulo</span> (<span class="name">+</span> (<span class="name">*</span> a x) b) m)))</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> rand</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</span><br><span class="line">    (<span class="name">lambda</span> ()</span><br><span class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</span><br><span class="line">      x)))</span><br></pre></td></tr></table></figure>
<p>当然，你也可以在需要随机数的时候直接调用rand-update，生成同样的随机数序列。但缺点是，这就<strong>需要程序中任何使用随机数的地方都必须显式的记住x的值</strong>，在生成下一个时，将x的值传给rand-update作为参数。</p>
<p>考虑用随机数实现<strong><em>蒙特卡洛法</em></strong> monte-carlo</p>
<blockquote>
<p> 蒙特卡洛模拟：从总体抽取大量随机样本，并通过这些随机样本估计这一随机事件的概率，将这个概率作为问题的解。</p>
</blockquote>
<p>比如，$6/\pi^2$是随机选取的两个整数之间没有公共因子（最大公因子（greatest common divisor，GCD）是1）的概率。</p>
<p>则可以通过每次随机选择两个证书并检查它们的GCD是否为1来近似的获得这个概率，π的近似求值。（Cesaro定理）</p>
<p><a href="https://zhuanlan.zhihu.com/p/47978393" target="_blank" rel="noopener">理解黎曼猜想（二）两个自然数互质的概率是多少？</a></p>
<p>那么，这个过程的核心就是蒙特卡洛模拟（monte-carlo），<strong>它以做某个实验的次数，以及这个实现本身作为参数</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">estimate-pi</span> trials)</span><br><span class="line">  (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> (<span class="name">monte-carlo</span> trials cesaro-test))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; Cesaro实验</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">cesaro-test</span>)</span><br><span class="line">  (<span class="name">=</span> (<span class="name">gcd</span> (<span class="name">rand</span>) (<span class="name">rand</span>)) <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">; 做某个实验的次数，以及这个实现本身作为参数</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> trials experiment)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</span><br><span class="line">           (<span class="name">/</span> trials-passed trials))</span><br><span class="line">          ((<span class="name">experiment</span>)</span><br><span class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) (<span class="name">+</span> trials-passed <span class="number">1</span>)))</span><br><span class="line">          (<span class="name">else</span></span><br><span class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) trials-passed))))</span><br><span class="line">  (<span class="name">iter</span> trials <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line">&gt; (<span class="name">estimate-pi</span> <span class="number">50</span>)</span><br><span class="line"><span class="number">2.449489742783178</span></span><br></pre></td></tr></table></figure>
<p>现在试一下不用rand，直接用rand-update，如果不使用赋值去模拟局部状态，则</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">random-gcd-test</span> trials initial-x)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed x)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">x1</span> (<span class="name">rand-update</span> x)))</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">x2</span> (<span class="name">rand-update</span> x1)))</span><br><span class="line">        (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</span><br><span class="line">               (<span class="name">/</span> trials-passed trials))</span><br><span class="line">              ((<span class="name">=</span> (<span class="name">gcd</span> x1 x2) <span class="number">1</span>)</span><br><span class="line">               (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</span><br><span class="line">                     (<span class="name">+</span> trials-passed <span class="number">1</span>)</span><br><span class="line">                     x2))</span><br><span class="line">              (<span class="name">else</span></span><br><span class="line">                (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</span><br><span class="line">                      trials-passed</span><br><span class="line">                      x2))))))</span><br><span class="line">  (<span class="name">iter</span> trials <span class="number">0</span> initial-x))</span><br></pre></td></tr></table></figure>
<p>很明显看到区别，在上面的方法中，蒙特卡洛可以<strong>抽象出一个公共方法，不限制experiment的具体形式</strong>，而下面的方法中，由于没有随机数生成器的局部状态，random-gcd-test必须显式的操作随机数x1和x2。</p>
<p>赋值和局部变量的好处：</p>
<blockquote>
<p>从复杂计算的角度来看，其他部分都像是<strong>随着时间不断变化，而它们自己隐藏起随时间变化的内部状态</strong>（比如银行账户和随机数生成器）。因此在进行系统抽象的时候，用<strong>局部变量去模拟系统的状态</strong>，用对这些<strong>变量的赋值去模拟状态的变化</strong>。</p>
</blockquote>
<h3 id="3-1-3-引进赋值的代价"><a href="#3-1-3-引进赋值的代价" class="headerlink" title="3.1.3 引进赋值的代价"></a>3.1.3 引进赋值的代价</h3><p>只要不使用赋值，以同样参数对同意过程的两次求值<strong>一定能产生同样的效果</strong>，就像在计算数学函数。不用任何赋值的程序设计成为<strong>函数式编程</strong>。</p>
<p><em>赋值如何让事情复杂化了？</em></p>
<p>来看make-withdraw的一个简化版本，其中不再关注是否有足够余额的问题：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; The Costs of Introducing Assignment</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">make-simplified-withdraw</span> balance)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">    (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</span><br><span class="line">    balance))</span><br><span class="line">(<span class="name">define</span> W (<span class="name">make-simplified-withdraw</span> <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</span><br><span class="line"><span class="number">-15</span></span><br></pre></td></tr></table></figure>
<p>如果没有set</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-decrementer</span> balance)</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</span><br><span class="line">    (<span class="name">-</span> balance amount)))</span><br><span class="line">(<span class="name">define</span> D (<span class="name">make-decrementer</span> <span class="number">25</span>))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>用<strong>代换模型</strong>来解释<code>make-decrementer</code>如何工作。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">make-decrementer</span> <span class="number">25</span>) <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 25代替balance</span></span><br><span class="line">((<span class="name">lambda</span> (<span class="name">amount</span>) (<span class="name">-</span> <span class="number">25</span> amount)) <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 应用运算符，20代替lambda中的amount</span></span><br><span class="line">(<span class="name">-</span> <span class="number">25</span> <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>类似的，来看<code>make-simplified-withdraw</code>如何工作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">make-simplified-withdraw</span> <span class="number">25</span>)   <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 25代替balance</span></span><br><span class="line">((lambda (amount) (set! balance (- 25 amount)) 25)   20))</span><br><span class="line"></span><br><span class="line"><span class="comment">; 20代替lambda中的amount，先将balance设为5，再返回25</span></span><br><span class="line">(<span class="name">set!</span> balance (<span class="name">-</span> <span class="number">25</span> <span class="number">20</span>)) <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>可见这里如果用<strong>代换模型</strong>，则这个过程首先将balance设为5，再返回25，显示是有问题的。造成这种问题的根源是：</p>
<p>在代换模型中，语言的符号（如balance）就是<strong>值的名字</strong>，而一旦引进了<strong>set和变量的值可以变化</strong>的想法，一个变量就不再是一个简单的名字了。</p>
<p><strong>同一和变化</strong></p>
<p>从这里暴露出的问题，远远不是打破了一个简单的计算模型，其意义要深远得多。一旦将变化引入了我们的计算模型，许多以前非常简单明了的概念现在都变得有问题了。</p>
<p>首先考虑两个物体实际上“<strong>同一</strong>”的概念。如果一个语言在表达式里支持“同一的东西可以相互替换”的概念，这样替换不会改变表达式的值，这个语言就称为是具有<font color="#FF0033" size="5">引用透明性</font>。</p>
<p>在我们的计算机语言包含了赋值操作之后，也就打破了引用透明性，产生了<strong>副作用</strong>。</p>
<ul>
<li><strong>修改变量的值</strong></li>
<li>IO 操作，如写数据到磁盘</li>
<li>UI 操作，如修改了一个按钮的可操作状态</li>
</ul>
<p><a href="https://juejin.im/post/5a58134751882573370794cc" target="_blank" rel="noopener">引用透明性和等式推理</a></p>
<p><strong>命令式编程的缺陷</strong></p>
<p>除了引入变量和赋值导致计算模型的复杂性之外，还容易出现一些不会在函数式编程中出现的错误，比如：</p>
<p>1.2.1节的迭代求阶乘</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> product counter)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</span><br><span class="line">      product</span><br><span class="line">        <span class="comment">; 注意这里</span></span><br><span class="line">      (<span class="name">iter</span> (<span class="name">*</span> counter product)</span><br><span class="line">	    (<span class="name">+</span> counter <span class="number">1</span>))))</span><br><span class="line">  (<span class="name">iter</span> <span class="number">1</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>如果用命令式编程，显式的通过赋值去更新变量product和counter的值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">product</span> <span class="number">1</span>)</span><br><span class="line">	(<span class="name">counter</span> <span class="number">1</span>))</span><br><span class="line">    (<span class="name">define</span> (<span class="name">iter</span>)</span><br><span class="line">      (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</span><br><span class="line">	product</span><br><span class="line">          <span class="comment">; 这两行的陷阱</span></span><br><span class="line">	(<span class="name">begin</span> (<span class="name">set!</span> product (<span class="name">*</span> counter product))</span><br><span class="line">	       (<span class="name">set!</span> counter (<span class="name">+</span> counter <span class="number">1</span>))</span><br><span class="line">	       (<span class="name">iter</span>))))</span><br><span class="line">    (<span class="name">iter</span>)))</span><br></pre></td></tr></table></figure>
<p>上述写法是正确的，但是如果颠倒其中两行的顺序</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;(set! counter (+ counter 1))</span></span><br><span class="line"><span class="comment">;(set! product (* counter product))</span></span><br></pre></td></tr></table></figure>
<p>结果就不对了。一般来说，<strong>带有赋值操作的程序强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本</strong>。</p>
<p>接下来要解决的问题就是，要给涉及赋值的表达式提供一种区别于之前的计算模型。</p>
<h2 id="3-2-求值的环境模型"><a href="#3-2-求值的环境模型" class="headerlink" title="3.2 求值的环境模型"></a>3.2 求值的环境模型</h2><p>之前说<strong>代换模型</strong>不再适用于赋值表达式。由于赋值操作的存在，此时的变量必须以某种方式指定了一个“位置”，相应的值可以存储在那里。在我们的新求值模型里，这种位置将维持在称为 <strong>环境</strong> 的结构中。</p>
<p>一些概念：</p>
<p>1）<strong>环境</strong>：<strong>框架</strong>的一个序列</p>
<p>2）<strong>框架</strong>：每个框架包含着一些 <strong>约束</strong> 的表格</p>
<p>3）<strong>约束</strong>：变量名和值相关联。（在一个框架里，任何变量至多只能有一个约束）</p>
<p>4）<strong>指针</strong>：每个框架还包含着一个<strong>指针</strong>，指向这一框架的<em>外围环境</em>。</p>
<p>5）<strong>变量</strong>：一个<em>变量</em>相对于某个特定环境的<em>值</em>，</p>
<p><img src="/.io//pic/3_1.png" alt="img"></p>
<p>​                                                                                一个简单的环境结构</p>
<p>1、2、3是三个框架，  ABCD都是环境指针，其中CD指向同一个环境。</p>
<p>环境对于求值过程是至关重要的，因为它确定了表达式求值的上下文。假设始终有一个全局环境，只包含一个框架（没有外围环境），这个环境包含所有关于基本过程的符号的值。</p>
<h3 id="3-2-1-求值规则"><a href="#3-2-1-求值规则" class="headerlink" title="3.2.1 求值规则"></a>3.2.1 求值规则</h3><p>在求值的环境模型中，过程只能通过一种方式创建，那就是通过求值一个lambda表达式。例如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure>
<p>过程定义的语法形式，不过是作为隐含lambda表达式的语法糖，等价于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> square</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x x))</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pic/3_3.png" alt="img"></p>
<p>过程对象的环境部分是一个指向全局环境的指针，因此产生这个过程的lambda表达式是在全局环境中求值的。</p>
<p>这里增加了一个新约束：将过程对象约束给符号square。一般来说，<strong>define就是把一个新的约束加入到框架中</strong>。</p>
<p>假设现在对表达式<code>(square 5)</code>求值，结果是创建了一个新环境——E1。</p>
<p>1）E1从一个框架开始，这个框架包含5赋值给x的约束。</p>
<p>2）E1引出的指针表示这个框架的外围环境是全局环境</p>
<p><strong>过程应用的环境模型</strong>：</p>
<ul>
<li>将一个过程对象应用于一组实际参数，将<strong>构造出一个新框架</strong>，其中将过程的<strong>形式参数约束到调用时的实际参数</strong>，而后在构造起的这一新环境的<strong>上下文中求值过程体</strong>。这个新框架的外围环境就是作为被应用的那个过程对象的一部分的环境。</li>
<li>相对于一个给定环境<strong>求值一个 lambda表达式</strong>，将会创建起一个过程对象，这个过程对象是一个序对，由该 lambda表达式 的正文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时的环境。</li>
</ul>
<p>关于<code>set!</code>的行为方式</p>
<p>在某个环境里求值 <strong><em>赋值表达式</em></strong> 时，要求我们首先在环境中确定有关变量的约束位置，而后再修改这个约束，使之表示这个新值。</p>
<p>这也就是说，首先需要<strong>找到包含这个变量的约束的第一个框架，而后修改这一框架</strong>。如果该变量在环境中没有约束，将报告一个错误。</p>
<h3 id="3-2-2-简单过程的应用"><a href="#3-2-2-简单过程的应用" class="headerlink" title="3.2.2 简单过程的应用"></a>3.2.2 简单过程的应用</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name">*</span> x x))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-of-squares</span> x y)</span><br><span class="line">  (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">f</span> a)</span><br><span class="line">  (<span class="name">sum-of-squares</span> (<span class="name">+</span> a <span class="number">1</span>) (<span class="name">*</span> a <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pic/3_4.png" alt="img"></p>
<p><img src="/.io//pic/3_5.png" alt="img"></p>
<p>求值 <code>(f 5)</code>：</p>
<ol>
<li>创建一个新环境 <code>E1</code>，参数 <code>a</code> 被约束到 5。在 <code>E1</code> 中求值 <code>(sum-of-square (+ a 1) (* a2))</code></li>
<li>求值组合式，首先求值子表达式。第一个子表达式 <code>sum-of-square</code> 以一个过程对象为值。（在 <code>E1</code> 的框架中未寻找到约束，而后进入有关的外围环境，并找到约束）</li>
<li>创建环境 <code>E2</code>，现在需要把过程对象 <code>sum-of-square</code> 应用于实参 6 和 10。</li>
</ol>
<h2 id="3-3-用变动的数据做模拟"><a href="#3-3-用变动的数据做模拟" class="headerlink" title="3.3 用变动的数据做模拟"></a>3.3 用变动的数据做模拟</h2><h3 id="3-3-1-变动的表结构"><a href="#3-3-1-变动的表结构" class="headerlink" title="3.3.1 变动的表结构"></a>3.3.1 变动的表结构</h3><p>针对序对的基本改变函数是set-car!和set-cdr!。<code>set-car!</code>要求两个参数，其中第一个参数必须是一个序对。然后修改这个序对，将它的car指针替换为指向set-car!第二个参数的指针。</p>
<p>假设x是<code>((a b) c d)</code>，y是<code>(e f)</code>，执行</p>
<p><img src="/.io//pic/image-20190612130259772.png" alt="image-20190612130259772"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(set-car! x y)</span><br></pre></td></tr></table></figure>
<p>修改x约束的那个表，将它的car用y的值取代。</p>
<p><img src="/.io//pic/image-20190612130309732.png" alt="image-20190612130309732"></p>
<p><strong>共享和相等</strong></p>
<p>当不同的数据对象共享某些序对时，会产生一些问题。例如，考虑下面的结构：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> x (<span class="name">list</span> 'a 'b))</span><br><span class="line">(<span class="name">define</span> z1 (<span class="name">cons</span> x x))</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pic/image-20190617143714166.png" alt="image-20190617143714166"></p>
<p>这里的z1是一个序对，car和cdr都指向同一个序对x。</p>
<p>再看另一个结构</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> z2 </span><br><span class="line">  (<span class="name">cons</span> (<span class="name">list</span> 'a 'b) (<span class="name">list</span> 'a 'b)))</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pic/image-20190617143741708.png" alt="image-20190617143741708"></p>
<p>两个表(a, b)的各个序对互不相同，虽然其中的符号是共享的。</p>
<p>作为表考虑，z1和z2表示同一个表<code>((a b) a b)</code>。一般而言，如果我们只用cons、car、cdr，z1和z2看不出差别。然而，<strong>如果允许修改表结构，共享的情况就会体现出差别</strong>。考虑下面的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">set-to-wow!</span> x)</span><br><span class="line">  (<span class="name">set-car!</span> (<span class="name">car</span> x) 'wow)</span><br><span class="line">  x)</span><br></pre></td></tr></table></figure>
<p>将<code>set-to-wow!</code>应用于z1和z2，将产生不同的结果。对于z1，修改car也就同时修改了cdr。而对于z2，只修改了car。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; z1</span><br><span class="line">((<span class="name">a</span> b) a b)</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">set-to-wow!</span> z1)</span><br><span class="line">((<span class="name">wow</span> b) wow b)</span><br><span class="line"></span><br><span class="line">&gt; z2</span><br><span class="line">((<span class="name">a</span> b) a b)</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">set-to-wow!</span> z2)</span><br><span class="line">((<span class="name">wow</span> b) a b)</span><br></pre></td></tr></table></figure>
<p>检测表结构是否共享的一种方式是使用<strong>谓词eq?</strong>。谓词<code>(eq? x y)</code>检查x和y作为指针是否相等。这样，对于z1和z2，<code>(eq? (car z1) (cdr z1))</code> 为true <code>(eq? (car z2) (cdr z2))</code> 为false。</p>
<h3 id="3-3-2-队列的表示"><a href="#3-3-2-队列的表示" class="headerlink" title="3.3.2 队列的表示"></a>3.3.2 队列的表示</h3><p>利用<code>set-car!</code> 和 <code>set-cdr!</code>，我们可以用序对构造出一些单靠cons、car、cdr无法构造的数据结构。这一节展示如何构造<strong>队列</strong>。</p>
<p>一个队列是一个序对，数据只能从一端插入（队列的尾），另一端删除（队列的首）。下面显示一个初始是空的队列，之后插入a和b，再删除a，再插入c和d，再删除b。</p>
<p><img src="/.io//pic/image-20190617145657417.png" alt="image-20190617145657417"></p>
<p>队列可以看做是由下面一组操作定义的结构：</p>
<ul>
<li>一个构造函数(make-queue) ，返回一个空队列。</li>
<li>两个选择函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(empty-queue? ⟨queue⟩)</span><br></pre></td></tr></table></figure>
<p>检查队列是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(front-queue ⟨queue⟩)</span><br></pre></td></tr></table></figure>
<p>返回队首的对象，如果空就报错。</p>
<ul>
<li>两个改变函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(insert-queue! ⟨queue⟩ ⟨item⟩)</span><br></pre></td></tr></table></figure>
<p>插入队尾，返回修改后的队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(delete-queue! ⟨queue⟩)</span><br></pre></td></tr></table></figure>
<p>删除队首对象，返回修改后的队列。</p>
<p>队列可以表示成一个常规的表，用car、cdr来完成上述操作。但是效率很低，为了插入一个数据项，需要扫描整个表，有<code>O(n)</code>的时间复杂度。那么简单修改一下表的表示方式，就可以只需<code>O(1)</code>的时间复杂度。方法就是加入一个指向队列尾的指针，这里就有两个指针<code>front-ptr</code> 和<code>rear-ptr</code>。</p>
<p><img src="/.io//pic/image-20190617155741378.png" alt="image-20190617155741378"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">front-ptr</span> queue) (<span class="name">car</span> queue))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">rear-ptr</span> queue) (<span class="name">cdr</span> queue))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">set-front-ptr!</span> queue item) </span><br><span class="line">  (<span class="name">set-car!</span> queue item))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">set-rear-ptr!</span> queue item) </span><br><span class="line">  (<span class="name">set-cdr!</span> queue item))</span><br></pre></td></tr></table></figure>
<p>现在来实现队列的其他操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">empty-queue</span>? queue) </span><br><span class="line">  (<span class="name">null</span>? (<span class="name">front-ptr</span> queue)))</span><br><span class="line">  </span><br><span class="line">(<span class="name">define</span> (<span class="name">make-queue</span>) (<span class="name">cons</span> '() '()))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">front-queue</span> queue)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">empty-queue</span>? queue)</span><br><span class="line">      (<span class="name">error</span> <span class="string">"FRONT called with an </span></span><br><span class="line"><span class="string">              empty queue"</span> queue)</span><br><span class="line">      (<span class="name">car</span> (<span class="name">front-ptr</span> queue))))</span><br></pre></td></tr></table></figure>
<p>如果要插入一个对象，按照下图的方式，</p>
<p>1）创建一个新队列，car是需要插入的项，cdr是空表。</p>
<p>2）若队列原来是空，就让<code>front-ptr</code> 和<code>rear-ptr</code>共同指向新序对。否则就修改rear-ptr，而指向新序对。</p>
<p><img src="/.io//pic/image-20190617162453179.png" alt="image-20190617162453179"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">insert-queue!</span> queue item)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">new-pair</span> (<span class="name">cons</span> item '())))</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</span><br><span class="line">           (<span class="name">set-front-ptr!</span> queue new-pair)</span><br><span class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</span><br><span class="line">           queue)</span><br><span class="line">          (<span class="name">else</span> (<span class="name">set-cdr!</span> (<span class="name">rear-ptr</span> queue) </span><br><span class="line">                          new-pair)</span><br><span class="line">                (<span class="name">set-rear-ptr!</span> queue new-pair)</span><br><span class="line">                queue))))</span><br></pre></td></tr></table></figure>
<p>要删除对象，就修改front-ptr，指向第二个数据项。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">delete-queue!</span> queue)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</span><br><span class="line">         (<span class="name">error</span> <span class="string">"DELETE! called with </span></span><br><span class="line"><span class="string">                 an empty queue"</span> queue))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">set-front-ptr!</span> </span><br><span class="line">               queue </span><br><span class="line">               (<span class="name">cdr</span> (<span class="name">front-ptr</span> queue)))</span><br><span class="line">              queue)))</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pic/image-20190617165406898.png" alt="image-20190617165406898"></p>
<h3 id="3-3-3-表格的表示"><a href="#3-3-3-表格的表示" class="headerlink" title="3.3.3 表格的表示"></a>3.3.3 表格的表示</h3><p>首先考虑一维表格的问题，每个记录实现为key和value的序对。这些记录连接起来就构成一个序对的表。为了向表格里面插入记录时有可以修改的位置，将这种表格构造为一种<strong>带有表头单元的表</strong>。表开头有一个“哑”记录——存放一个特殊符号，<code>*table*</code>。</p>
<p><img src="/.io//pic/image-20190617170617702.png" alt="image-20190617170617702"></p>
<p>为了从表格中提取信息，定义lookup过程，以key为参数，返回value。lookup基于assoc定义。assoc返回key的那条记录。lookup检查assoc返回的记录是否为假，而后返回value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">lookup</span> key table)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</span><br><span class="line">    (<span class="name">if</span> record</span><br><span class="line">        (<span class="name">cdr</span> record)</span><br><span class="line">        false)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">assoc</span> key records)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? records) false)</span><br><span class="line">        ((<span class="name">equal</span>? key (<span class="name">caar</span> records)) </span><br><span class="line">         (<span class="name">car</span> records))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> records)))))</span><br></pre></td></tr></table></figure>
<p>如果是插入操作，</p>
<p>1）首先用assoc检查表格中是否有这个key，如果没有，就cons这个key和value，构造出一个新记录。接着插入到表的最前面，位于哑记录之后。</p>
<p>2）如果表格中存在这个记录，就用该记录的cdr设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">insert!</span> key value table)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</span><br><span class="line">    (<span class="name">if</span> record</span><br><span class="line">        (<span class="name">set-cdr!</span> record value)</span><br><span class="line">        (<span class="name">set-cdr!</span> table</span><br><span class="line">                  (<span class="name">cons</span> (<span class="name">cons</span> key value) </span><br><span class="line">                        (<span class="name">cdr</span> table)))))</span><br><span class="line">  'ok)</span><br></pre></td></tr></table></figure>
<p>在构造一个新表时，只需创建起一个包含符号<code>*table*</code>的表。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</span><br><span class="line">  (<span class="name">list</span> '*table*))</span><br></pre></td></tr></table></figure>
<p><strong>二维表格</strong></p>
<p>二维表格的每个值用两个key索引。</p>
<p><img src="/.io//../../../../../Desktop/image-20190617172806860.png" alt="image-20190617172806860"></p>
<p><img src="/.io//pic/image-20190617172821310.png" alt="image-20190617172821310"></p>
<p>二维表的查询。先用第一个key确定对应的子表格，而后用第二个key确定value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">lookup</span> key-1 key-2 table)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</span><br><span class="line">    (<span class="name">if</span> subtable</span><br><span class="line">        (<span class="name">let</span> ((<span class="name">record</span> </span><br><span class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</span><br><span class="line">          (<span class="name">if</span> record (<span class="name">cdr</span> record) false))</span><br><span class="line">        false)))</span><br></pre></td></tr></table></figure>
<p>二维表的插入。首先用assoc查看key-1是否有一个子表格，没有就构造，其中只包含一个记录<code>(key-2, value)</code>。若有，就将新值插入该子表格。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">insert!</span> key-1 key-2 value table)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</span><br><span class="line">    (<span class="name">if</span> subtable</span><br><span class="line">        (<span class="name">let</span> ((<span class="name">record</span> </span><br><span class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</span><br><span class="line">          (<span class="name">if</span> record</span><br><span class="line">              (<span class="name">set-cdr!</span> record value)</span><br><span class="line">              (<span class="name">set-cdr!</span> </span><br><span class="line">               subtable</span><br><span class="line">               (<span class="name">cons</span> (<span class="name">cons</span> key-2 value)</span><br><span class="line">                     (<span class="name">cdr</span> subtable)))))</span><br><span class="line">        (<span class="name">set-cdr!</span> </span><br><span class="line">         table</span><br><span class="line">         (<span class="name">cons</span> (<span class="name">list</span> key-1 (<span class="name">cons</span> key-2 value))</span><br><span class="line">               (<span class="name">cdr</span> table)))))</span><br><span class="line">  'ok)</span><br></pre></td></tr></table></figure>
<p><strong>创建局部表格</strong></p>
<p>上述的lookup和insert!都以整个表格为参数，这也使我们可以将它们用到包含多个表格的程序中。处理多个表格的方式是为每个表格提供一对独立的lookup和insert！过程。</p>
<p>实现的方案是，用过程表示表格，将表格表示为一个以局部状态的方式维持一个内部表格的对象。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">local-table</span> (<span class="name">list</span> '*table*)))</span><br><span class="line">    (<span class="name">define</span> (<span class="name">lookup</span> key-1 key-2)</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">subtable</span> </span><br><span class="line">             (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> local-table))))</span><br><span class="line">        (<span class="name">if</span> subtable</span><br><span class="line">            (<span class="name">let</span> ((<span class="name">record</span> </span><br><span class="line">                   (<span class="name">assoc</span> key-2 </span><br><span class="line">                          (<span class="name">cdr</span> subtable))))</span><br><span class="line">              (<span class="name">if</span> record (<span class="name">cdr</span> record) false))</span><br><span class="line">            false)))</span><br><span class="line">    (<span class="name">define</span> (<span class="name">insert!</span> key-1 key-2 value)</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">subtable</span> </span><br><span class="line">             (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> local-table))))</span><br><span class="line">        (<span class="name">if</span> subtable</span><br><span class="line">            (<span class="name">let</span> ((<span class="name">record</span> </span><br><span class="line">                   (<span class="name">assoc</span> key-2 </span><br><span class="line">                          (<span class="name">cdr</span> subtable))))</span><br><span class="line">              (<span class="name">if</span> record</span><br><span class="line">                  (<span class="name">set-cdr!</span> record value)</span><br><span class="line">                  (<span class="name">set-cdr!</span> </span><br><span class="line">                   subtable</span><br><span class="line">                   (<span class="name">cons</span> (<span class="name">cons</span> key-2 value)</span><br><span class="line">                         (<span class="name">cdr</span> subtable)))))</span><br><span class="line">            (<span class="name">set-cdr!</span> </span><br><span class="line">             local-table</span><br><span class="line">             (<span class="name">cons</span> (<span class="name">list</span> key-1</span><br><span class="line">                         (<span class="name">cons</span> key-2 value))</span><br><span class="line">                   (<span class="name">cdr</span> local-table)))))</span><br><span class="line">      'ok)</span><br><span class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'lookup-proc) lookup)</span><br><span class="line">            ((<span class="name">eq</span>? m 'insert-proc!) insert!)</span><br><span class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown operation: </span></span><br><span class="line"><span class="string">                          TABLE"</span> m))))</span><br><span class="line">    dispatch))</span><br></pre></td></tr></table></figure>
<p>利用make-table，我们可以实现get和put操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> operation-table (<span class="name">make-table</span>))</span><br><span class="line">(<span class="name">define</span> get (<span class="name">operation-table</span> 'lookup-proc))</span><br><span class="line">(<span class="name">define</span> put (<span class="name">operation-table</span> 'insert-proc!))</span><br></pre></td></tr></table></figure>
<p>这两个操作都访问同一个局部表格，这一表格被封装在由对make-table的调用创建起的对象里面。</p>
<h3 id="3-3-4-数字电路的模拟器"><a href="#3-3-4-数字电路的模拟器" class="headerlink" title="3.3.4 数字电路的模拟器"></a>3.3.4 数字电路的模拟器</h3><p><img src="/.io//pic/image-20190618100752926.png" alt="image-20190618100752926"></p>
<p>连接基本组件来构造更复杂的功能。比如下面的<strong>半加器</strong>电路，包括一个或门，两个与门和一个非门。</p>
<p><img src="/.io//pic/image-20190618101130329.png" alt="image-20190618101130329"></p>
<p>当A=1或B=1之一是1时，S=1，当A=1且B=1时，C=1。</p>
<blockquote>
<p><strong>半加器</strong></p>
<p>半加器是实现两个一位二进制数加法运算的器件。它具有两个输入端(被加数A和加数B)及输出端Y。 [1] </p>
<p>A和B是相加的两个数，S是半加和数，C是进位数。</p>
<p>所谓半加就是不考虑进位的加法，它的真值表如下 (见表)：</p>
<p><img src="/.io//pic/image-20190618103146103.png" alt="image-20190618103146103"></p>
</blockquote>
<p>现在要构造一个程序来模拟数字逻辑电路。最基本元素是make-wire，用于构造连线。比如可以构造出</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> a (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> b (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> c (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> d (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> e (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> s (<span class="name">make-wire</span>))</span><br></pre></td></tr></table></figure>
<p>如果需要把一个功能连到一组连线上，就调用一个构造这类功能的过程，参数就是连线。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">or-gate</span> a b d)</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">(<span class="name">and-gate</span> a b c)</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">(<span class="name">inverter</span> c e)</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">(<span class="name">and-gate</span> d e s)</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<p>再拼接成<strong>半加器</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">half-adder</span> a b s c)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">d</span> (<span class="name">make-wire</span>)) (<span class="name">e</span> (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">or-gate</span> a b d)</span><br><span class="line">    (<span class="name">and-gate</span> a b c)</span><br><span class="line">    (<span class="name">inverter</span> c e)</span><br><span class="line">    (<span class="name">and-gate</span> d e s)</span><br><span class="line">    'ok))</span><br></pre></td></tr></table></figure>
<p>在这个基础上，可以再构建<strong>全加器</strong>。</p>
<blockquote>
<p><strong>全加器</strong></p>
<p>全加器能进行加数、被加数和低位来的进位信号相加，并根据求和结果给出该位的进位信号。</p>
<p>当多位数相加时，半加器可用于最低位求和，并给出进位数。第二位的相加有两个待加数和，还有一个来自前面低位送来的进位数。这三个数相加，得出本位和数（全加和数）和进位数。这种就是“全加“，下表为全加器的逻辑状态表。</p>
<p><img src="/.io//pic/o4YBAFtYGTaAfKmzAAAvuawUHgA437.png" alt="åå å¨åå¨å å¨çåçååºå«ï¼ç»æååè½ï¼"></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">full-adder</span> a b c-in sum c-out)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">c1</span> (<span class="name">make-wire</span>)) </span><br><span class="line">        (<span class="name">c2</span> (<span class="name">make-wire</span>))</span><br><span class="line">        (<span class="name">s</span>  (<span class="name">make-wire</span>)))</span><br><span class="line">    (<span class="name">half-adder</span> b c-in s c1)</span><br><span class="line">    (<span class="name">half-adder</span> a s sum c2)</span><br><span class="line">    (<span class="name">or-gate</span> c1 c2 c-out)</span><br><span class="line">    'ok))</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pic/image-20190618113425796.png" alt="image-20190618113425796"></p>
<p>从模拟器的角度，各种功能块构成了基础，将功能块连接起来就是这里的组合方法，而将特定的连接模式定义为过程就是这里的抽象方法。</p>
<h4 id="基本功能块"><a href="#基本功能块" class="headerlink" title="基本功能块"></a><strong>基本功能块</strong></h4><p>基本功能块使得在一根连线上的信号变化能够影响其他连线上的信号。我们添加如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(get-signal ⟨wire⟩)</span><br></pre></td></tr></table></figure>
<p>返回连线上信号的当前值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(set-signal! ⟨wire⟩ ⟨new value⟩)</span><br></pre></td></tr></table></figure>
<p>将连线上信号修改为新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)</span><br></pre></td></tr></table></figure>
<p>改变信号值就需要执行该过程。这种过程是一些媒介，能够将相应连线上值的变化传递到其他的连线。</p>
<p>利用这些过程，可以定义基本的数字逻辑功能了。为了把输入通过一个反门连接到输出，用add-action! 为输入关联一个过程，当输入路线的值改变时，执行这一过程。</p>
<p>先看<strong>非门</strong>，在一个inverter-delay后将输出线路设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">inverter</span> input output)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">invert-input</span>)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">new-value</span> </span><br><span class="line">           (<span class="name">logical-not</span> (<span class="name">get-signal</span> input))))</span><br><span class="line">      (<span class="name">after-delay</span> </span><br><span class="line">       inverter-delay</span><br><span class="line">       (<span class="name">lambda</span> ()</span><br><span class="line">         (<span class="name">set-signal!</span> output new-value)))))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">add-action!</span> input invert-input)</span><br><span class="line">  'ok)</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">logical-not</span> s)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">=</span> s <span class="number">0</span>) <span class="number">1</span>)</span><br><span class="line">        ((<span class="name">=</span> s <span class="number">1</span>) <span class="number">0</span>)</span><br><span class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s))))</span><br></pre></td></tr></table></figure>
<p>下面是<strong>与门</strong>的定义。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">and-gate</span> a1 a2 output)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">and-action-procedure</span>)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">new-value</span></span><br><span class="line">           (<span class="name">logical-and</span> (<span class="name">get-signal</span> a1) </span><br><span class="line">                        (<span class="name">get-signal</span> a2))))</span><br><span class="line">      (<span class="name">after-delay</span> </span><br><span class="line">       and-gate-delay</span><br><span class="line">       (<span class="name">lambda</span> ()</span><br><span class="line">         (<span class="name">set-signal!</span> output new-value)))))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">add-action!</span> a1 and-action-procedure)</span><br><span class="line">  (<span class="name">add-action!</span> a2 and-action-procedure)</span><br><span class="line">  'ok)</span><br></pre></td></tr></table></figure>
<h4 id="线路的表示"><a href="#线路的表示" class="headerlink" title="线路的表示"></a><strong>线路的表示</strong></h4><p>一条线路是一个具有两个局部状态变量的计算对象：一个是信号值signal-value（初值为0），一个是一组过程action-procedures，在信号值改变时，这些过程需要运行。类似于在3.1.1中处理银行账户的做法实现：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-wire</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">signal-value</span> <span class="number">0</span>) </span><br><span class="line">        (<span class="name">action-procedures</span> '()))</span><br><span class="line">       </span><br><span class="line">    (<span class="name">define</span> (<span class="name">set-my-signal!</span> new-value)</span><br><span class="line">      (<span class="name">if</span> (<span class="name">not</span> (<span class="name">=</span> signal-value new-value))</span><br><span class="line">          (<span class="name">begin</span> (<span class="name">set!</span> signal-value new-value)</span><br><span class="line">                 (<span class="name">call-each</span> </span><br><span class="line">                  action-procedures))</span><br><span class="line">          'done))</span><br><span class="line">       </span><br><span class="line">    (<span class="name">define</span> (<span class="name">accept-action-procedure!</span> proc)</span><br><span class="line">      (<span class="name">set!</span> action-procedures </span><br><span class="line">            (<span class="name">cons</span> proc action-procedures))</span><br><span class="line">      (<span class="name">proc</span>))</span><br><span class="line">       </span><br><span class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'get-signal) </span><br><span class="line">             signal-value)</span><br><span class="line">            ((<span class="name">eq</span>? m 'set-signal!) </span><br><span class="line">             set-my-signal!)</span><br><span class="line">            ((<span class="name">eq</span>? m 'add-action!) </span><br><span class="line">             accept-action-procedure!)</span><br><span class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown operation: </span></span><br><span class="line"><span class="string">                          WIRE"</span> m))))</span><br><span class="line">    dispatch))</span><br></pre></td></tr></table></figure>
<p><code>set-my-signal!</code>检查新的信号值是否实际改变了线路上的信号，如果是，就用<code>call-each</code>运行每个动作过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">call-each</span> procedures)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? procedures)</span><br><span class="line">      'done</span><br><span class="line">      (<span class="name">begin</span> ((<span class="name">car</span> procedures))</span><br><span class="line">             (<span class="name">call-each</span> (<span class="name">cdr</span> procedures)))))</span><br></pre></td></tr></table></figure>
<p>一旦设置好dispatch过程，就可以提供以下访问线路中局部操作的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">get-signal</span> wire)</span><br><span class="line">  (<span class="name">wire</span> 'get-signal))</span><br><span class="line">(<span class="name">define</span> (<span class="name">set-signal!</span> wire new-value)</span><br><span class="line">  ((<span class="name">wire</span> 'set-signal!) new-value))</span><br><span class="line">(<span class="name">define</span> (<span class="name">add-action!</span> wire action-procedure)</span><br><span class="line">  ((<span class="name">wire</span> 'add-action!) action-procedure))</span><br></pre></td></tr></table></figure>
<h4 id="待处理表agenda"><a href="#待处理表agenda" class="headerlink" title="待处理表agenda"></a><strong>待处理表agenda</strong></h4><p>最后是after-delay的实现。要维护一个称为待处理表的数据结构，包含需要完成的事项清单。定义如下操作：</p>
<ul>
<li><code>(make-agenda)</code> 返回一个新的空agenda.</li>
<li><code>(empty-agenda? ⟨agenda⟩)</code> .</li>
<li><code>(first-agenda-item ⟨agenda⟩)</code> 返回agenda第一个item.</li>
<li><code>(remove-first-agenda-item! ⟨agenda⟩)</code> .</li>
<li><code>(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)</code> </li>
<li><code>(current-time ⟨agenda⟩)</code> 返回当时的模拟时间。</li>
</ul>
<p>用<code>the-agenda</code>表示特定的待处理表。以下过程向<code>the-agenda</code>中插入一个新item</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">after-delay</span> delay action)</span><br><span class="line">  (<span class="name">add-to-agenda!</span> </span><br><span class="line">   (<span class="name">+</span> delay (<span class="name">current-time</span> the-agenda))</span><br><span class="line">   action</span><br><span class="line">   the-agenda))</span><br></pre></td></tr></table></figure>
<p>agenda中的模拟过程用propagate实现，它操作<code>the-agenda</code>，顺序执行agenda的每个过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">propagate</span>)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">empty-agenda</span>? the-agenda)</span><br><span class="line">      'done</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">first-item</span> </span><br><span class="line">             (<span class="name">first-agenda-item</span> the-agenda)))</span><br><span class="line">        (<span class="name">first-item</span>)</span><br><span class="line">        (<span class="name">remove-first-agenda-item!</span> the-agenda)</span><br><span class="line">        (<span class="name">propagate</span>))))</span><br></pre></td></tr></table></figure>
<h4 id="一个简单的实例模拟"><a href="#一个简单的实例模拟" class="headerlink" title="一个简单的实例模拟"></a>一个简单的实例模拟</h4><p>下面过程将一个<strong>监测器</strong>放到一个线路上，用于显示模拟器的活动。这一过程会告诉相应线路，只要它的值改变了，就打印出新的值，同时打印当前时间和线路名称。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">probe</span> name wire)</span><br><span class="line">  (<span class="name">add-action!</span> </span><br><span class="line">   wire</span><br><span class="line">   (<span class="name">lambda</span> ()</span><br><span class="line">     (<span class="name">newline</span>)</span><br><span class="line">     (<span class="name">display</span> name)</span><br><span class="line">     (<span class="name">display</span> <span class="string">" "</span>)</span><br><span class="line">     (<span class="name">display</span> (<span class="name">current-time</span> the-agenda))</span><br><span class="line">     (<span class="name">display</span> <span class="string">"  New-value = "</span>)</span><br><span class="line">     (<span class="name">display</span> (<span class="name">get-signal</span> wire)))))</span><br></pre></td></tr></table></figure>
<p>我们从初始化待处理表和描述各种功能块的延时开始</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> the-agenda (<span class="name">make-agenda</span>))</span><br><span class="line">(<span class="name">define</span> inverter-delay <span class="number">2</span>)</span><br><span class="line">(<span class="name">define</span> and-gate-delay <span class="number">3</span>)</span><br><span class="line">(<span class="name">define</span> or-gate-delay <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>现在定义4条线路，在其中两条线路上安装监测器</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> input-1 (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> input-2 (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> sum (<span class="name">make-wire</span>))</span><br><span class="line">(<span class="name">define</span> carry (<span class="name">make-wire</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">probe</span> 'sum sum)</span><br><span class="line">sum <span class="number">0</span>  New-value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">(<span class="name">probe</span> 'carry carry)</span><br><span class="line">carry <span class="number">0</span>  New-value = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后将这些线路连接到一个半加器电路上</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">half-adder</span> input-1 input-2 sum carry)</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">(<span class="name">set-signal!</span> input-1 <span class="number">1</span>)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">(<span class="name">propagate</span>)</span><br><span class="line">sum <span class="number">8</span>  New-value = <span class="number">1</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在时间8, sum上的信号变为1。现在到了模拟开始之后的8个时间单位。在这一点上，我们可 以将input-2上的信号设置为1，并让有关的值向前传播：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">set-signal!</span> input-2 <span class="number">1</span>)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">(<span class="name">propagate</span>)</span><br><span class="line">carry <span class="number">11</span>  New-value = <span class="number">1</span></span><br><span class="line">sum <span class="number">16</span>  New-value = <span class="number">0</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>在时间11处，carry变成1，16处sum变成0。</p>
<h4 id="agenda的实现"><a href="#agenda的实现" class="headerlink" title="agenda的实现"></a>agenda的实现</h4><p>这种待处理表由一些时间段组成，每个时间段是由一个数值（表示时间）和一个队列(见练习3.32)组成的序对，在这个队列里，保存着那些已经安排好的，应该在这一时间段运行的过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-time-segment</span> time queue)</span><br><span class="line">  (<span class="name">cons</span> time queue))</span><br><span class="line">(<span class="name">define</span> (<span class="name">segment-time</span> s) (<span class="name">car</span> s))</span><br><span class="line">(<span class="name">define</span> (<span class="name">segment-queue</span> s) (<span class="name">cdr</span> s))</span><br></pre></td></tr></table></figure>
<p>我们将用3.3.2节描述的队列操作完成在时间段队列上的操作。<br>待处理表本身就是时间段的一个一维表格。与3.3.3节所示的表格的不同之处，就在于这 些时间段应该按照时间递增的顺序排列。此外，我们还需在待处理表的头部保存一个当前时 间（即，此前最后被处理的那个动作的时间）。一个新构造出的待处理表里没有时间段，其当前时间是0。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-agenda</span>) (<span class="name">list</span> <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">current-time</span> agenda) (<span class="name">car</span> agenda))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">set-current-time!</span> agenda time)</span><br><span class="line">  (<span class="name">set-car!</span> agenda time))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">segments</span> agenda) (<span class="name">cdr</span> agenda))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">set-segments!</span> agenda segments)</span><br><span class="line">  (<span class="name">set-cdr!</span> agenda segments))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">first-segment</span> agenda) </span><br><span class="line">  (<span class="name">car</span> (<span class="name">segments</span> agenda)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">rest-segments</span> agenda) </span><br><span class="line">  (<span class="name">cdr</span> (<span class="name">segments</span> agenda)))</span><br></pre></td></tr></table></figure>
<p>若一个agenda没有时间段，那它就是空的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">empty-agenda</span>? agenda)</span><br><span class="line">  (<span class="name">null</span>? (<span class="name">segments</span> agenda)))</span><br></pre></td></tr></table></figure>
<p>为了将一个动作加入待处理表，</p>
<p>1）我们首先要检査这个待处理表是否为空。如果真是这样，那么就<strong>创建一个新的时间段</strong>，并将这个时间段装入待处理表里。</p>
<p>2）否则我们就扫描整个的待处理表，检査其中各个时间段的时间。如果发现某个时间段具有合适的时间，那么就把这个动作加入与之关联的队列里。如果碰到了某个比需要预约的时间更晚的时间，那么就将一个新的时间段插入待处理表，插入这个位置之前。如果到达了待处理表的末尾，我们就必须在最后加上一个新的时间段。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">add-to-agenda!</span> time action agenda)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">belongs-before</span>? segments)</span><br><span class="line">    (<span class="name">or</span> (<span class="name">null</span>? segments)</span><br><span class="line">        (<span class="name">&lt;</span> time </span><br><span class="line">           (<span class="name">segment-time</span> (<span class="name">car</span> segments)))))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">make-new-time-segment</span> time action)</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">make-queue</span>)))</span><br><span class="line">      (<span class="name">insert-queue!</span> q action)</span><br><span class="line">      (<span class="name">make-time-segment</span> time q)))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">add-to-segments!</span> segments)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">=</span> (<span class="name">segment-time</span> (<span class="name">car</span> segments)) time)</span><br><span class="line">        (<span class="name">insert-queue!</span> </span><br><span class="line">         (<span class="name">segment-queue</span> (<span class="name">car</span> segments))</span><br><span class="line">         action)</span><br><span class="line">        (<span class="name">let</span> ((<span class="name">rest</span> (<span class="name">cdr</span> segments)))</span><br><span class="line">          (<span class="name">if</span> (<span class="name">belongs-before</span>? rest)</span><br><span class="line">              (<span class="name">set-cdr!</span></span><br><span class="line">               segments</span><br><span class="line">               (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </span><br><span class="line">                      time </span><br><span class="line">                      action)</span><br><span class="line">                     (<span class="name">cdr</span> segments)))</span><br><span class="line">              (<span class="name">add-to-segments!</span> rest)))))</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">segments</span> (<span class="name">segments</span> agenda)))</span><br><span class="line">    (<span class="name">if</span> (<span class="name">belongs-before</span>? segments)</span><br><span class="line">        (<span class="name">set-segments!</span></span><br><span class="line">         agenda</span><br><span class="line">         (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </span><br><span class="line">                time </span><br><span class="line">                action)</span><br><span class="line">               segments))</span><br><span class="line">        (<span class="name">add-to-segments!</span> segments))))</span><br></pre></td></tr></table></figure>
<p>从待处理表中<strong>删除第一项</strong>的过程，应该删去第一个时间段的队列前端的那一项。如果删 除使这个时间段变空了，我们就将这个时间段也从时间段的表里删去:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">remove-first-agenda-item!</span> agenda)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">segment-queue</span> </span><br><span class="line">            (<span class="name">first-segment</span> agenda))))</span><br><span class="line">    (<span class="name">delete-queue!</span> q)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">empty-queue</span>? q)</span><br><span class="line">        (<span class="name">set-segments!</span> </span><br><span class="line">         agenda </span><br><span class="line">         (<span class="name">rest-segments</span> agenda)))))</span><br></pre></td></tr></table></figure>
<p>找出待处理表中里第一项，也就是找出其第一个时间段队列里的第一项。无论何时提取 这个项时，都需要更新待处理表的当前时间</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">first-agenda-item</span> agenda)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">empty-agenda</span>? agenda)</span><br><span class="line">      (<span class="name">error</span> <span class="string">"Agenda is empty: </span></span><br><span class="line"><span class="string">              FIRST-AGENDA-ITEM"</span>)</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">first-seg</span> </span><br><span class="line">             (<span class="name">first-segment</span> agenda)))</span><br><span class="line">        (<span class="name">set-current-time!</span> </span><br><span class="line">         agenda </span><br><span class="line">         (<span class="name">segment-time</span> first-seg))</span><br><span class="line">        (<span class="name">front-queue</span> </span><br><span class="line">         (<span class="name">segment-queue</span> first-seg)))))</span><br></pre></td></tr></table></figure>
<h3 id="3-3-5-约束的传播"><a href="#3-3-5-约束的传播" class="headerlink" title="3.3.5 约束的传播"></a>3.3.5 约束的传播</h3><p>在传统上，<strong>计算机程序总被组织成一种单向的计算，它们对一些事先给定的参数执行某些操作，产生出所需要的输出。</strong>但在另一方面，我们也经常需要模拟一些<strong>由各种量之间的关系描述的系统</strong>。例如，某个机械结构的数学模型里可能包含着这样的一些信息：在一个金属杆的偏转量d与作用于这个杆的力F、杆的长度L、截面面积A和弹性模数之间的关系可以由下面方程描述</p>
<script type="math/tex; mode=display">
dAE=FL</script><p>这种关系并不是单向的，<strong>给定了其中任意的4个量，我们就可以利用它计算出第5个量</strong>。然而，<strong>要将这种方程翻译到传统的程序设计语言，就会迫使我们选出一个量，要求基于另外的4个量去计算出它</strong>。这样，一个用于计算面积A的过程将不能用于计算偏转量。虽然对于A和d的计算都出自这同一个方程。</p>
<p>在这一节里，我们要描绘一种语言的设计，这种语言将使我们可以基于各种关系进行工作。这一语言里的基本元素就是基本约束，它们描述了在不同量之间的某种特定关系。例如，<code>(adder a b c)</code>描述的是量a、b和c之间必须有关系$a+b=c$，<code>(multiplier x y z)</code>描述的是约束关系$xy=z$，而<code>(constant 3.14 x)</code>表示x的值永远都是3.14。</p>
<p>我们的语言里还提供了一些方法，使它们可以用于组合各种基本约束，以便去描述更复杂的关系。在这里，我们将通过构造<strong>约束网络</strong>的方式组合起各种约束，在这种约束网络里，约束通过<strong>连接器</strong>连接起来。连接器是一种对象，它们可以“保存”一个值，使之能参与一个<br>或者多个约束。例如，我们知道在华氏温度和摄氏温度之间的关系是：</p>
<script type="math/tex; mode=display">
9C=5(F-32)</script><p>这样的约束就可以看做是一个网络。通过基本<strong>加法约束</strong>、<strong>乘法约束</strong>和<strong>常量约束</strong>组成。在这个图里，我们看到左边的乘法块有三个引线，分别标记为 m1 、 m2 和p。该乘法约束的这些引线以如下方式连接到网络的其他部分：引线 m1连到连接器 C ，这个连接器将保存摄氏温度。引线 m2 接在连接器 w ，该连接器还连接着一个保存常量 9 的约束块。引线 p 被这一乘法块约束到 m1和 m2 的乘积，它还连接到另一个乘法块的引线p。另一乘法块的 m2连接到常量 5 ，它的 m1 连接到另一加法块的一条引线上。</p>
<p><img src="/.io//pic/image-20190618163207055.png" alt="image-20190618163207055"></p>
<h4 id="约束系统的使用"><a href="#约束系统的使用" class="headerlink" title="约束系统的使用"></a>约束系统的使用</h4><p>首先调用构造函数make-connector，创建起两个连接器C和F</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> C (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name">define</span> F (<span class="name">make-connector</span>))</span><br><span class="line">(<span class="name">celsius-fahrenheit-converter</span> C F)</span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">celsius-fahrenheit-converter</span> c f)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">u</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">v</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">w</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">x</span> (<span class="name">make-connector</span>))</span><br><span class="line">        (<span class="name">y</span> (<span class="name">make-connector</span>)))</span><br><span class="line">    (<span class="name">multiplier</span> c w u)</span><br><span class="line">    (<span class="name">multiplier</span> v x u)</span><br><span class="line">    (<span class="name">adder</span> v y f)</span><br><span class="line">    (<span class="name">constant</span> <span class="number">9</span> w)</span><br><span class="line">    (<span class="name">constant</span> <span class="number">5</span> x)</span><br><span class="line">    (<span class="name">constant</span> <span class="number">32</span> y)</span><br><span class="line">    'ok))</span><br></pre></td></tr></table></figure>
<h4 id="约束系统的实现"><a href="#约束系统的实现" class="headerlink" title="约束系统的实现"></a>约束系统的实现</h4><p>类似于数字电路模拟器。虽然约束系统里的基本对象在某些方面更复杂一些,但整个系统却更为简单,因为这里完全不需要关心待处理表和时间延迟等等问题。</p>
<p>连接器的基本操作包括</p>
<ul>
<li><code>(has-value? ⟨connector⟩)</code> .</li>
<li><code>(get-value ⟨connector⟩)</code> .</li>
<li><code>(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)</code> </li>
<li><code>(forget-value! ⟨connector⟩ ⟨retractor⟩)</code> 要求连接器忘记改值。</li>
<li><code>(connect ⟨connector⟩ ⟨new-constraint⟩)</code> 通过连接器参与一个新约束。</li>
</ul>
<p>通过<code>inform-about-value</code>与各个相关约束通信，这一过程告知给定的约束，该连接器有了新值。而<code>inform-about-no-value</code>告知该连接器丧失了原有的值。</p>
<p><code>adder</code>在被求和连接器a1和a2和连接器sum之间构造出一个加法约束。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; adder将一个新的加法约束连接到指定连接器。me就代表那个加法约束。</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">adder</span> a1 a2 sum)</span><br><span class="line">  <span class="comment">; 当加法约束得到了通知，知道自己的一个连接器有了新值后，process-new-value就会被调用。</span></span><br><span class="line">  (<span class="name">define</span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">and</span> (<span class="name">has-value</span>? a1) </span><br><span class="line">                (<span class="name">has-value</span>? a2))</span><br><span class="line">           (<span class="name">set-value!</span> sum</span><br><span class="line">                       (<span class="name">+</span> (<span class="name">get-value</span> a1) </span><br><span class="line">                          (<span class="name">get-value</span> a2))</span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name">and</span> (<span class="name">has-value</span>? a1) </span><br><span class="line">                (<span class="name">has-value</span>? sum))</span><br><span class="line">           (<span class="name">set-value!</span> a2</span><br><span class="line">                       (<span class="name">-</span> (<span class="name">get-value</span> sum) </span><br><span class="line">                          (<span class="name">get-value</span> a1))</span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name">and</span> (<span class="name">has-value</span>? a2) </span><br><span class="line">                (<span class="name">has-value</span>? sum))</span><br><span class="line">           (<span class="name">set-value!</span> a1</span><br><span class="line">                       (<span class="name">-</span> (<span class="name">get-value</span> sum) </span><br><span class="line">                          (<span class="name">get-value</span> a2))</span><br><span class="line">                       me))))</span><br><span class="line">  <span class="comment">; 如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行process-new-value。</span></span><br><span class="line">  (<span class="name">define</span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">forget-value!</span> sum me)</span><br><span class="line">    (<span class="name">forget-value!</span> a1 me)</span><br><span class="line">    (<span class="name">forget-value!</span> a2 me)</span><br><span class="line">    (<span class="name">process-new-value</span>))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? request 'I-have-a-value)</span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name">eq</span>? request 'I-lost-my-value)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request: </span></span><br><span class="line"><span class="string">                        ADDER"</span> request))))</span><br><span class="line">  (<span class="name">connect</span> a1 me)</span><br><span class="line">  (<span class="name">connect</span> a2 me)</span><br><span class="line">  (<span class="name">connect</span> sum me)</span><br><span class="line">  me)</span><br></pre></td></tr></table></figure>
<p><code>adder</code>将一个新的加法约束连接到指定连接器。<code>me</code>就代表那个加法约束。</p>
<p>当加法约束得到了通知，知道自己的一个连接器有了新值后，<code>process-new-value</code>就会被调用。</p>
<p>如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行<code>process-new-value</code>。</p>
<p>乘法对象类似于加法对象。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">multiplier</span> m1 m2 product)</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">or</span> (<span class="name">and</span> (<span class="name">has-value</span>? m1) </span><br><span class="line">                    (<span class="name">=</span> (<span class="name">get-value</span> m1) <span class="number">0</span>))</span><br><span class="line">               (<span class="name">and</span> (<span class="name">has-value</span>? m2) </span><br><span class="line">                    (<span class="name">=</span> (<span class="name">get-value</span> m2) <span class="number">0</span>)))</span><br><span class="line">           (<span class="name">set-value!</span> product <span class="number">0</span> me))</span><br><span class="line">          ((<span class="name">and</span> (<span class="name">has-value</span>? m1) </span><br><span class="line">                (<span class="name">has-value</span>? m2))</span><br><span class="line">           (<span class="name">set-value!</span> product</span><br><span class="line">                       (<span class="name">*</span> (<span class="name">get-value</span> m1) </span><br><span class="line">                          (<span class="name">get-value</span> m2))</span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name">and</span> (<span class="name">has-value</span>? product) </span><br><span class="line">                (<span class="name">has-value</span>? m1))</span><br><span class="line">           (<span class="name">set-value!</span> m2</span><br><span class="line">                       (<span class="name">/</span> (<span class="name">get-value</span> product) </span><br><span class="line">                          (<span class="name">get-value</span> m1))</span><br><span class="line">                       me))</span><br><span class="line">          ((<span class="name">and</span> (<span class="name">has-value</span>? product) </span><br><span class="line">                (<span class="name">has-value</span>? m2))</span><br><span class="line">           (<span class="name">set-value!</span> m1</span><br><span class="line">                       (<span class="name">/</span> (<span class="name">get-value</span> product) </span><br><span class="line">                          (<span class="name">get-value</span> m2))</span><br><span class="line">                       me))))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">forget-value!</span> product me)</span><br><span class="line">    (<span class="name">forget-value!</span> m1 me)</span><br><span class="line">    (<span class="name">forget-value!</span> m2 me)</span><br><span class="line">    (<span class="name">process-new-value</span>))</span><br><span class="line">  (<span class="name">define</span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? request 'I-have-a-value)</span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name">eq</span>? request 'I-lost-my-value)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name">else</span></span><br><span class="line">           (<span class="name">error</span> <span class="string">"Unknown request: </span></span><br><span class="line"><span class="string">                   MULTIPLIER"</span> </span><br><span class="line">                  request))))</span><br><span class="line">  (<span class="name">connect</span> m1 me)</span><br><span class="line">  (<span class="name">connect</span> m2 me)</span><br><span class="line">  (<span class="name">connect</span> product me)</span><br><span class="line">  me)</span><br></pre></td></tr></table></figure>
<p>最后，<strong>监视器</strong>在指定连接器被设置或取消值的时候打印出一个消息：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">probe</span> name connector)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">print-probe</span> value)</span><br><span class="line">    (<span class="name">newline</span>) (<span class="name">display</span> <span class="string">"Probe: "</span>)</span><br><span class="line">    (<span class="name">display</span> name) (<span class="name">display</span> <span class="string">" = "</span>)</span><br><span class="line">    (<span class="name">display</span> value))</span><br><span class="line">  (<span class="name">define</span> (<span class="name">process-new-value</span>)</span><br><span class="line">    (<span class="name">print-probe</span> (<span class="name">get-value</span> connector)))</span><br><span class="line">  (<span class="name">define</span> (<span class="name">process-forget-value</span>)</span><br><span class="line">    (<span class="name">print-probe</span> <span class="string">"?"</span>))</span><br><span class="line">  (<span class="name">define</span> (<span class="name">me</span> request)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? request 'I-have-a-value)</span><br><span class="line">           (<span class="name">process-new-value</span>))</span><br><span class="line">          ((<span class="name">eq</span>? request 'I-lost-my-value)</span><br><span class="line">           (<span class="name">process-forget-value</span>))</span><br><span class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request: </span></span><br><span class="line"><span class="string">                        PROBE"</span> request))))</span><br><span class="line">  (<span class="name">connect</span> connector me)</span><br><span class="line">  me)</span><br></pre></td></tr></table></figure>
<h4 id="连接器的表示"><a href="#连接器的表示" class="headerlink" title="连接器的表示"></a>连接器的表示</h4><p>连接器用带有局部状态变量value，informant和constraint的过程对象表示，value中保存这个连接器的当前值，informant是设置连接器值的对象，constraint是这一连接器所涉及的所有约束的表。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-connector</span>)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">value</span> false) </span><br><span class="line">        (<span class="name">informant</span> false) </span><br><span class="line">        (<span class="name">constraints</span> '()))</span><br><span class="line">    <span class="comment">; 当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。</span></span><br><span class="line">    (<span class="name">define</span> (<span class="name">set-my-value</span> newval setter)</span><br><span class="line">      <span class="comment">; 如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束</span></span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">not</span> (<span class="name">has-value</span>? me))</span><br><span class="line">             (<span class="name">set!</span> value newval)</span><br><span class="line">             (<span class="name">set!</span> informant setter)</span><br><span class="line">             <span class="comment">; 而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的那个约束之外</span></span><br><span class="line">             (<span class="name">for-each-except</span> </span><br><span class="line">              setter</span><br><span class="line">              inform-about-value</span><br><span class="line">              constraints))</span><br><span class="line">            ((<span class="name">not</span> (<span class="name">=</span> value newval))</span><br><span class="line">             (<span class="name">error</span> <span class="string">"Contradiction"</span> </span><br><span class="line">                    (<span class="name">list</span> value newval)))</span><br><span class="line">            (<span class="name">else</span> 'ignored)))</span><br><span class="line">       </span><br><span class="line">    <span class="comment">; 当连接器被要求忘记自己的值时，它就会去运行局部过程forget-my-value。</span></span><br><span class="line">    (<span class="name">define</span> (<span class="name">forget-my-value</span> retractor)</span><br><span class="line">      <span class="comment">; 首先检査这一要求是否来自原先设置值的同一个对象</span></span><br><span class="line">      (<span class="name">if</span> (<span class="name">eq</span>? retractor informant)</span><br><span class="line">          (<span class="name">begin</span> (<span class="name">set!</span> informant false)</span><br><span class="line">                 <span class="comment">; 如果情况确实如此，连接器就通知它所参与的所有约束，告知它们自己的值已经没有了。</span></span><br><span class="line">                 (<span class="name">for-each-except</span> </span><br><span class="line">                  retractor</span><br><span class="line">                  inform-about-no-value</span><br><span class="line">                  constraints))</span><br><span class="line">          'ignored))</span><br><span class="line">       </span><br><span class="line">    <span class="comment">; connect向约束表里加入一个新约束（如果它以前不在表里)。如果这个连接器已经有值，它就会将这一事实通知这个新约束。</span></span><br><span class="line">    (<span class="name">define</span> (<span class="name">connect</span> new-constraint)</span><br><span class="line">      (<span class="name">if</span> (<span class="name">not</span> (<span class="name">memq</span> new-constraint </span><br><span class="line">                     constraints))</span><br><span class="line">          (<span class="name">set!</span> constraints</span><br><span class="line">                (<span class="name">cons</span> new-constraint </span><br><span class="line">                      constraints)))</span><br><span class="line">      (<span class="name">if</span> (<span class="name">has-value</span>? me)</span><br><span class="line">          (<span class="name">inform-about-value</span> new-constraint))</span><br><span class="line">      'done)</span><br><span class="line">       </span><br><span class="line">    <span class="comment">; 连接器过程me完成对于内部过程服务的分派工作，它同时也作为这个连接器对象的代表</span></span><br><span class="line">    (<span class="name">define</span> (<span class="name">me</span> request)</span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? request 'has-value?)</span><br><span class="line">             (<span class="name">if</span> informant true false))</span><br><span class="line">            ((<span class="name">eq</span>? request 'value) value)</span><br><span class="line">            ((<span class="name">eq</span>? request 'set-value!) </span><br><span class="line">             set-my-value)</span><br><span class="line">            ((<span class="name">eq</span>? request 'forget) </span><br><span class="line">             forget-my-value)</span><br><span class="line">            ((<span class="name">eq</span>? request 'connect) connect)</span><br><span class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown operation: </span></span><br><span class="line"><span class="string">                          CONNECTOR"</span></span><br><span class="line">                         request))))</span><br><span class="line">    me))</span><br></pre></td></tr></table></figure>
<p>当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束。而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的<br>那个约束之外。这一工作通过下面的迭代过程完成，它将一个指定过程应用于一个表中的所有对象，除了一个给定的例外：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 将一个指定过程应用于一个表中的所有对象</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">for-each-except</span> exception </span><br><span class="line">                         procedure </span><br><span class="line">                         list)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">loop</span> items)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">null</span>? items) 'done)</span><br><span class="line">          ((<span class="name">eq</span>? (<span class="name">car</span> items) exception) </span><br><span class="line">           (<span class="name">loop</span> (<span class="name">cdr</span> items)))</span><br><span class="line">          (<span class="name">else</span> (<span class="name">procedure</span> (<span class="name">car</span> items))</span><br><span class="line">                (<span class="name">loop</span> (<span class="name">cdr</span> items)))))</span><br><span class="line">  (<span class="name">loop</span> list))</span><br></pre></td></tr></table></figure>
<p>下面几个过程为分派提供了一个语法界面：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">has-value</span>? connector)</span><br><span class="line">  (<span class="name">connector</span> 'has-value?))</span><br><span class="line">(<span class="name">define</span> (<span class="name">get-value</span> connector)</span><br><span class="line">  (<span class="name">connector</span> 'value))</span><br><span class="line">(<span class="name">define</span> (<span class="name">set-value!</span> connector </span><br><span class="line">                    new-value </span><br><span class="line">                    informant)</span><br><span class="line">  ((<span class="name">connector</span> 'set-value!) </span><br><span class="line">   new-value </span><br><span class="line">   informant))</span><br><span class="line">(<span class="name">define</span> (<span class="name">forget-value!</span> connector retractor)</span><br><span class="line">  ((<span class="name">connector</span> 'forget) retractor))</span><br><span class="line">(<span class="name">define</span> (<span class="name">connect</span> connector new-constraint)</span><br><span class="line">  ((<span class="name">connector</span> 'connect) new-constraint))</span><br></pre></td></tr></table></figure>
<h2 id="3-4-并发：时间是一个本质问题"><a href="#3-4-并发：时间是一个本质问题" class="headerlink" title="3.4 并发：时间是一个本质问题"></a>3.4 并发：时间是一个本质问题</h2><p>在并发的情况下，由赋值引入的复杂性问题将变得更加严重。</p>
<h3 id="3-4-1-并发系统中时间的性质"><a href="#3-4-1-并发系统中时间的性质" class="headerlink" title="3.4.1 并发系统中时间的性质"></a>3.4.1 并发系统中时间的性质</h3><p>假设由Peter和Paul进行的取款被实现为两个独立的进程，共享同一个变量balance</p>
<p><img src="/.io//pic/TB2lzajiVXXXXcHXXXXXXXXXXXX_!!581166664.png" alt="Peterä¸Paulåæ¶ååä¸ä¸ªè´¦æ·çä¸ç§åºæ¯"></p>
<p><strong>并发程序的正确行为</strong></p>
<ul>
<li>1）对并发地一种可能限制方式是：规定能修改共享状态变量的两个操作都不允许同时发生。（<strong>低效</strong>）</li>
<li>2）另一种不严厉的方式是：保证并发系统产生的结果与各个进程<strong>按照某种方式顺序运行产生出的结果</strong>完全一样。<ul>
<li>2.1）它并没有要求各个进程实际上顺序地运行，而只是要求它们<strong>产生的结果与 <em>假设</em> 它们顺序运行所产生的结果相同</strong>。</li>
<li>2.2）一个并发程序完全可能产生多于一个 “正确的” 结果，因为我们只要求其结果与按照 <em>某种</em> 方式顺序化的结果相同。</li>
</ul>
</li>
</ul>
<p>对于2.2），比如Peter和Paul的共享账户有100，Peter存入40，同时Paul取出账户中钱的一半。则可能产生两种余额，70或90。</p>
<h3 id="3-4-2-控制并发的机制"><a href="#3-4-2-控制并发的机制" class="headerlink" title="3.4.2 控制并发的机制"></a>3.4.2 控制并发的机制</h3><p>在设计并发系统时，设法做出一些一般性的机制，使我们可能<strong>限制并行进程之间的交错情况</strong>，以保证程序具有正确的行为方式。<br>人们已经为此目的而开发了许多不同的机制，我们讨论其中的一种：<strong>串行化组</strong>（serializer）</p>
<p><strong>对共享变量的串行访问</strong></p>
<p><strong>串行化</strong>：使进程可以并发地执行，但是其中也有一些过程不能并发地执行。</p>
<p>Scheme的串行化</p>
<p>通过<strong>串行化组</strong>实现这种限制。构造的方式是调用make-serializer，这一过程的实现将在后面给出。对一个给定串行化组的所有调用返回的串行化过程都属于同一个集合。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</span><br><span class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</span><br><span class="line">               balance)</span><br><span class="line">        <span class="string">"Insufficient funds"</span>))</span><br><span class="line">  </span><br><span class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</span><br><span class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</span><br><span class="line">    balance)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; 关键改动</span></span><br><span class="line">  (<span class="name">let</span> ((<span class="name">protected</span> (<span class="name">make-serializer</span>)))</span><br><span class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</span><br><span class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) (<span class="name">protected</span> withdraw))</span><br><span class="line">            ((<span class="name">eq</span>? m 'deposit) (<span class="name">protected</span> deposit))</span><br><span class="line">            ((<span class="name">eq</span>? m 'balance) deposit)</span><br><span class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></span><br><span class="line">                         m))))</span><br></pre></td></tr></table></figure>
<p><strong>使用多重共享资源的复杂性</strong></p>
<p>如果只存在一个共享资源（如银行账户），串行化的使用问题相对简单。如果存在多项共享资源，并发程序的设计就可能变得非常难以把握了。</p>
<p>比如现在可以交换两个账户的余额。假设Peter和Paul都能访问账户a1, a2, a3。Peter要交换a1和a3，同时Paul要交换a1和a2，虽然对单个账户做了串行化，但交换操作还是可能产生不正确的结果。</p>
<p><strong>串行化的实现</strong></p>
<p>使用<strong>互斥元（mutex）</strong>的同步机制来实现串行化。mutex是一种对象，提供两种操作</p>
<p>1）获取（acquired）</p>
<p>2）释放（released）</p>
<p>一旦一个mutex被获取，对它的任何操作都必须等released之后。</p>
<p>在make-serializer的实现中，关联一个mutex。<strong>给定一个过程p，串行化组先返回一个mutex，再运行p，然后释放mutex，这样就能保证这个串行化组产生的所有过程中，一次只能运行一个p</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">make-serializer</span>)</span><br><span class="line">   (<span class="name">let</span> ((<span class="name">mutex</span> (<span class="name">make-mutex</span>))</span><br><span class="line">         (<span class="name">lambda</span> (<span class="name">p</span>)</span><br><span class="line">           (<span class="name">define</span> (<span class="name">serialized-p</span> . args)</span><br><span class="line">             (<span class="name">mutex</span> 'acquired)</span><br><span class="line">             (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">apply</span> p args)))</span><br><span class="line">               (<span class="name">mutex</span> 'release)</span><br><span class="line">               val))</span><br><span class="line">           serialized-p))))</span><br></pre></td></tr></table></figure>
<p>mutex是一个Boolean，在mutex的构造函数中，初始化为false。</p>
<p>在acquired时，先判断是否为false，若是，设置为true然后使用；否则在循环中等待，直到检测为false。</p>
<p>在acquired操作时，有一个<code>test-and-set!</code>方法，用于检查mutex并返回结果，其中若检查结果为false，在返回false之前还要设置为true。</p>
<p>这里的关键是，<code>test-and-set!</code>必须以原子操作的方式执行。比如说，一旦某进程检查了一个mutex发现是false，就必须在其他进程检查这个mutex之前完成为true的设置，否则mutex的机制就失效了。目前多CPU的电脑中提供了专门指令，直接在硬件中支持原子操作。</p>
<p><strong>死锁</strong></p>
<p>比如Peter要交换a2和a1，则进入了保护a2的串行化进程；Paul同时要交换a1和a2，则进入了保护a1的串行化进程。于是双方都无法继续了。</p>
<p>避免死锁的一种方式，就是首先给每个账户确定一个<strong>唯一的标识编号</strong>，再重写serialized-exchange，使每个进程总是首先去<strong>保护较低编号</strong>的账户。</p>
<p><strong>并发性、时间和通信</strong></p>
<p>我们已经看到，在并发系统的程序设计中，为什么需要去控制不同进程访问共享变量的事件发生的顺序，也看到了如何通过审慎地使用串行化去完成这方面的控制。但是并发性的基本问题比这些更深刻，因为，从一种更基本的观点看，“共享状态”究竟意味着什么，这件事常常并不清楚。</p>
<p>像<code>test-and-set!</code>这样的机制，都要求进程能在任意时刻去检查一个全局性的共享标志。在实现新型高速处理器时，由于在那里需要采用各种优化技术，例如流水线和缓存，因此就不可能在每个时刻都保持存储器内容的一致性，此时完成上述的检查将很有问题，也必然非常低效。正因为这样，在当前的多处理器系统里，串行化方式正在被并发控制的各种新技术取代，比如<strong>屏障同步</strong></p>
<h2 id="3-5-流"><a href="#3-5-流" class="headerlink" title="3.5 流"></a>3.5 流</h2><p>流是另一种模拟现实物理世界的设计策略，其核心思想就是<strong>用数学概念上的函数来表示一现实物体的改变</strong>，比如对象X，可以用<code>X(t)</code>来表示，如果我们想集中关心的是一个个时刻的x，那么就可以将它看作一个变化的量。如果关注的是这些值的整个时间史，那么就不需要强调其中的变化——这一函数本身是没有改变的。</p>
<p>在第二章我们学习了<strong>序列</strong>和<strong>表</strong>的概念（P84）。从抽象的观点看，流也是一个序列，但如果把流表示为表，必能完全揭示流处理的威力。这里要引入一种叫“<strong>延时求值</strong>”的技术。</p>
<h3 id="3-5-1-流作为延时的表"><a href="#3-5-1-流作为延时的表" class="headerlink" title="3.5.1 流作为延时的表"></a>3.5.1 流作为延时的表</h3><p>我们之前建立了一些对序列操作的抽象机制，比如map、filter、accumulate等。但如果我们将序列表示为表，表达可以更优雅，但效率很低。</p>
<p>例如，要计算一个区间内的素数之和。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">null</span>? sequence)</span><br><span class="line">    initial</span><br><span class="line">    (<span class="name">op</span> (<span class="name">car</span> sequence)</span><br><span class="line">        (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">prime</span>? n)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> n next)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">=</span> n next) #t)</span><br><span class="line">          ((<span class="name">=</span> <span class="number">0</span> (<span class="name">remainder</span> n next)) #f)</span><br><span class="line">          (<span class="name">else</span> (<span class="name">iter</span> n (<span class="name">+</span> next <span class="number">1</span>)))))</span><br><span class="line">  (<span class="name">iter</span> n <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</span><br><span class="line">    '()</span><br><span class="line">    (<span class="name">cons</span> low (<span class="name">enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>) high))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">filter</span> predicate sequence)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? sequence) '())</span><br><span class="line">        ((<span class="name">predicate</span> (<span class="name">car</span> sequence))</span><br><span class="line">         (<span class="name">cons</span> (<span class="name">car</span> sequence)</span><br><span class="line">               (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence))))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">iter</span> count accum)</span><br><span class="line">    (<span class="name">cond</span> ((<span class="name">&gt;</span> count b) accum)</span><br><span class="line">          ((<span class="name">prime</span>? count) (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) (<span class="name">+</span> count accum))</span><br><span class="line">          (<span class="name">else</span> (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) accum))))</span><br><span class="line">    (<span class="name">iter</span> a <span class="number">0</span>)))</span><br></pre></td></tr></table></figure>
<p>如果用序列操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</span><br><span class="line">  (<span class="name">accumulate</span> + </span><br><span class="line">              <span class="number">0</span></span><br><span class="line">              (<span class="name">filter</span> prime? (<span class="name">enumerate-interval</span> a b))))</span><br></pre></td></tr></table></figure>
<p>在执行计算时，第一个程序只需要<strong>维护正在累积的和</strong>。第二个程序只有<strong>等enumate-interval构造完成这一区间所有整数的表之后</strong>，过滤器才能开始工作。这就需要大量的中间存储，增加计算开销。</p>
<p>流是一种非常巧妙的想法，使我们<strong>既可以利用各种序列操作，又不会带来将序列作为表操作的性能代价</strong>。</p>
<p>从表面上看，流也是表，但对他们进行操作的过程的名字不同。有构造函数cons-stream，以及两个选择函数stream-car和stream-cdr，满足如下约束</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">stream-car</span> (<span class="name">cons-stream</span> x y))=x</span><br><span class="line">(<span class="name">stream-cdr</span> (<span class="name">cons-stream</span> x y))=y</span><br></pre></td></tr></table></figure>
<p>我们用和第二章各种表操作（如list-ref，map和for-each等）类似的方式来操作流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name">stream-car</span> s)</span><br><span class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc s)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</span><br><span class="line">      the-empty-stream</span><br><span class="line">      (<span class="name">cons-stream</span> </span><br><span class="line">       (<span class="name">proc</span> (<span class="name">stream-car</span> s))</span><br><span class="line">       (<span class="name">stream-map</span> proc (<span class="name">stream-cdr</span> s)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-for-each</span> proc s)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</span><br><span class="line">      'done</span><br><span class="line">      (<span class="name">begin</span> </span><br><span class="line">        (<span class="name">proc</span> (<span class="name">stream-car</span> s))</span><br><span class="line">        (<span class="name">stream-for-each</span> proc </span><br><span class="line">                         (<span class="name">stream-cdr</span> s)))))</span><br></pre></td></tr></table></figure>
<p>核心的诉求是，<strong>对于流的cdr的求值要等到真正通过过程stream-cdr去访问它的时候再做，而不是在构造stream-cdr的时候做</strong>。</p>
<p>流的实现将基于一种称为<strong>delay</strong>的特殊形式，对于<code>(delay &lt;exp&gt;)</code>的求值不是对表达式求值，而是返回一个称为 <strong>延时对象</strong> 的对象。这个对象可以看做是对未来某个时间要对表达式求值的一个允诺。</p>
<p>和delay一起的还有一个<strong>force</strong>的过程，它以一个延时对象为参数，执行相应的求值工作，也就是说，force就用来迫使delay完成所允诺的求值。下面用这两个概念来构造流。</p>
<p>cons-stream的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cons-stream ⟨a⟩ ⟨b⟩)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cons ⟨a⟩ (delay ⟨b⟩))</span><br></pre></td></tr></table></figure>
<p>可见，定义的时候，b还没有放到cons的cdr中。再看对cons的取值，</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) </span><br><span class="line">  (<span class="name">car</span> stream))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) </span><br><span class="line">  (<span class="name">force</span> (<span class="name">cdr</span> stream)))</span><br></pre></td></tr></table></figure>
<p><strong>流实现的行为方式</strong></p>
<p>我们再来看之前的过滤出素数的例子</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">stream-car</span> </span><br><span class="line"> (<span class="name">stream-cdr</span></span><br><span class="line">  (<span class="name">stream-filter</span> </span><br><span class="line">   prime? (<span class="name">stream-enumerate-interval</span> </span><br><span class="line">           <span class="number">10000</span> <span class="number">1000000</span>))))</span><br></pre></td></tr></table></figure>
<p>计算开始于对参数10000 1000000调用stream-enumerate-interval。它的实现是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">stream-enumerate-interval</span> low high)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</span><br><span class="line">      the-empty-stream</span><br><span class="line">      (<span class="name">cons-stream</span></span><br><span class="line">       low</span><br><span class="line">       (<span class="name">stream-enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>)</span><br><span class="line">                                  high))))</span><br></pre></td></tr></table></figure>
<p>这样，由stream-enumerate-interval返回的结果就是通过cons-stream形成的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons</span> <span class="number">10000</span></span><br><span class="line">      (<span class="name">delay</span> </span><br><span class="line">        (<span class="name">stream-enumerate-interval</span> </span><br><span class="line">         <span class="number">10001</span> </span><br><span class="line">         <span class="number">1000000</span>)))</span><br></pre></td></tr></table></figure>
<p>也就是说，当stream-enumerate-interval返回一个流的时候，car是10000，而cdr是一个<strong>允诺</strong>，表示当需要的时候，才在这个区间中枚举更多的内容。</p>
<p>再来看这个流程构建后的过滤</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) </span><br><span class="line">         the-empty-stream)</span><br><span class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</span><br><span class="line">         (<span class="name">cons-stream</span> </span><br><span class="line">          (<span class="name">stream-car</span> stream)</span><br><span class="line">          (<span class="name">stream-filter</span> </span><br><span class="line">           pred</span><br><span class="line">           (<span class="name">stream-cdr</span> stream))))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> </span><br><span class="line">               pred </span><br><span class="line">               (<span class="name">stream-cdr</span> stream)))))</span><br></pre></td></tr></table></figure>
<p>首先检查stream-car，因为这个数不是素数（10000），再进一步检查stream-cdr，这个时候对stream-cdr的调用会迫使系统对延时的stream-enumerate-interval求值，这一次就返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons</span> <span class="number">10001</span></span><br><span class="line">      (<span class="name">delay</span> </span><br><span class="line">        (<span class="name">stream-enumerate-interval</span> </span><br><span class="line">         <span class="number">10002</span> </span><br><span class="line">         <span class="number">1000000</span>)))</span><br></pre></td></tr></table></figure>
<p>如此进行，直到找到第一个素数10007，此时stream-filter根据其定义返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons-stream</span> </span><br><span class="line"> (<span class="name">stream-car</span> stream)</span><br><span class="line"> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">cons</span> <span class="number">10007</span></span><br><span class="line">      (<span class="name">delay</span></span><br><span class="line">        (<span class="name">stream-filter</span></span><br><span class="line">         prime?</span><br><span class="line">         (<span class="name">cons</span> <span class="number">10008</span></span><br><span class="line">               (<span class="name">delay</span></span><br><span class="line">                 (<span class="name">stream-enumerate-interval</span> </span><br><span class="line">                  <span class="number">10009</span> <span class="number">1000000</span>))))))</span><br></pre></td></tr></table></figure>
<p>这样在stream-cdr中，又迫使延时的stream-filter求值，转而再去迫使stream-enumerate-interval求值，直到再找到下一个素数……</p>
<p>一般而言，可以将延时求值看做是一种“由需要驱动”的设计，其中流处理的每个阶段都仅仅活动到足够满足下一阶段的需要。</p>
<p><strong>delay和force的实现</strong></p>
<p>delay必须包装起一个表达式，使其可以在以后根据需要求值。delay实际上也是一个lambda表达式的语法糖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(delay ⟨exp⟩)</span><br><span class="line">=</span><br><span class="line">(lambda () ⟨exp⟩)</span><br></pre></td></tr></table></figure>
<p>而force就是简单调用由delay产生的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(define (force delayed-object)</span><br><span class="line">  (delayed-object))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/congyihao/article/details/60747909" target="_blank" rel="noopener">Java 8 - 通过lambda表达式进行惰性计算</a></p>
<p>lambda表达式的出现使得JDK8内部发生了很多有趣的变化, 其中就包括惰性计算的特性.<br>这里以JDK标准库中的Logger为例, 1.8以前的log方法有如下签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String msg)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span>;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msg);</span><br><span class="line">&gt;         doLog(lr);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>也就是说客户端程序调用log方法的时候, 无论最终是否触发log行为, <code>msg</code>始终是要被计算的. 若计算<code>msg</code>是非常耗时的行为, 那么无疑会造成不必要的开销. 下面是一个调用的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; log(Level.WARNING, <span class="string">"Log msg: "</span> + someExpensiveOperation());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在java 1.8版本出现之后, 该方法多了如下重载:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, Supplier&lt;String&gt; msgSupplier)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span>;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msgSupplier.get());</span><br><span class="line">&gt;         doLog(lr);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><code>Supplier</code>是一个<code>FunctionalInterface</code>, 也就是说现在的<code>log</code>方法可以接受一个无参的lambda表达式作为参数, 而计算的过程也被延迟到了<code>supplier.get()</code>的调用时. 改进后的调用例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 注意: 传入的lambda表达式并不会立即执行, 而是在log中判断isLoggable(level)成功后才会执行</span></span><br><span class="line">&gt; log(Level.WARNING, () -&gt; <span class="string">"Log msg: "</span> + someExpensiveOperation());</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里还存在一个优化。有时需要多次对同一个delay求值，这就需要delay能保存上一次求出的值。于是可以将delay实现为一种特殊的记忆过程，它以一个无参过程为参数，返回该过程的记忆性版本。这种记忆性过程在第一次执行时将结果保存，下一次求值时再返回之前保存的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">memo-proc</span> proc)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">already-run</span>? false) (<span class="name">result</span> false))</span><br><span class="line">    (<span class="name">lambda</span> ()</span><br><span class="line">      (<span class="name">if</span> (<span class="name">not</span> already-run?)</span><br><span class="line">          (<span class="name">begin</span> (<span class="name">set!</span> result (<span class="name">proc</span>))</span><br><span class="line">                 (<span class="name">set!</span> already-run? true)</span><br><span class="line">                 result)</span><br><span class="line">          result))))</span><br></pre></td></tr></table></figure>
<p>此后再定义delay，使得<code>(delay ⟨exp⟩)</code>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(memo-proc (lambda () ⟨exp⟩))</span><br></pre></td></tr></table></figure>
<h3 id="3-5-2-无穷流"><a href="#3-5-2-无穷流" class="headerlink" title="3.5.2 无穷流"></a>3.5.2 无穷流</h3><p>用流表示无穷长的序列。</p>
<p>比如以下的流可以表示所有正整数序列。这是一个无穷长的流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</span><br><span class="line">  (<span class="name">cons-stream</span> </span><br><span class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</span><br><span class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">100</span>)</span><br><span class="line"><span class="number">101</span></span><br></pre></td></tr></table></figure>
<p>用这个就可以表示，例如不能被7整除的整数的流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">divisible</span>? x y) (<span class="name">=</span> (<span class="name">remainder</span> x y) <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> no-sevens</span><br><span class="line">  (<span class="name">stream-filter</span> (<span class="name">lambda</span> (<span class="name">x</span>) </span><br><span class="line">                   (<span class="name">not</span> (<span class="name">divisible</span>? x <span class="number">7</span>)))</span><br><span class="line">                 integers))</span><br></pre></td></tr></table></figure>
<p>之后在用访问这个流元素的方式找出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (stream-ref no-sevens 100)</span><br><span class="line">117</span><br></pre></td></tr></table></figure>
<p>也可以定义斐波那契数列的无穷流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">fibgen</span> a b)</span><br><span class="line">  (<span class="name">cons-stream</span> a (<span class="name">fibgen</span> b (<span class="name">+</span> a b))))</span><br><span class="line">(<span class="name">define</span> fibs (<span class="name">fibgen</span> <span class="number">0</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">6</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>这样定义出的<code>fibs</code>是一个序对，其car是0，cdr是一个求值<code>(fibgen 1 1)</code>的允诺。求该表达式时，又将产生一个序对，car是，cdr是<code>(fibgen 1 2)</code>。</p>
<p><strong>隐式的定义流</strong></p>
<p>上面的integers和fibs是通过描述“生成”过程的方式定义的，这种过程是一个个的计算出流的元素。另一种就是<strong>隐式的求值</strong>。</p>
<p>例如，下面表达式将ones定义为1的一个无穷流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define ones (cons-stream 1 ones))</span><br></pre></td></tr></table></figure>
<p>这种方式就像在定义一个递归过程：这里的ones是一个序对，car是1，cdr是求值ones的一个允诺。而对cdr的求值又得到了一个1和cdr的允诺。</p>
<p>add-streams操作产生出两个给定流的逐对元素之和</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">add-streams</span> s1 s2) </span><br><span class="line">  (<span class="name">stream-map</span> + s1 s2))</span><br></pre></td></tr></table></figure>
<p>现在可以用另一种方式定义整数流integers</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> integers </span><br><span class="line">  (<span class="name">cons-stream</span> <span class="number">1</span> (<span class="name">add-streams</span> ones integers)))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">10</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>首元素是1，其余是ones和integers之和。这样，integers的第二个元素就是1加上integers的第一个元素，也就是2。第三个元素就是1加上integers的第二个元素，也就是3。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 原版integers定义</span></span><br><span class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</span><br><span class="line">  (<span class="name">cons-stream</span> </span><br><span class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</span><br><span class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>同样的风格也可以定义出斐波那契数列</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> fibs </span><br><span class="line">  (<span class="name">cons-stream</span> </span><br><span class="line">   <span class="number">0</span> (<span class="name">cons-stream</span></span><br><span class="line">      <span class="number">1</span> (<span class="name">add-streams</span> </span><br><span class="line">         (<span class="name">stream-cdr</span> fibs) fibs))))</span><br><span class="line"></span><br><span class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">11</span>)</span><br><span class="line"><span class="number">89</span></span><br></pre></td></tr></table></figure>
<p>这个定义是fib是一个从0和1开始的流，而这个流的其余部分都可以通过加起流fibs和移动了一个位置的fibs而得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    1 1 2 3 5  8 13 21 … = (stream-cdr fibs)</span><br><span class="line">    0 1 1 2 3  5  8 13 … = fibs</span><br><span class="line">0 1 1 2 3 5 8 13 21 34 … = fibs</span><br></pre></td></tr></table></figure>
<h3 id="3-5-5-函数式程序的模块化和对象的模块化"><a href="#3-5-5-函数式程序的模块化和对象的模块化" class="headerlink" title="3.5.5 函数式程序的模块化和对象的模块化"></a>3.5.5 函数式程序的模块化和对象的模块化</h3><p>正如在3.1.2中看到的，引进赋值的主要收益就是使我们可以<strong>增强系统的模块化</strong>，把一个大系统的状态中的某些部分封装，或者说<strong>“隐藏”到局部变量里</strong>。</p>
<p>流模型可以<strong>提供等价的模块化，同时又不必使用赋值</strong>。为了展示这方面的情况，我们可以重新实现前面在 3.1.2 节看过的π的蒙特卡罗估计，这次从流的观点出发来做。</p>
<p>这里的一个关键性的模块化问题，就是我们希望<strong>将一个随机数生成器的内部状态隐蔽起来，隔离在使用随机数的程序之外</strong>。从过程 <code>rand-update</code> 开始，它所提供的一系列值就是我们所需的随机数，用它作为一个随机数生成器：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> rand</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</span><br><span class="line">    (<span class="name">lambda</span> ()</span><br><span class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</span><br><span class="line">      x)))</span><br></pre></td></tr></table></figure>
<p>在这个流的描述中，看不到什么随机数生成器。在这里只有一个随机数的流，通过对rand-update的一系列顺序调用产生：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> random-numbers</span><br><span class="line">  (<span class="name">cons-stream</span> random-init</span><br><span class="line">               (<span class="name">stream-map</span> rand-update </span><br><span class="line">                           random-numbers)))</span><br></pre></td></tr></table></figure>
<p>用它构造出在<code>random-numbers</code>流中顺序的数对上的的Cesaro实验的输出流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">map-successive-pairs</span> f s)</span><br><span class="line">  (<span class="name">cons-stream</span></span><br><span class="line">   (<span class="name">f</span> (<span class="name">stream-car</span> s) </span><br><span class="line">      (<span class="name">stream-car</span> (<span class="name">stream-cdr</span> s)))</span><br><span class="line">   (<span class="name">map-successive-pairs</span> </span><br><span class="line">    f (<span class="name">stream-cdr</span> (<span class="name">stream-cdr</span> s)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> cesaro-stream</span><br><span class="line">  (<span class="name">map-successive-pairs</span></span><br><span class="line">   (<span class="name">lambda</span> (<span class="name">r1</span> r2) (<span class="name">=</span> (<span class="name">gcd</span> r1 r2) <span class="number">1</span>))</span><br><span class="line">   random-numbers))</span><br></pre></td></tr></table></figure>
<p>现在将<code>cesaro-stream</code>扔进<code>monte-carlo</code>过程，该过程生成一个可能性估计的流。得到的结果就变换到一个估计π值的流。这一版本的程序<strong>不需要用参数去告诉它试多少次</strong>，只要查看更后面的值，就可以得到更好的π的估计。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> experiment-stream </span><br><span class="line">                     passed </span><br><span class="line">                     failed)</span><br><span class="line">  (<span class="name">define</span> (<span class="name">next</span> passed failed)</span><br><span class="line">    (<span class="name">cons-stream</span></span><br><span class="line">     (<span class="name">/</span> passed (<span class="name">+</span> passed failed))</span><br><span class="line">     (<span class="name">monte-carlo</span></span><br><span class="line">      (<span class="name">stream-cdr</span> experiment-stream) </span><br><span class="line">      passed </span><br><span class="line">      failed)))</span><br><span class="line">  (<span class="name">if</span> (<span class="name">stream-car</span> experiment-stream)</span><br><span class="line">      (<span class="name">next</span> (<span class="name">+</span> passed <span class="number">1</span>) failed)</span><br><span class="line">      (<span class="name">next</span> passed (<span class="name">+</span> failed <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> pi</span><br><span class="line">  (<span class="name">stream-map</span></span><br><span class="line">   (<span class="name">lambda</span> (<span class="name">p</span>) (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> p)))</span><br><span class="line">   (<span class="name">monte-carlo</span> cesaro-stream <span class="number">0</span> <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">&gt; (<span class="name">stream-ref</span> pi <span class="number">1000</span>)</span><br><span class="line"><span class="number">3.24037034920393</span></span><br></pre></td></tr></table></figure>
<p>而且，这一方法也非常模块化，这里<strong>构造了一个一般性的monte-carlo过程，它可以处理任何试验，而且这里没有赋值，也没有局部状态</strong>。</p>
<p>附：流执行的预先定义函数</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; stream-&gt;list</span></span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> stream-&gt;list</span><br><span class="line">  (<span class="name">lambda</span> (<span class="name">strm</span> n)</span><br><span class="line">    (<span class="name">if</span> (<span class="name">or</span> (<span class="name">stream-null</span>? strm) (<span class="name">zero</span>? n))</span><br><span class="line">        '()</span><br><span class="line">        (<span class="name">cons</span> (<span class="name">stream-car</span> strm)</span><br><span class="line">              (<span class="name">stream-&gt;list</span> (<span class="name">stream-cdr</span> strm) (<span class="name">sub1</span> n))))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">define-syntax</span> delay</span><br><span class="line">  (<span class="name">syntax-rules</span> ()</span><br><span class="line">    ((<span class="name">_</span> exp) (<span class="name">lambda</span> () exp))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">force</span> delayed-object)</span><br><span class="line">  (<span class="name">delayed-object</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">define-syntax</span> cons-stream</span><br><span class="line">  (<span class="name">syntax-rules</span> ()</span><br><span class="line">    ((<span class="name">_</span> a b) (<span class="name">cons</span> a (<span class="name">delay</span> b)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) (<span class="name">car</span> stream))</span><br><span class="line"> </span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) (<span class="name">force</span> (<span class="name">cdr</span> stream)))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-null</span>? stream)</span><br><span class="line">  (<span class="name">null</span>? stream))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> the-empty-stream '())</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</span><br><span class="line">      (<span class="name">stream-car</span> s)</span><br><span class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc . argstreams)</span><br><span class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? (<span class="name">car</span> argstreams))</span><br><span class="line">      the-empty-stream</span><br><span class="line">      (<span class="name">cons-stream</span></span><br><span class="line">       (<span class="name">apply</span> proc (<span class="name">map</span> stream-car argstreams))</span><br><span class="line">       (<span class="name">apply</span> stream-map</span><br><span class="line">              (<span class="name">cons</span> proc</span><br><span class="line">                    (<span class="name">map</span> stream-cdr</span><br><span class="line">                         argstreams))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) the-empty-stream)</span><br><span class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</span><br><span class="line">         (<span class="name">cons-stream</span> (<span class="name">stream-car</span> stream)</span><br><span class="line">                      (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream))))</span><br><span class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))))</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liujiacai.net/blog/2015/12/26/sicp-chapter3-summary/" target="_blank" rel="noopener">SICP 第三章总结</a></p>
<p><a href="https://github.com/rsy56640/daily_learning/tree/master/SICP#3" target="_blank" rel="noopener">SICP note</a></p>
<p><a href="https://sicp.liujiacai.net/chap3/exercise.html" target="_blank" rel="noopener">第三章习题索引</a></p>
<p><a href="https://sarabander.github.io/sicp/html/3_002e5.xhtml" target="_blank" rel="noopener">第三章英文版</a></p>
<p><a href="https://wizardforcel.gitbooks.io/sicp-py/content/" target="_blank" rel="noopener">SICP Python 描述 中文版</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/机器学习笔记-最大熵/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/机器学习笔记-最大熵/" class="post-title-link" itemprop="url">机器学习笔记-最大熵</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/机器学习笔记-最大熵/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/机器学习笔记-最大熵/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、最大熵原理"><a href="#1、最大熵原理" class="headerlink" title="1、最大熵原理"></a>1、最大熵原理</h1><p>日常生活中，很多事情的发生表现出一定的随机性，试验的结果往往是不确定的，也不知道这个随机现象所服从的概率分布。<strong>最大熵的实质</strong>就是，在已知部分知识的前提下，关于未知分布最合理的推断就是符合已知知识最不确定或者最随机的推断。任何其他的选择都意味着我们增加了其他的约束和假设。</p>
<p>将最大熵应用到分类，就是最大熵模型。给定一个训练集：</p>
<script type="math/tex; mode=display">
T = \{  (x_1,y_1),  (x_2,y_2),..., (x_N,y_N)\}</script><p>其中$x_i \in X$是输入，$y_i \in Y$是输出，X和Y表示输入和输出空间。N为样本数。<strong>目标是</strong>，利用最大熵原理选出一个最好的分类模型，即对于任意给定的输入$x \in X$，可以以概率$p(y|x)$输出$y \in Y$ 。</p>
<p>按照最大熵原理，应该<strong>优先保证模型满足已知的所有约束</strong>。思路是，从训练数据T中抽取若干有用的特征，要求这些特征在T上关于经验分布$\tilde{p}(x,y)$的数学期望与它们在模型中关于$p(x,y)$的数学期望相等。这样，一个特征就是一个约束了。</p>
<p>这里就涉及到，<strong>特征如何刻画？经验分布如何表示？</strong></p>
<h1 id="2、特征函数"><a href="#2、特征函数" class="headerlink" title="2、特征函数"></a>2、特征函数</h1><p>假设通过特征选择，抽取若干特征。特征通常由特征函数来表示。例如</p>
<script type="math/tex; mode=display">
f(x,y) =\left\{\begin{matrix}
\begin{aligned}
& 1，若x,y满足某个事实 \\ 
& 0，否则
\end{aligned}
\end{matrix}\right.</script><p>这里的特征不是指输入的某个特征，而是指输入和输出共同的特征。</p>
<blockquote>
<p>例如，假设我们需要判断“打”是动词还是量词，已知的训练数据有</p>
<p>(x1,y1)=(一打火柴，量词);</p>
<p>(x2,y2)=(三打啤酒，量词);</p>
<p>(x3,y3)=(打电话，动词);</p>
<p>(x4,y4)=(打篮球，动词);</p>
<p>通过观察，发现“打”前面是数字时，是量词，“打”后面是名词时，是动词。这就是从训练数据中提取的两个特征，可分别用特征函数表示为</p>
</blockquote>
<h1 id="3、经验分布"><a href="#3、经验分布" class="headerlink" title="3、经验分布"></a>3、经验分布</h1><p>经验（概率）分布就是通过对训练集T进行统计得到的分布，用$\tilde p$表示。这里列举两个经验分布</p>
<script type="math/tex; mode=display">
\tilde p(x,y) = \frac {count(x,y)} {N} , \tilde p(x)=\frac {count(x)} {N}</script><p>其中，count表示出现的次数。</p>
<h1 id="4、约束条件"><a href="#4、约束条件" class="headerlink" title="4、约束条件"></a>4、约束条件</h1><p>对于任意一个特征函数f，$E<em>{\tilde p}f$ 表示f在训练数据T上关于$\tilde p(x,y)$的数学期望， $E</em>{p}f$ 表示f在训练数据T上关于$p(x,y)$的数学期望。按照期望的定义，我们有</p>
<script type="math/tex; mode=display">
E_{\tilde p}f=\sum_{x,y}\tilde p(x,y)f(x,y)</script><script type="math/tex; mode=display">
E_{ p}f=\sum_{x,y} p(x,y)f(x,y)</script><p>其中，p(x,y)是未知的，而建模的目标是生成$p(y|x)$，因此，根据Bayes定理，$p(x,y)=p(x)p(y|x)$。在样本数量足够的条件下，$p(x)$可以用$\tilde p(x)$近似表示。这样</p>
<script type="math/tex; mode=display">
E_{ p}f=\sum_{x,y} \tilde p(x)p(y|x)f(x,y)</script><p>对于概率分布$p(y|x)$，我们希望特征f的期望值应该和从训练集中得到的特征期望值是一致的，因此，<strong>增加约束</strong></p>
<script type="math/tex; mode=display">
E_{ p}f=E_{\tilde p}f</script><p>假设我们从训练集中抽取了n个特征，相应的，便有n个特征函数$f_i(i=1,2,…,n)$以及n个约束条件</p>
<script type="math/tex; mode=display">
C_i:E_{ p}(f_i)=E_{\tilde p}(f_i) \tag {3-1}</script><blockquote>
<p>关于约束条件的几何解释</p>
<p><img src="/.io//最大熵1.png" alt="最大熵1"></p>
<p>（a）：P是所有可能的概率空间，此时没有约束条件，所有的概率模型$p(y|x)$都是允许的；</p>
<p>（b）：增加了一个线性约束条件$C_1$，此时，目标分布$p(y|x)$只能落在由$C_1$定义的线段上；</p>
<p>（c）：在（b）的基础上增加了另一个约束条件$C_2$ ，且$C_1 \cap C_2  \neq \varnothing$。此时，目标分布只能落在交点上，即被唯一确定；</p>
<p>（d）：在（b）基础上增加了另一个约束$C_3$，且$C_1 \cap C_2  = \varnothing$，此时不存在能够同时满足$C_1$和$C_3$的$p(y|x)$。</p>
</blockquote>
<p>利用（3-1）定义的约束条件，我们定义P的一个子空间</p>
<script type="math/tex; mode=display">
C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><h1 id="5、最大熵模型"><a href="#5、最大熵模型" class="headerlink" title="5、最大熵模型"></a>5、最大熵模型</h1><p>由于我们的目标是获得一个条件分布，因此这里也采用相应的条件熵</p>
<script type="math/tex; mode=display">
H(p(y|x))=-\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)</script><p>可以看出这里也是用$\tilde p(x)$来近似$p(x)$。以下将$H(p(y|x))$简记为$H(p)$。至此，可以给出最大熵模型的完整描述。</p>
<p>对于给定的训练集T，特征函数$f_i(x,y), i=1,2,…n$，最大熵模型就是求解</p>
<script type="math/tex; mode=display">
\underset {p \in C} {max} \ \  H(p) = \begin{pmatrix}
-\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)
\end{pmatrix}, \\
s.t. \sum_y p(y|x)=1 \tag {5-1} \\
s.t. \ C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><p>其中的s.t.是为了保证$p(y|x)$是一个（合法的）条件概率分布。</p>
<p>等价于一个求极小值问题</p>
<script type="math/tex; mode=display">
\underset {p \in C} {min} \ \  -H(p) = \begin{pmatrix}
\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)
\end{pmatrix}, \\
s.t. \sum_y p(y|x)=1 \tag {5-2} \\
s.t. \ C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><h1 id="6、模型求解"><a href="#6、模型求解" class="headerlink" title="6、模型求解"></a>6、模型求解</h1><p>对于5-1的求解，主要思路和步骤如下：</p>
<ol>
<li>利用Lagrange乘子将最大熵模型由一个带约束的最优化问题转为无约束的最优化问题，这是一个<strong>极小极大问题（min max）</strong>。</li>
<li>利用对偶问题等价性，转化为求解上一步得到的极大/极小问题的对偶问题，也是一个极大极小问题。</li>
</ol>
<h2 id="6-1-原始问题和对偶问题"><a href="#6-1-原始问题和对偶问题" class="headerlink" title="6.1 原始问题和对偶问题"></a>6.1 原始问题和对偶问题</h2><p>根据（5-2），引入拉格朗日乘子$\lambda=(\lambda_0,\lambda_1,…,\lambda_n)^T$，定义拉格朗日函数</p>
<script type="math/tex; mode=display">
L(p,\lambda) = -H(p) + \lambda_0(1-\sum_y p(y|x))+\sum_{i=1}^n\lambda_i(\tau_i-E_p(f_i))  \tag{6-1}</script><p>利用对偶性，求解（6-1）的<strong>原始问题</strong>表示为：</p>
<script type="math/tex; mode=display">
\underset {p \in C} {min}\  \underset {\lambda} {max}\ L(p,\lambda) \tag{6-2}</script><p><strong>对偶问题</strong>为：</p>
<script type="math/tex; mode=display">
\underset {\lambda} {max}\ \underset {p \in C} {min}\  L(p,\lambda) \tag{6-3}</script><p>由于$H(p)$是关于p的凸函数，因此要求解最大熵模型，只需求解对偶问题（6-3）即可。</p>
<h3 id="6-1-1-指数形式的解"><a href="#6-1-1-指数形式的解" class="headerlink" title="6.1.1 指数形式的解"></a>6.1.1 指数形式的解</h3><p>首先求解内部的极小问题。由于$\underset {p \in C} {min}\  L(p,\lambda)$是关于$\lambda$的函数，将其记做：</p>
<script type="math/tex; mode=display">
\Psi (\lambda) =\underset {p \in C} {min}\  L(p,\lambda) = L(p_{\lambda}, \lambda) \tag {6-4}</script><p>其中</p>
<script type="math/tex; mode=display">
p_{\lambda}=\underset {p \in C} {argmin}\ L(p,\lambda)=p_{\lambda}(y|x) \tag {6-5}</script><p>根据拉格朗日乘子法，求$L(p,\lambda)$对$p(y|x)$的偏导，得（求解过程略）：</p>
<script type="math/tex; mode=display">
p_{\lambda}=\frac {1} {Z_{\lambda}(x)} \ \exp(\sum_{i=1}^n \lambda_i f_i(x,y)) \tag{6-6}</script><p>其中，</p>
<script type="math/tex; mode=display">
Z_{\lambda}(x)=\sum_y \exp(\sum_{i=1}^n \lambda_i f_i(x,y)) \tag{6-7}</script><p>称为<strong>规范化因子</strong>（normalizing factor）。注意，此时已经没有$\lambda_0$了。</p>
<p>由（6-6）定义的$p_{\lambda}$就是最大熵模型的解，它具有<strong>指数形式</strong>。其中，$\lambda_i$就是特征$f_i$的权重，越大表示特征越重要。</p>
<h3 id="6-1-2-最大似然估计"><a href="#6-1-2-最大似然估计" class="headerlink" title="6.1.2 最大似然估计"></a>6.1.2 最大似然估计</h3><p>得到对偶问题的内层极小值问题的解之后，接着求解外层的极大值问题$\underset {\lambda} {max} \ \Psi(\lambda)$。</p>
<p>设其解为</p>
<script type="math/tex; mode=display">
\lambda^* = \underset {\lambda} {argmax} \ \Psi(\lambda) \tag{6-8}</script><p>则最大熵模型的解为</p>
<script type="math/tex; mode=display">
p^*=p_{\lambda^*} \tag{6-9}</script><p>根据推导，最大化$\Psi(\lambda)$与最大似然估计是等价的！</p>
<h1 id="7、最优化方法"><a href="#7、最优化方法" class="headerlink" title="7、最优化方法"></a>7、最优化方法</h1><p>通用的方法有梯度下降，拟牛顿法等，最大熵模型有两个量身定做的方法：通用迭代尺度法（Generalized Iterative Scaling，GIS）和改进的迭代尺度法（Impoved Iterative Scaling，IIS）。</p>
<h2 id="7-1-GIS算法"><a href="#7-1-GIS算法" class="headerlink" title="7.1 GIS算法"></a>7.1 GIS算法</h2><blockquote>
<p>算法1：</p>
<p>S1：初始化参数，令$\lambda=0$</p>
<p>S2：计算$E_{\tilde p}(f_i),\ i=1,2,…,n$</p>
<p>S3：执行一次迭代，对参数做一次刷新。</p>
<p>​    计算$E<em>{p</em>{\lambda}}(f_i)$</p>
<p>​    FOR i=1,2,…,n DO {</p>
<p>​        $\lambda<em>i\  += \ \eta \log\frac {E</em>{\tilde p}(f<em>i)} {E</em>{p_{\lambda}}(f_i)}$</p>
<p>​    }</p>
<p>S4：检查是否收敛，若未收敛则继续S3</p>
</blockquote>
<p>其中，$\eta$是学习率，在实际中取$\frac {1} {C}$，$$，表示训练数据中包含特征最多的那个样本所包含的特征个数。</p>
<script type="math/tex; mode=display">
\Delta\lambda_i=\eta \log\frac {E_{\tilde p}(f_i)} {E_{p_{\lambda}}(f_i)}</script><p>是校正量。</p>
<p>每次迭代，先用当前的权重估算每个特征$f<em>i$在训练数据中的概率分布的期望，然后逐个与相应的经验分布的期望比较，其偏差程度通过$\log\frac {E</em>{\tilde p}(f<em>i)} {E</em>{p_{\lambda}}(f_i)}$来进行刻画。</p>
<p>收敛条件就是当两次迭代的$\lambda$在一个较小的范围。</p>
<p>GIS每次迭代时间很长，不太稳定，容易溢出，一般不会使用。</p>
<h2 id="7-2-IIS算法"><a href="#7-2-IIS算法" class="headerlink" title="7.2 IIS算法"></a>7.2 IIS算法</h2><p>与GIS的不同主要在$\Delta\lambda_i$的计算上。IIS通过求解方程</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde p(x)p(y|x)f_i(x,y)\exp(\Delta\lambda_i\sum_{i=1}^nf_i(x,y))=\tilde p(f_i)</script><p>1）若$\sum<em>{i=1}^nf_i(x,y)$为常数，即对任意样本(x,y)，都有$\sum</em>{i=1}^nf_i(x,y)=C$，则</p>
<script type="math/tex; mode=display">
\Delta\lambda_i=\frac {1} {C} \log\frac {E_{\tilde p}(f_i)} {E_{p_{\lambda}}(f_i)}</script><p>此时，IIS可以看做是GIS的一种推广。</p>
<p>2）若$\sum_{i=1}^nf_i(x,y)$不是常数，则需要通过数值方式来求解$\Delta\lambda_i$，如牛顿法。</p>
<h1 id="8、优缺点"><a href="#8、优缺点" class="headerlink" title="8、优缺点"></a>8、优缺点</h1><p>优点是：在建模时，只需要集中精力选取特征，不需要花费精力考虑如何使用这些特征，可以灵活使用不同类型的特征。</p>
<p>缺点是计算量大。</p>
<p>参考</p>
<p>【1】 <a href="http://blog.csdn.net/itplus/article/details/26550273" target="_blank" rel="noopener">最大熵学习笔记</a></p>
<p>【2】统计学习方法</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/计算广告/广告反作弊/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer">
      <meta itemprop="description" content="Record and Think!">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/计算广告/广告反作弊/" class="post-title-link" itemprop="url">广告反作弊</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/计算广告/" itemprop="url" rel="index"><span itemprop="name">计算广告</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/计算广告/广告反作弊/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/计算广告/广告反作弊/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>秒针发布过《互联网广告反作弊技术白皮书》</p>
<p>腾讯灯塔联手秒针、AdMaster发布</p>
<h1 id="腾讯《2017广告反欺诈白皮书》"><a href="#腾讯《2017广告反欺诈白皮书》" class="headerlink" title="腾讯《2017广告反欺诈白皮书》"></a>腾讯《2017广告反欺诈白皮书》</h1><p>日均校验40亿广告请求，识别的作弊比率在15%左右。部分行业和campaign中，作弊率有60%。</p>
<h2 id="欺诈手段"><a href="#欺诈手段" class="headerlink" title="欺诈手段"></a>欺诈手段</h2><ul>
<li>虚假流量。</li>
</ul>
<p>某APP在地推时，新增用户暴涨。95%的新增用户的共同特征：</p>
<p><strong>ROM编译机名称一致；指令逃逸差异数与正常用户不一致；CPU结构为X86，为PC机模拟器；文件系统类型的差异度与正常用户不一致</strong>。</p>
<p>某APP的新增用户中，工作室批量刷量的特征有：</p>
<p><strong>安装时间具有明显的规律；手机APP安装数量一致；明显的地域集中性</strong>。</p>
<p>2.2 黑产技术</p>
<p>1、广告作弊类型分类</p>
<p>1）模拟器刷量：电脑模拟器刷量、手机软件模拟刷量、脚本刷量（录制行为跑循环任务）。</p>
<p>2）真假机用户：储备大量手机或者sim卡，利用数据线push命令到手机，手机执行命令。</p>
<p>3）静默安装（真机真用户假行为）。人工方式或网络传播方式将木马/具有再分发能力的应用植入到用户手机，形成僵尸网络，在用户无感知的情况下，完成App的下载、激活和删除等一系列操作。</p>
<p>4）羊毛党（真机真用户真行为假动机）：登录一次就删除应用、使用时长极短、留存率极低。在大部份的情况下，这种用户对业务的健康发展并无太大价值。</p>
<p>5）广告素材、篇幅偷换（不可见）。“1 像素广告”指在用户的手机屏幕上只展示1个像素大小的广告。这种广告，用户看不见，但统计工具可以统计到，仍然会作为曝光广告与广告主结算，给广告主带来经济损失。</p>
<p>6）以次充好（不匹配）。部分媒体会将广告主原本定向的一线城市用户偷偷换成二三线城市用户，达到以次充好的目的。</p>
<h2 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h2><p>2.3 反作弊技术</p>
<p>1）用户群体数据检测。低阶技术，常见方式有：</p>
<p><strong>a.看留存率</strong>。真实的用户的留存曲线是一条平滑的指数衰减曲线，如果发现留存曲线存在陡升陡降的异常波动，则判断刷量者干预了数据。</p>
<p><strong>b.看用户终端、网络信息</strong>。如根据经验分析渠道新增用户或者启动用户的设备排名;2G、3G、4G的使用比例分布是否正常等。</p>
<p><strong>c.看用户注册信息</strong>。比如说注册昵称的分布和规律等。</p>
<p>以上操作均效率低下。</p>
<p>2）用户行为特征分析</p>
<p><strong>a.单个指标</strong>。与黑IP库进行比对，是否为黑名单IP、是否为代理IP;与IMEI库进行对比，是否为为黑IMEI;</p>
<p><strong>b.群体指标</strong>。用户的IP、IMEI、机型、OS、位置信息、运营商、接入方式的<strong>分布</strong>是否符合先验数据的分布</p>
<p><strong>c.设备一致性验证</strong>。CPU、制造商、MAC地址、IMEI、机型、操作系统的一致性验证。</p>
<p>简单粗暴，没有黑白转换机制，误判率高。</p>
<p><strong>这些方法容易被刷量者利用</strong>。在某电商专业Android app游戏激活、注册、留存、付费、应用市场好评平台上，买主只需要很小的代价，即可刷出完全符合正常用户规律的留存率、IP分布机型分布使用时长等。</p>
<p>3）终端特征分析+云端交叉验证</p>
<p>“查”模型负责找寻黑产界的新型作弊方式，提升整体模型的覆盖率</p>
<p>“杀”模型负责准确识别恶意份子</p>
<p>“验”模型通过多业务交叉验证，负责保证“查”、“杀”模型的准确率</p>
<p><strong>终端识别模块</strong>（灯塔SDK稽核模块）:该模块主要是采用机器学习算法选取系统中所有可用的信息作为特征，然后对这些特征进行运算得到该<strong>设备的指纹，</strong>可以有效识别手机模拟器、修改系统参数等行为。</p>
<p><strong>基于规则的识别模块</strong>（业务自有模块）:该模块一般是通过业务经验及对历史可疑渠道的总结形成的<strong>反作弊规则</strong>，可以理解为多维组合规则，一般需根据业务成本、对渠道的容忍度<strong>设置关键变量的阈值</strong>。</p>
<p><strong>基于数据挖掘的识别模块</strong>（灯塔云端模块）:该模块主要从硬件信息、用户活跃、用户行为进行多维度、多业务交叉验证，分别计算每个维度下面的不同特征值，结合决策树、LR、贝叶斯网络等多种算法进行精准的定位。<strong>分类</strong></p>
<p>为了增强识别的准确性和稳定性，模块之间、模块内部均采用集成学习方法的思想，其核心思想是在模块内对同一个训练集训练不同的分类器，然后把这些分类器结合起来构成一个最终的分类器，而每一个模块可以针对不同的作弊手段进行识别，再把模块与模块结合，才能识别所有的作弊手段。    </p>
<h1 id="admaster《广告反欺诈研究报告》2016"><a href="#admaster《广告反欺诈研究报告》2016" class="headerlink" title="admaster《广告反欺诈研究报告》2016"></a>admaster《广告反欺诈研究报告》2016</h1><p>今年 1 月 29 日和 3 月 2 日,宝洁公司首席品牌官 Marc Pritchard 分别在美国互动广告局(Interactive<br>Advertising Bureau, IAB)和美国广告主协会(Association of National Advertisers, ANA)两个年度<br>重要峰会上进行主题发言,针对数字广告透明度和可见性标准的言论引发了全球营销圈和数字行业的热议。<br>宝洁呼吁业界在四个方面采取行动:</p>
<ol>
<li>数字广告采纳一套统一的可见性测量标准;</li>
<li>贯彻第三方测评机构</li>
</ol>
<p>的验证审核;</p>
<ol>
<li>提倡全面透明的代理公司合同机制;</li>
<li>预防广告欺诈。</li>
</ol>
<p>AdMaster先后推出了 BlueAir、定投识别 (VOA)、监播实录 (SNAP) 等技术产品,逐步建立了“全方位、深层次、多角度”的广告反欺诈解决方案。尤其在程序化购买中,AdMaster 在投放前预判 (Pre-bid),即事前广告反欺诈技术。</p>
<p><strong>BlueAir</strong>可以对智能电视IP、地域、频次以及User Agent等维度的异常流量进行甄别，将行为逻辑上不正常的设备加入黑名单，从而保障广告投放的安全。同时，与海信、康佳、创维、欢网等硬件厂家共同建立智能电视设备白名单，以便从设备维度进一步甄别流量真实性。</p>
<p><strong>定投识别</strong></p>
<p><strong>监播实录</strong></p>
<p><strong>投放前预判</strong>。在流量请求、广告未展现时,根据历史流量质量进行排查,从而提前避免广告在无效流量上的投放。</p>
<h2 id="无效流量类型"><a href="#无效流量类型" class="headerlink" title="无效流量类型"></a>无效流量类型</h2><p>1、广告可见性问题引发的低质量流量</p>
<p>目前媒体的环境导致广告不易可见。AdMaster 在 AdServing 广告投放管理技术上能够实现广告可见性的预估判断。在多种广告形式的后测方面,通过独创的模型评估广告可见性表现。</p>
<p>2、机器人无效流量（Non-Human Traffic）</p>
<p>从最初的 cookie 和 IP不变的前提下,反复刷新页面和点击广告,造成广告曝光和点击的增加,到通过木马或者恶意程序控制海量人肉刷机、伪造大量 IP 与设备信息进行模拟访问、或将 IP 和 cookie、User Agent 一起进行轮替的流量造假方式,都属于机器人无效流量。</p>
<p><strong>BlueAir</strong> 广告反欺诈技术能够结合历史异常数据,能够在流量请求、广告未展现时,即根据历史流量质量判断此流量的质量,在投放前通过 <strong>Pre-bid</strong> 判断出流量的异常,杜绝流量造假现象发生。</p>
<p>3、视频类无效流量</p>
<p>(1)针对剧目投偏现象,AdMaster <strong>定投识别</strong> (VOA) 功能通过 Referrer/ 剧目 ID 等方式解析 广告曝光时所<br><strong>播放剧目名称</strong>,并与广告主定投的剧目内容进行匹配。在移动端定投评估中,高诚信度的视频媒体也提供高度<br>配合。剧目投偏比例,一目了然。</p>
<p>(2)针对时有发生的曝光代码调用,但是素材未正确展示的广告欺诈现象,AdMaster 利用<strong>监播实录</strong> (SNAP)<br>功能,采用类似于“神秘访客”概念的方法从海量抽样监测,将视频内容播放前的所有贴片内容录制下来,并<br>通过图像识别与适当的素材进行对比,判断素材是否被正确展示,以及是否按照要求展示。</p>
<p>4、智能电视无效流量</p>
<p>支持智能电视广告的监测模式一般有 3 种 : 分别是第三方 SDK 监测、C2S 和 S2S 两种 API。前两种相比 S2S 更为安全,也更容易监测流量异常情况,可以说 C2S API 是智能电视广告监测安全的起点和基础(S2S API 传输方式目前很难识别无效流量)。</p>
<h1 id="inmobi《移动广告反作弊白皮书》"><a href="#inmobi《移动广告反作弊白皮书》" class="headerlink" title="inmobi《移动广告反作弊白皮书》"></a>inmobi《移动广告反作弊白皮书》</h1><p>没技术</p>
<p>反作弊措施</p>
<p>1）剔除自动流量。</p>
<p>识别机器人脚本，分析展示和点击的质量。</p>
<p>2）数据信号双重检测。</p>
<p>将媒体共享的人群信息和从SDK收集的信息比对，对所有无效信息定位和删除。</p>
<p>[部分有关 广告联盟作弊 与反作弊资料收集]（<a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=4882639）" target="_blank" rel="noopener">http://cwiki.apachecn.org/pages/viewpage.action?pageId=4882639）</a></p>
<p>roadmap中，AD fraud的业界措施</p>
<p>监控广告投放的效果；</p>
<p>保存曝光设备的ip</p>
<p>记录用户在landing页的行为</p>
<p>网页分析</p>
<p><strong>基于数据挖掘的识别模块</strong>（灯塔云端模块）:该模块主要从硬件信息、用户活跃、用户行为进行多维度、多业务交叉验证，分别计算每个维度下面的不同特征值，结合决策树、LR、贝叶斯网络等多种算法进行精准的定位。为了增强识别的准确性和稳定性，模块之间、模块内部均采用集成学习方法的思想，其核心思想是在模块内对同一个训练集训练不同的分类器，然后把这些分类器结合起来构成一个最终的分类器，而每一个模块可以针对不同的作弊手段进行识别，再把模块与模块结合，才能识别所有的作弊手段。</p>
<p>这个方法未来肯定要实现的，大致是通过集成学习的方式，综合硬件信息，网页特征，用户行为</p>
<p>最初我们只有url信息，提取url的特征判断投放的网页是否安全；</p>
<p>后面对每条</p>
<p>前期，通过分析url内容，判断网页是否安全，是否为虚假网页，网页内容与广告品牌是否有冲突。</p>
<p>后面，分析曝光的详细信息，包括设备信息，用户特征，判断是否为作弊流量；分析网页元素和广告位置，判断广告可见性。</p>
<p>再后面，在对url和黑名单有一定积累的基础上，在投放或竞价前检测投放环境，主动识别和屏蔽非安全流量</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/29/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Schwimmer</p>
              <div class="site-description motion-element" itemprop="description">Record and Think!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">313</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Schwimmer</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.2.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  
  
<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-schwimmer-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>







  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
