<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Record and Think!">
<meta property="og:type" content="website">
<meta property="og:title" content="Schwimmer&#39;s Blog">
<meta property="og:url" content="https://schwimmer.github.io/page/28/index.html">
<meta property="og:site_name" content="Schwimmer&#39;s Blog">
<meta property="og:description" content="Record and Think!">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Schwimmer&#39;s Blog">
<meta name="twitter:description" content="Record and Think!">





  
  
  <link rel="canonical" href="https://schwimmer.github.io/page/28/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Schwimmer's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Schwimmer's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>Schlagwörter</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>Kategorien</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>Archiv</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习和深度学习算法理论/CNN/CNN/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习和深度学习算法理论/CNN/CNN/" class="post-title-link" itemprop="url">CNN</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-16 09:28:37" itemprop="dateModified" datetime="2019-06-16T09:28:37+08:00">2019-06-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/深度学习/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h1><p>也称为滤波器。</p>
<p>权重共享：卷积核的权重（矩阵的值）对于不同位置的所有输入都是相同的。</p>
<h2 id="卷积操作的意义"><a href="#卷积操作的意义" class="headerlink" title="卷积操作的意义"></a>卷积操作的意义</h2><p>例如，有整体边缘滤波器Ke，横向边缘滤波器Kh，纵向边缘滤波器Kv。</p>
<script type="math/tex; mode=display">
K_e=\begin{bmatrix}
0 & -4 & 0\\ 
-4 & 16 & -4\\ 
0 & -4 & 0
\end{bmatrix}\ \ K_h=\begin{bmatrix}
1 & 2 & 1\\ 
0 & 0 & 0\\ 
-1 & -2 & -1
\end{bmatrix}\ \ K_v=\begin{bmatrix}
1 & 0 & -1\\ 
2 & 0 & -2\\ 
1 & 0 & -1
\end{bmatrix}</script><p>若某像素位于物体边缘，则周边像素与该像素会有明显差异，用Ke可以放大边缘和周边的差异，起到边缘检测的作用。同理，Kh、Kv可以保留横向、纵向的边缘信息。</p>
<h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><p>也叫汇合层。通常操作有平均值池化（average-pooling）和最大值汇合（max-pooling）。与卷积核操作不同，池化层不包含需要学习的参数。仅指定汇合类型，核大小（kernel size）和步长（stride）。</p>
<p>汇合的结果相对输入降小了，是一种降采样（down-sampling）操作。也可以看成是一个用p范数（p-norm）作为非线性映射的卷积操作。当p趋于正无穷时就是最大值汇合。</p>
<p>汇合层的引入是仿照人的视觉系统对视觉输入对象进行降维和抽象。作用有：</p>
<p>1）特征不变性（feature invariant）。使模型更关注是否存在某些特征而不是特征具体的位置。</p>
<p>2）特征降维。</p>
<p>3）一定程度上防止过拟合。</p>
<h1 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h1><p>fully connected layers</p>
<p>参考：</p>
<p>【1】解析卷积神经网络.pdf</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/算法与数据结构/查找树/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/算法与数据结构/查找树/" class="post-title-link" itemprop="url">查找树</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2017-07-16 12:44:24" itemprop="dateModified" datetime="2017-07-16T12:44:24+08:00">2017-07-16</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法与数据结构/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树 (Red-Black Tree )，B-tree/B+-tree/ B*-tree (B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度*</strong>O<em>(log2</em>N<em>)<em>*与树的深度相关，那么降低树的深度自然对查找效率是有所提高的；还有一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</em></em></p>
<p><strong>这样我们就提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构，也就是B树</strong></p>
<h1 id="1、B树"><a href="#1、B树" class="headerlink" title="1、B树"></a>1、B树</h1><h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>二叉搜索树：</p>
<ol>
<li>所有非叶子结点至多拥有两个儿子（ Left 和 Right ）；</li>
<li>所有结点存储一个关键字；</li>
<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li>
</ol>
<p><img src="http://static.oschina.net/uploads/img/201301/06112317_yHxY.jpg" alt=""></p>
<h2 id="1-2-搜索方法"><a href="#1-2-搜索方法" class="headerlink" title="1.2 搜索方法"></a>1.2 搜索方法</h2><p> B 树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比 结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p>
<p> 如果 B 树的所有非叶子结点的左右子树的 结点数目均保持差不多（平衡），那么 B 树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变 B 树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；如</p>
<p><img src="http://static.oschina.net/uploads/img/201301/06112317_ssDu.jpg" alt=""></p>
<p>但 B 树在经过多次插入与删除后，有可能导致不同的结构：</p>
<p><img src="http://static.oschina.net/uploads/img/201301/06112317_NTuh.jpg" alt=""></p>
<p>右边也是一个 B 树，但 它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用 B 树还 要考虑尽可能让 B 树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；       </p>
<p>实际使用的 B 树都是在原 B 树的基 础上加上平衡算法，即“平衡二叉树”；如何保持 B 树结点分布均匀的平衡算法是平衡二叉树的 关键；<strong>平衡算法</strong>是一种在 B 树中插入和删除结点的策略；</p>
<h1 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B-树"></a>2、B-树</h1><h2 id="1-1-原理-1"><a href="#1-1-原理-1" class="headerlink" title="1.1 原理"></a>1.1 原理</h2><p>是一种多路搜索树（并不是二叉的）：</p>
<p>​       1. 定义任意非叶子结点最多只有 M 个儿 子；且 M&gt;2 ；</p>
<p>​       2. 根结点的儿子数为 [2, M] ；</p>
<p>​       3. 除根结点以外的非叶子结点的儿子数为 [M/2, M] ；</p>
<p>​       4. 每个结点存放至少 M/2-1 （取 上整）和至多 M-1 个关键字；（至少 2 个关键 字）</p>
<p>​       5. 非叶子结点的关键字个数 = 指向儿 子的指针个数 -1 ；</p>
<p>​       6. 非叶子结点的关键字： K[1], K[2], …, K[M-1] ；且 K[i] &lt; K[i+1] ；</p>
<p>​       7. 非叶子结点的指针： P[1], P[2], …, P[M] ；其中 P[1] 指向关键字小于 K[1] 的子树， P[M] 指向关键字大于K[M-1] 的子树，其它 P[i] 指 向关键字属于 (K[i-1], K[i]) 的子树；</p>
<p>​       8. 所有叶子结点位于同一层；</p>
<p>如：（ M=3 ）</p>
<p><img src="http://static.oschina.net/uploads/img/201301/06112317_djvw.jpg" alt=""></p>
<p>B- 树的特性：</p>
<p>​       1. 关键字集合分布在整颗树中；</p>
<p>​       2. 任何一个关键字出现且只出现在一个结点中；</p>
<p>​       3. 搜索有可能在非叶子结点结束；</p>
<p>​       4. 其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>​       5. 自动层次控制；</p>
<p>​       由于限制了除根结点以外的非叶子结点，至少含有 M/2 个儿子，确保了结点的至少利用率，其最底搜索性能为：</p>
<p><img src="http://static.oschina.net/uploads/img/201301/06112318_AOeO.jpg" alt=""></p>
<p> 其中， M 为设定的非叶子结点最多子树个 数， N 为关键字总数；</p>
<p>​       所以 B- 树的性能<strong>总是等价于二分查找 （与 M 值无关）</strong>，也就没有 B 树平衡 的问题；</p>
<p>​       由于 M/2 的限制，在插入结点时，如果 结点已满，需要将结点分裂为两个各占 M/2 的结点；删除结点时，需将两个不足 M/2 的 兄弟结点合并；</p>
<h2 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2 方法"></a>1.2 方法</h2><p>参考</p>
<p><a href="http://www.oschina.net/question/565065_86338" target="_blank" rel="noopener">BTree,B-Tree,B+Tree,B*Tree都是什么</a></p>
<p><a href="http://blog.csdn.net/hbhhww/article/details/8206846" target="_blank" rel="noopener">B-tree/B+tree/B*tree</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/模型集成/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/模型集成/" class="post-title-link" itemprop="url">模型集成</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2018-02-11 09:26:22" itemprop="dateModified" datetime="2018-02-11T09:26:22+08:00">2018-02-11</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jiqizhixin.com/articles/2018-01-14-8" target="_blank" rel="noopener">每个Kaggle冠军的获胜法门：揭秘Python中的模型集成</a></p>
<p><img src="https://image.jiqizhixin.com/uploads/wangeditor/c897487a-bf02-4023-9355-24c747d7ef62/43133image%20(1" alt="">.png)</p>
<p>Example Schematics of an ensemble.  An input array X is fed through two proprocessing pipelines and then to a set of base learners f(i). The ensemble combines all base learner predictions into a final prediction array P. </p>
<p>By the end of the post, you will:</p>
<ul>
<li>understand the fundamentals of ensembles</li>
<li>know how to code them</li>
<li>understand the main pitfalls and drawbacks of ensembles</li>
</ul>
<h2 id="Predicting-Republican-and-Democratic-donations"><a href="#Predicting-Republican-and-Democratic-donations" class="headerlink" title="Predicting Republican and Democratic donations"></a>Predicting Republican and Democratic donations</h2><p>we’ll use a data set on U.S. political contributions. The <a href="https://github.com/fivethirtyeight/data/tree/master/science-giving" target="_blank" rel="noopener">original data set</a> was prepared by <a href="https://fivethirtyeight.com/contributors/ben-wieder/" target="_blank" rel="noopener">Ben Wieder</a> at <a href="https://fivethirtyeight.com/" target="_blank" rel="noopener">FiveThirtyEight</a>, who dug around the U.S. government’s political contribution registry and found that when <a href="https://fivethirtyeight.com/features/when-scientists-donate-to-politicians-its-usually-to-democrats/" target="_blank" rel="noopener">scientists donate to politician, it’s usually to Democrats</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line"><span class="comment">### Import data</span></div><div class="line"><span class="comment"># Always good to set a seed for reproducibility</span></div><div class="line">SEED = <span class="number">222</span></div><div class="line">np.random.seed(SEED)</div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">'input.csv'</span>)</div><div class="line"></div><div class="line"><span class="comment">### Training and test set</span></div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_test</span><span class="params">(test_size=<span class="number">0.95</span>)</span>:</span></div><div class="line">    <span class="string">"""Split Data into train and test sets."""</span></div><div class="line">    y = <span class="number">1</span> * (df.cand_pty_affiliation == <span class="string">"REP"</span>)</div><div class="line">    X = df.drop([<span class="string">"cand_pty_affiliation"</span>], axis=<span class="number">1</span>)</div><div class="line">    X = pd.get_dummies(X, sparse=<span class="keyword">True</span>)</div><div class="line">    X.drop(X.columns[X.std() == <span class="number">0</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> train_test_split(X, y, test_size=test_size, random_state=SEED)</div><div class="line"></div><div class="line">xtrain, xtest, ytrain, ytest = get_train_test()</div><div class="line"></div><div class="line"><span class="comment"># A look at the data</span></div><div class="line">print(<span class="string">"\nExample data:"</span>)</div><div class="line">df.head()</div><div class="line"></div><div class="line">df.cand_pty_affiliation.value_counts(normalize=<span class="keyword">True</span>).plot(</div><div class="line">    kind=<span class="string">"bar"</span>, title=<span class="string">"Share of No. donations"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>This claim is based on the observation on the share of donations being made to Republicans and Democrats. However, there’s plenty more that can be said: for instance, which scientific discipline is most likely to make a Republican donation, and which state is most likely to make Democratic donations? We will go one step further and <em>predict</em> whether a donation is most likely to be a to a Republican or Democrat.</p>
<h2 id="What-is-an-ensemble"><a href="#What-is-an-ensemble" class="headerlink" title="What is an ensemble?"></a>What is an ensemble?</h2><p>Combining predictions from several models averages out idiosyncratic errors and yield better overall predictions.</p>
<p>How to combine predictions?</p>
<p>Machine learning is remarkably similar in classification problems: <strong>taking the most common class label prediction is equivalent to a majority voting rule</strong>. But there are many other ways to combine predictions, and more generally we can use a <strong>model to <em>learn</em></strong> how to best combine predictions.</p>
<h3 id="Understanding-ensembles-by-combining-decision-trees"><a href="#Understanding-ensembles-by-combining-decision-trees" class="headerlink" title="Understanding ensembles by combining decision trees"></a>Understanding ensembles by combining decision trees</h3><p>The deeper the tree, the more complex the patterns it can capture, but the <strong>more prone</strong> to overfitting it will be. Because of this, we will need an alternative way of building complex models of decision trees, and an ensemble of different decision trees is one such way.</p>
<p>We’ll use the below helper function to visualize our decision rules:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pydotplus  <span class="comment"># you can install pydotplus with: pip install pydotplus </span></div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_graph</span><span class="params">(clf, feature_names)</span>:</span></div><div class="line">    <span class="string">"""Print decision tree."""</span></div><div class="line">    graph = export_graphviz(</div><div class="line">        clf,</div><div class="line">        label=<span class="string">"root"</span>,</div><div class="line">        proportion=<span class="keyword">True</span>,</div><div class="line">        impurity=<span class="keyword">False</span>, </div><div class="line">        out_file=<span class="keyword">None</span>, </div><div class="line">        feature_names=feature_names,</div><div class="line">        class_names=&#123;<span class="number">0</span>: <span class="string">"D"</span>, <span class="number">1</span>: <span class="string">"R"</span>&#125;,</div><div class="line">        filled=<span class="keyword">True</span>,</div><div class="line">        rounded=<span class="keyword">True</span></div><div class="line">    )</div><div class="line">    graph = pydotplus.graph_from_dot_data(graph)  </div><div class="line">    <span class="keyword">return</span> Image(graph.create_png())</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/算法与数据结构/最长公共子串/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/算法与数据结构/最长公共子串/" class="post-title-link" itemprop="url">最长公共子串</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法与数据结构/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>找出最长子串，需要知道子串的<strong>起始位置</strong>和子串的<strong>长度</strong>。</p>
<p>因此，维护一个二维数组，存放两个字符串的字符关系，再创建两个变量存放index和maxLen。</p>
<p><img src="https://segmentfault.com/img/remote/1460000007963599?w=684&amp;h=644" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findLcsNew</span><span class="params">(String str1, String str2)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> len1, len2;</div><div class="line">		len1 = str1.length();</div><div class="line">		len2 = str2.length();</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> maxLen = <span class="number">0</span>, index = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</div><div class="line">				<span class="keyword">if</span> ( i == <span class="number">0</span> || j == <span class="number">0</span> ) &#123;</div><div class="line">                  <span class="comment">// 第一行和第一列都是0</span></div><div class="line">					arr[i][j] = <span class="number">0</span>;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// 该字符和上一个字符均相等时</span></div><div class="line">					<span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j) &amp;&amp; str1.charAt(i-<span class="number">1</span>) == str2.charAt(j-<span class="number">1</span>)) &#123;</div><div class="line">						arr[i][j] = arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						arr[i][j] = <span class="number">0</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">if</span> (arr[i][j] &gt; maxLen) &#123;</div><div class="line">					maxLen = arr[i][j];</div><div class="line">					index = i;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		String newStr = str1.substring(index - maxLen, index + <span class="number">1</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> newStr;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>也可以用一维数组实现，同时可以记录多个相同长度的最长子串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findLcs</span><span class="params">(String str1, String str2)</span> </span>&#123;</div><div class="line">	StringBuffer buff = <span class="keyword">new</span> StringBuffer();</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line">	<span class="keyword">int</span> len1, len2;</div><div class="line">	len1 = str1.length();</div><div class="line">	len2 = str2.length();</div><div class="line">	<span class="keyword">int</span> maxLen = len1 &gt; len2 ? len1 : len2;</div><div class="line">	<span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</div><div class="line">	<span class="keyword">int</span>[] maxIndex = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</div><div class="line">	<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len2; i++) &#123;</div><div class="line">		<span class="keyword">for</span> (j = len1 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">			<span class="keyword">if</span> (str2.charAt(i) == str1.charAt(j)) &#123;</div><div class="line">				<span class="keyword">if</span> ((i == <span class="number">0</span>) || (j == <span class="number">0</span>))</div><div class="line">					c[j] = <span class="number">1</span>;</div><div class="line">				<span class="keyword">else</span></div><div class="line">					c[j] = c[j - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				c[j] = <span class="number">0</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (c[j] &gt; max[<span class="number">0</span>]) &#123; <span class="comment">// 如果是大于那暂时只有一个是最长的,而且要把后面的清0;</span></div><div class="line">				max[<span class="number">0</span>] = c[j];</div><div class="line">				maxIndex[<span class="number">0</span>] = j;</div><div class="line"></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; maxLen; k++) &#123;</div><div class="line">					max[k] = <span class="number">0</span>;</div><div class="line">					maxIndex[k] = <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[j] == max[<span class="number">0</span>]) &#123; <span class="comment">// 有多个是相同长度的子串</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; maxLen; k++) &#123;</div><div class="line">					<span class="keyword">if</span> (max[k] == <span class="number">0</span>) &#123;</div><div class="line">						max[k] = c[j];</div><div class="line">						maxIndex[k] = j;</div><div class="line">						<span class="keyword">break</span>; <span class="comment">// 在后面加一个就要退出循环了</span></div><div class="line">					&#125;</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; maxLen; j++) &#123;</div><div class="line">		<span class="keyword">if</span> (max[j] &gt; <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (i = maxIndex[j] - max[j] + <span class="number">1</span>; i &lt;= maxIndex[j]; i++)</div><div class="line">				buff.append(str1.charAt(i));			</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> buff.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/" class="post-title-link" itemprop="url">浅谈在线最优化求解算法-以CTR预测模型为例</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="1、最优化求解问题"><a href="#1、最优化求解问题" class="headerlink" title="1、最优化求解问题"></a>1、最优化求解问题</h1><p>通常，我们需要求解的最优化问题有如下三类：</p>
<p><strong>（1）无约束优化问题</strong>：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)</script><p>含义是求解X，令目标函数$f(X)$最小。</p>
<p>对于这类问题，在$f(X)$ 是凸函数的前提下，通常做法就是对$f(X)$ 求导，并令$\frac {\partial} {\partial X} f(X) =0$ ，求解可以得到最优值。</p>
<blockquote>
<p> <strong>凸函数</strong></p>
<p> 如果$f(x)$是定义在N维向量空间上的实变量函数，对于在$f(x)$的定义域C上的任意两个点$x_1$和$x_2$，以及任意[0,1]之间的值t都有：</p>
<script type="math/tex; mode=display">
 f(tX_1 + (1-t)X_2) \leq tf(X_1)+(1-t)f(X_2)\\
 \forall X_1,X_2 \in C,\ \ 0 \leq t \leq 1</script><p> 则称$f(x)$是凸函数。一个函数是凸函数是其存在最优解的充要条件。</p>
<p> 此外，如果$f(x)$满足</p>
<script type="math/tex; mode=display">
 f(tX_1 + (1-t)X_2)< tf(X_1)+(1-t)f(X_2)\\
 \forall X_1,X_2 \in C,\ \ 0 \leq t \leq 1</script><p> 则$f(x)$为严格凸函数。如下图所示，左边是严格凸函数，右边是凸函数</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/凸函数.png" alt="凸函数"></p>
</blockquote>
<p><strong>（2）有等式约束的最优化问题</strong>：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)\\
s.t. h_k(X)=0;k=1,2,...,n</script><p>含义是在n个等式约束$h_k(X)$ 的条件下求解X，另目标函数$f(X)$最小。</p>
<p>针对有等式的最优化问题，采用<strong>拉格朗日乘数法</strong>进行求解，通过拉格朗日系数$A=[a_1,a_2,…,a_n]^T$ 把等式约束和目标函数组合成一个式子</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}[f(X)+ A^TH(X)]</script><p>相当于转化成无约束最优化求解问题，解决方法是分别对X，A求偏导并令其等于0。</p>
<p><strong>（3）不等式约束的优化问题求解</strong> ：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)\\
s.t. h_k(X)=0;k=1,2,...,n\\
g_l(X)\leq 0;l=1,2,...,m</script><p>对于不等式约束，通过KKT条件求解。将所有的约束和目标函数写为一个式子</p>
<script type="math/tex; mode=display">
L(X,A,B)=f(X)+A^TH(X)+B^TG(X)</script><p>KKT条件是说最优值必须满足以下条件：</p>
<script type="math/tex; mode=display">
\frac \partial {\partial X} L(X,A,B)=0\\
H(X)=0\\
B^TG(X)=0</script><p>KKT条件是求解最优值的必要条件，要使其成为充要条件，还需要f(x)为凸函数。</p>
<h1 id="2、批量最优化求解算法"><a href="#2、批量最优化求解算法" class="headerlink" title="2、批量最优化求解算法"></a>2、批量最优化求解算法</h1><p>一些定义：</p>
<p>$i=1,2,…,N$表示向量维度</p>
<p>$j=1,2,…,M$表示样本个数</p>
<p>$t=1,2,…$表示迭代次数</p>
<h2 id="2-1-批量和随机求解"><a href="#2-1-批量和随机求解" class="headerlink" title="2.1 批量和随机求解"></a>2.1 批量和随机求解</h2><p>我们面对的最优化问题都是无约束的最优化问题（有约束的也可以转成无约束的），因此通常可以将其描述为</p>
<script type="math/tex; mode=display">
W=\arg \underset{W}{min}\   l(W,Z)\\
Z=\{ (X_j,y_j) | j=1,2,...,M  \}\\
y_j=h(W,X_j)
\tag {2-1-1}</script><p>就是<strong>在已知训练集的情况下，求使得目标函数最小的权重矩阵</strong>。其中，$Z$是训练集，$\mathbf{X}$是特征向量，$X_j$是其中一个样本，$Y$是预测值，$y_j$是其中一个样本对应的预测值。一共有M个样本。$h(W,X_j)$ 是特征向量到预测值的<strong>映射函数</strong>，$ l(W,Z)$ 最优化求解的目标函数，也称为<strong>损失函数</strong>，$W$ 为特征权重，也就是在损失函数中需要求解的参数。</p>
<blockquote>
<p> 损失函数一般包括损失项和正则项</p>
</blockquote>
<p>常用的损失函数有：</p>
<p>（1）<strong>平方损失函数</strong>（线性回归）</p>
<p>最小二乘法（Ordinary Least Squares）是常用的一种平方损失函数，最小二乘的基本原理是：最优拟合直线应该是使各点到回归直线的距离和最小的直线，即平方和最小。</p>
<p>线性回归的映射函数为：</p>
<script type="math/tex; mode=display">
h(W,X_j)=W^TX_j</script><p>损失函数可以表示为</p>
<script type="math/tex; mode=display">
l(W,Z)=\sum_{j=1}^M (y_j-W^TX_j)^2</script><p>（2）<strong>Logistics损失函数</strong>（逻辑回归）</p>
<p>逻辑回归的映射函数为：</p>
<script type="math/tex; mode=display">
h(W,X_j)=\frac 1 {1+e^{-W^TX_j}}</script><blockquote>
<p>logistic函数的优点是：</p>
<p>1、他的输入范围是$-\infty \rightarrow  + \infty $ ，<strong>输出范围是(0,1)，正好满足概率分布为（0，1）的要求</strong>。我们用概率去描述分类器，自然比单纯的某个阈值要方便很多； </p>
<p>2、是一个单调上升的函数，具有良好的连续性，<strong>不存在不连续点</strong>。</p>
</blockquote>
<p>由于该函数服从伯努利分布（0-1分布），通过最大似然估计，对于每一维的权重W，损失函数可以表示为</p>
<script type="math/tex; mode=display">
l(W,Z)=(Y-h_W(\mathbf X))X</script><blockquote>
<p><strong>推导过程</strong></p>
<p>令</p>
<script type="math/tex; mode=display">
h_W(X) = \frac 1 {1+e^{-W^T\mathbf X}}</script><p>该函数服从伯努利分布（一次点击要么成功，要么失败，通过训练集可以知道不同特征组合下成功和失败的概率）</p>
<script type="math/tex; mode=display">
P(Y=1 | \mathbf X;W) = h_W(\mathbf X)\\
P(Y=0 | \mathbf X;W) = 1-h_W(\mathbf X)</script><p>则概率分布函数为</p>
<script type="math/tex; mode=display">
P(Y|\mathbf X;W) = (h_W(\mathbf X))^Y*(1-h_W(\mathbf X))^{1-Y}</script><p>（<strong>也就是说，我们有样本，通过样本能知道概率分布，那么我们需要知道得到这个概率分布的最有可能的参数W。即我们通过样本知道一些特征组合下的点击率，现在需要求概率函数中的系数。</strong>）</p>
<p>我们假设样本数据相互独立，所以它们的联合分布可以表示为各边际分布的乘积，用似然函数表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
L(W)=P(Y|\mathbf X;W) &= (h_W(\mathbf X))^Y(1-h_W(\mathbf X))^{1-Y}\\
&=\prod_{j=1}^M(h_W(X_j))^{y_j}(1-h_W(X_j))^{1-y_j}
\end{aligned}
\tag {2-1-2}</script><p>从而，损失函数的求解，可以转化为求最有可能导致这样概率分布的W，也就是求L(W)的最大值。最简单的方法就是对W求偏导，并令导数为零。</p>
<p>在多数情况下，直接对变量进行求导反而会使得计算式子更加的复杂，此时可以借用对数函数。由于对数函数是单调增函数，因此与（2-1-2）具有相同的最大值，上式变为</p>
<script type="math/tex; mode=display">
\begin{aligned} 
l(W) &= Log\ L(W)\\
&=\sum_{j=1}^M(y_jln\ h(X_j)+(1-y_j)ln\ (1-h(X_j)))
\end{aligned}</script><p>对其求关于W的偏导</p>
<p>首先求logistic函数的导数，得（最后一个X是对$W^TX$的求导）</p>
<script type="math/tex; mode=display">
h_W^{'}(\mathbf X) = h_W(\mathbf X)(1-h_W(\mathbf X))</script><blockquote>
<p><strong>推导过程如下</strong></p>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/求导的推导.jpg" alt="求导的推导"></p>
</blockquote>
<p>为了求解方便，将l(W)转为（其实1/M没用，完全可以去掉，不懂为何要加上）</p>
<script type="math/tex; mode=display">
J(W) = -\frac {1}{M} l(W)</script><p>则就变成求J(W)的最小值。求偏导的过程如下：</p>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/最大似然估计求偏导.png" alt="最大似然估计求偏导"></p>
<p>最后得到目标函数（损失函数）为：</p>
<script type="math/tex; mode=display">
\frac {\partial }{\partial W}J(W) =-\frac{1}{M} (Y-h_W(\mathbf X))X</script></blockquote>
<p>对于损失函数的求解，一个典型的方法就是梯度下降法，由于损失函数是凸函数，因此沿着梯度下降的方向找到最小点。</p>
<p>假设样本总数为m，<strong>批量梯度下降</strong>是：</p>
<script type="math/tex; mode=display">
Repeat\ until\ convergence \{ \\
W^{(t+1)} := W^t - \eta^t\triangledown  _{W}l(W^{t},Z) \\
\}\\
 \tag{1-2}</script><p>而<strong>随机梯度下降（SGD）</strong>是：</p>
<script type="math/tex; mode=display">
Repeat\ until\ convergence \{ \\
      for\ j=1\ to\ M, \{ \\
          W^{(t+1)} := W^t - \eta^t\triangledown  _{W}l(W^{t},Z_j) \\
\}</script><p>两者的区别是：</p>
<p>前者每次更新$W$都需要遍历一次整个样本集合；而后者在遍历样本集合的时候，每个样本都能改变$W$ ，有更快的收敛速度 。由于SGD针对观测到的随机一条数据进行权重的更新，很适合进行增量计算，实现梯度下降的online模式。</p>
<h2 id="2-2-正则化"><a href="#2-2-正则化" class="headerlink" title="2.2 正则化"></a>2.2 正则化</h2><p>正则化的主要目的是防止过拟合。对于损失函数构成的模型，可能会出现有些权重很大，有些权重很小的情况，导致过拟合，使得模型的复杂度提高，泛化能力较差（对未知数据的预测能力）。</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/过拟合1.png" alt="过拟合1"></p>
<p>而正则化就是对损失函数中权重的限制，限制其模不要太大：</p>
<script type="math/tex; mode=display">
W=\arg \underset{W}{min}\   l(W,Z)\\
s.t. \Psi(W)<\delta</script><p>其中，$\Psi(W)$称为正则化因子，是一个关于W求模的函数，常用的正则化因子有L1和L2正则化。</p>
<script type="math/tex; mode=display">
L1\ Regularization \ \ \ \ \ \ \ \ \Psi(W)=||W||_1=\sum_{i=1}^N|w_i|\\
L2 \ Regularization\ \ \ \ \ \ \ \Psi(W)=||W||_2^2=\sum_{i=1}^N(w_i)^2=W^TW</script><p>L1和L2的主要区别有两个：</p>
<p>（1）L1在0处不可导，而L2可导。</p>
<p>（2）L1通常能产生更稀疏的模型，也就是W的更多维度是0。这些为0的权重就代表了不是很重要的维度，所以能起到特征选择的目的。</p>
<p>（3）L2能限制特征权重各个维度的模不要太大，解决过拟合。</p>
<blockquote>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/正则化解空间.png" alt="正则化解空间"><br> 其中，左图的圆形区域是L2正则化的单位圆，右图的方形区域是L1正则化的单位圆。<br><strong>单位圆</strong></p>
<p>使$||X||_p=1$的图形，当p=1和2时，单位圆分别为$|x|+|y|=1$和$x^2+y^2=1$。</p>
</blockquote>
<p>但是在SGD中，由于每次W的更新并不是沿着全局梯度进行下降，而是沿着某个样本产生的梯度方向进行下降，这样即使采用L1的方式也很难产生稀疏解。因此在接下来的在线最优化求解算法中，稀疏性是一个主要的追求目标。</p>
<p>参考：</p>
<p><a href="http://www.mamicode.com/info-detail-517504.html【正则化方法：L1和L2" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-517504.html【正则化方法：L1和L2</a> regularization、数据集扩增、dropout】</p>
<p><a href="http://blog.csdn.net/zouxy09/article/details/24971995/【机器学习中的范数规则化之（一）L0、L1与L2范数】" target="_blank" rel="noopener">http://blog.csdn.net/zouxy09/article/details/24971995/【机器学习中的范数规则化之（一）L0、L1与L2范数】</a></p>
<h1 id="3、在线最优化求解算法"><a href="#3、在线最优化求解算法" class="headerlink" title="3、在线最优化求解算法"></a>3、在线最优化求解算法</h1><h2 id="3-1-截断梯度法TG"><a href="#3-1-截断梯度法TG" class="headerlink" title="3.1 截断梯度法TG"></a>3.1 截断梯度法TG</h2><p>为了使特征权重W有更多的0，最简单的方法就是设一个阈值，当W的某个维度值小于这个阈值的时候置为0，这个称为<strong>简单截断法</strong>。但实际中W的某个系数比较小可能是由于该维度训练不足引起，所以这么做会导致这部分特征的丢失。于是又改进为<strong>截断梯度法Truncated Gradient</strong>。</p>
<h3 id="3-1-1-简单截断法"><a href="#3-1-1-简单截断法" class="headerlink" title="3.1.1 简单截断法"></a>3.1.1 简单截断法</h3><p>以$k$为窗口，当$t/k$不为整数时，采用标准的SGD；否则，采用如下的权重更新方式：</p>
<script type="math/tex; mode=display">
W^{t+1}=T_0(W^t - \eta^tG^t,\theta) \\
T_0(v_i,\theta) = \begin{Bmatrix}
0\ if\ |v_i|\leqslant \theta\\ 
v_i\ otherwise
\end{Bmatrix}</script><p>其中，$G^t=\triangledown  _{W}l(W^{t},Z^{t})$ 代表第t次迭代中损失函数的梯度，$\eta^{t}$ 是学习率，通常将其设置为 $1/\sqrt{t}$ 的函数。可以看出，简单截断法的思路是，如果某个维度的权重变化小于设定的$\theta$ ，则直接置为0。</p>
<h3 id="3-1-2-截断梯度法"><a href="#3-1-2-截断梯度法" class="headerlink" title="3.1.2 截断梯度法"></a>3.1.2 截断梯度法</h3><p>在前一种方法上的改进。加入了L1正则化项$\eta^{t}\lambda sgn(W^{t})$ 。</p>
<script type="math/tex; mode=display">
W^{t+1}=W^t-\eta ^tG^t-\eta^t\lambda sgn(W^t)</script><p>其中$sgn(v)$是符号函数。由于每次仅根据一个样本进行更新，因此也不再使用区分样本的下表$j$。</p>
<p>采用类似的方式表示为：</p>
<script type="math/tex; mode=display">
W^{t+1}=T_1(W^t - \eta^tG^t,\eta^t\lambda^t,\theta) \\
T_1(v_i,\alpha,\theta) = \begin{Bmatrix}
\begin{aligned}
& max(0,v_i-\alpha)\ if\ v_i\in [0,\theta]\\ 
& min(0,v_i+\alpha)\ if\ v_i\in [-\theta,0]\\
& v_i\ otherwise
\end{aligned}
\end{Bmatrix}</script><p>其中，$\lambda^{t} \in \mathbb{R}$且$\lambda^{t}\geqslant0 $ 。同样以k为窗口，每k步进行一次截断。当t/k不为整数时，$\lambda^{t}=0$， 否则，$\lambda^{t}=k\lambda$。可以看出，$\lambda$和$\theta$决定了权重的稀疏程度，这两个值越大越稀疏。</p>
<h2 id="3-2-前向后向切分FOBOS"><a href="#3-2-前向后向切分FOBOS" class="headerlink" title="3.2 前向后向切分FOBOS"></a>3.2 前向后向切分FOBOS</h2><h3 id="3-2-1-FOBOS算法原理"><a href="#3-2-1-FOBOS算法原理" class="headerlink" title="3.2.1 FOBOS算法原理"></a>3.2.1 FOBOS算法原理</h3><p>在FOBOS（Forward-backward Splitting）中，将权重的更新分为两个步骤：</p>
<script type="math/tex; mode=display">
W^{t+\frac{1}{2}} = W^t-\eta^tG^{t}\\
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t+\frac{1}{2}}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}
\tag {3-2-1}</script><p>前一个步骤还是标准的梯度下降，后一个步骤可以理解为对梯度下降的结果进行微调，其中第一项是L2正则化，表示不能离损失迭代结果太远，第二项$\Psi (W)$是正则化项。</p>
<p>将上面两个式子合并，有</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t}-\eta^{t}G^{t}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}</script><p>令</p>
<script type="math/tex; mode=display">
F(W)=\frac {1} {2} ||W- W^{t}-\eta^{t}G^{t}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)</script><p>如果$W^{t+1}$存在一个最优解，<strong><em>那么可以推断0向量一定属于$F(W)$的一维次梯度集合</em>。</strong></p>
<script type="math/tex; mode=display">
0 \in \partial F(W)=W-W^{t}+\eta^{t}G^{t}+\eta^{t+\frac 1 2}\partial \Psi(W)</script><blockquote>
<p><strong>次导数和次梯度</strong></p>
<p>参考SubGradient.pdf</p>
<p>次导数是一个区间，一维次梯度就是次导数</p>
</blockquote>
<p>由于$W^{t+1}=\arg \underset{x}{min} F(W)$，则有：</p>
<script type="math/tex; mode=display">
0=\left \{ W-W^{t} - \eta^{t}G^{t}+\eta^{t+\frac {1}{2}}\partial\Psi(W) \right \}|_{W=W^{t+1}}</script><p>便可以得到另一种更新权重的方式</p>
<script type="math/tex; mode=display">
W^{t+1}=W^{t}+ \eta^{t}G^{t}-\eta^{t+\frac {1}{2}}\partial\Psi(W^{t+1})</script><p>从上式可以看到权重的更新不仅与迭代前的状态有关，也与迭代后的$W^{t+1}$有关。</p>
<h3 id="3-2-2-L1-FOBOS"><a href="#3-2-2-L1-FOBOS" class="headerlink" title="3.2.2 L1-FOBOS"></a>3.2.2 L1-FOBOS</h3><p>在L1正则化下，有$\Psi (W)=\lambda||w||_1$ 。对于（2-3-1），</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t+\frac{1}{2}}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}</script><p>用向量V来表示$W^{t+\frac 1 2}$ ，用标量$\tilde{\lambda} \in \mathbb{R}$来表示$\eta^{t+\frac 1 2}\lambda$ ，将公式展开，并改写为</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min}\sum_{i=1}^N (\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)
\tag {3-2-2}</script><p>可以看到，在求和公式中的每一项都是大于0的，所以公式（3-2-2）可以拆解成对特征权重W的每一维度单独求解</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\arg \underset{w_i}{min}(\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)
\tag {3-2-3}</script><p>假设$w_i^<em>$是一个维度上的最优解，通过反证法证明$w_i^</em>v_i\geq0$（证明略）。再分$v_i\geq0$和$v_i&lt;0$来讨论。</p>
<p><strong>（1）当$v_i\geq0$时</strong>，</p>
<p>由于$w_i^<em>v_i\geq0$，所以$w_i^</em> \geq0$ 。相当于给（2-3-3）增加了一个不等式约束条件：</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\arg \underset{w_i}{min}(\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)\\
s.t. -w_i\leq 0</script><p>通过拉格朗日乘子求解这个含不等式的约束问题。</p>
<p>引入拉格朗日系数$\beta \geq 0$ ，由KKT条件，有</p>
<script type="math/tex; mode=display">
\frac \partial {\partial w_i}\left ( \frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|-\beta w_i \right )|_{w_i=w_i^*}=0 \\
\beta w_i^*=0</script><p>根据上面的求导可得</p>
<script type="math/tex; mode=display">
w_i^*=v_i-\tilde{\lambda}+\beta</script><p>再分为两种情况</p>
<p>① 当$w_i^<em> &gt; 0$ 时，由于$\beta w_i^</em>=0$ 所以$\beta=0$，此时有$w_i^*=v_i-\tilde{\lambda}$ ，从而$v_i-\tilde{\lambda} &gt; 0$ 。</p>
<p>② 当$w_i^* = 0$ 时，有$v_i-\tilde{\lambda}+\beta=0$ 。由于$\beta \geq 0$ ，所以$v_i-\tilde{\lambda} \leq 0$  。</p>
<p>可以得出，当$v_i\geq0$ 时，</p>
<script type="math/tex; mode=display">
w_i^* = max(0, v_i-\tilde{\lambda})</script><p><strong>（2）当$v_i&lt;0$时</strong>，</p>
<p>采用同样的分析方法，得到</p>
<script type="math/tex; mode=display">
w_i^* =- max(0, -v_i-\tilde{\lambda})</script><p>综上，可得FOBOS在L1正则化条件下，特征权重各个维度的更新方式为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
w_i^{t+1} &= sgn(v_i)max(0,|v_i|-\tilde{\lambda})\\
& = sgn(w_i^{t}-\eta^{t}g_i^{t})max \left \{ 0, |w_i^{t}-\eta^{t}g_i^{t}|-\eta^{t+ \frac {1} {2}} \lambda \right \}
 \end{aligned}
 \tag{3-2-4}</script><p>其中，$g_i^{t}$就是梯度在维度i上的取值。</p>
<p><strong>从公式（3-2-4）可以看出，L1-FOBOS每次更新W的时候，对W的每个维度都会进行判定，当$|w_i^{t}-\eta^{t}g_i^{t}|-\eta^{t+ \frac {1} {2}} \lambda&lt;0$的时候对齐进行截断，即权重置为0。</strong></p>
<p>换一种写法，</p>
<script type="math/tex; mode=display">
|w_i^{t}-\eta^{t}g_i^{t}|<\eta^{t+ \frac {1} {2}} \lambda
\tag {3-2-5}</script><p>可以看出截断的意义是，<strong>当一条样本产生的梯度不足以令对应维度上的权重值发生足够大的变大（$\eta^{t+ \frac {1} {2}} \lambda$ ），则认为在本次更新过程中该维度不重要，令其权重为0</strong>。</p>
<p>若对L1-FOBOS进行适当的变换，可以发现，L1-FOBOS就是TG在特定条件下的特殊形式。</p>
<h2 id="3-3-RDA"><a href="#3-3-RDA" class="headerlink" title="3.3 RDA"></a>3.3 RDA</h2><h3 id="3-3-1-RDA算法原理"><a href="#3-3-1-RDA算法原理" class="headerlink" title="3.3.1 RDA算法原理"></a>3.3.1 RDA算法原理</h3><p>TG和FOBOS都是建立在SGD的基础之上，属于梯度下降类型的方法，这类型方法的优点就是精度比较高，并且 TG、 FOBOS 也都能在稀疏性上得到提升。 但是有些其它类型的算法，例如 RDA，是从另一个方面来求解 Online Optimization 并且更有效地提升了特征权重的稀疏性。 </p>
<p>正则对偶平均（ RDA, Regularized Dual Averaging） 是微软十年的研究成果， RDA 是 Simple Dual Averaging Scheme 的一个扩展， 由 Lin Xiao 发表于 2010 年 。</p>
<p>在 RDA 中， 特征权重的更新策略为： </p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\Psi(W)+\frac {\beta^{t}}{t}h(W) \right \}
\tag {3-3-1}</script><p>本质上，公式（3-3-1）包括了3个部分：</p>
<p>（1）线性函数$\frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle$ 包含了之前所有梯度（或次梯度）的平均值（dual average），$G^r$ 是梯度；</p>
<p>（2）$\Psi(W)$ 为正则项；</p>
<p>（3）额外正则项$\frac {\beta^{t}}{t}h(W)$。其中$h(W)$是一个辅助的严格凸函数。${\beta^{t}|t\geq 1}$ 是一个非负且非自减序列。</p>
<h3 id="3-3-2-L1-RDA"><a href="#3-3-2-L1-RDA" class="headerlink" title="3.3.2 L1-RDA"></a>3.3.2 L1-RDA</h3><p>在L1正则化下，有$\Psi (W)=\lambda||w||_1$，并且由于$h(W)$是一个关于W的严格凸函数，就令$h(W)=\frac {1} {2} ||W||_2^2 $ 。此外，将${\beta^{t}|t\geq 1}$定义为$\beta^{t}=\gamma \sqrt t $ 。再代入（2-4-1），有</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\lambda||w||_1+\frac {\gamma} {2\sqrt t}||W||_2^2 \right \}
\tag {3-3-2}</script><p>分解到每一个权重的维度上</p>
<script type="math/tex; mode=display">
w_i^{t+1} = \arg \underset{w_i}{min} \left \{ \bar{g_i}^{t}w_i +\lambda|w_i|+\frac {\gamma} {2\sqrt t}w_i^2 \right \}
\tag {3-3-3}</script><p>这里$\lambda &gt;0,\ \frac {\gamma} {\sqrt t}&gt;0,\  \bar{g<em>i}^{t} = \frac 1 t \sum</em>{r=1}^t g_i^{(r)}$ 。公式（2-4-3）就是一个无约束的非平滑最优化问题（因为第二项$\lambda|w_i|$ 在0处不可导）。所以用次导数求解。</p>
<p>假设$w_i^<em>$ 是其最优解，并且定义$\xi \in \partial  |w_i|$为$|w_i|$ 在$w_i^</em>$ 的次导数，则有</p>
<script type="math/tex; mode=display">
\partial |w_i^*| =  \left\{\begin{matrix}
-1<\xi<1  & if w_i^*=0\\ 
1 & if w_i^*>0\\ 
-1 & if w_i^*<0
\end{matrix}\right.</script><p>对公式（3-3-3）求次导数，并令其为0，则有</p>
<script type="math/tex; mode=display">
\bar{g_i}^{t} + \lambda\xi + \frac {\gamma} {\sqrt t} w_i = 0</script><p>由于$\lambda &gt;0$，再分情况讨论（略），可以得到L1-RDA特征权重的各个维度更新的方式为：</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\begin{Bmatrix}
0 & if |\bar{g_i}^{t}|<\lambda\\ 
-\frac {\sqrt t}{\gamma}\left (\bar{g_i}^{t}-\lambda sgn(\bar{g_i}^{t})  \right ) & otherwise
\end{Bmatrix}
\tag {3-3-4}</script><p><strong>这里可以看出，当某个维度上累积梯度平均值的绝对值小于阈值$\lambda$ 时，产生截断</strong>。</p>
<h3 id="3-3-3-L1-RDA和L1-FOBOS的比较"><a href="#3-3-3-L1-RDA和L1-FOBOS的比较" class="headerlink" title="3.3.3 L1-RDA和L1-FOBOS的比较"></a>3.3.3 L1-RDA和L1-FOBOS的比较</h3><p>在L1-FOBOS中，进行截断的条件是</p>
<script type="math/tex; mode=display">
|w_i^{t}-\eta^{t}g_i^{t}|<\eta^{t+ \frac {1} {2}} \lambda</script><p>通常会定义$\eta$为与$\frac 1 {\sqrt t}$ 正相关的函数$\eta=\Theta \left ( \frac {1} {\sqrt t} \right )$ 。因此L1-FOBOS的<strong>截断阈值为$\Theta \left ( \frac {1} {\sqrt t} \right )\lambda$  ，</strong>随着**t的增加，这个阈值会逐渐降低。</p>
<p>相比较而言，L1-RDA的<strong>截断阈值是$\lambda$ </strong>。是一个常数，并不随着t变化，因此相对于L1-FOBOS更简单粗暴。这种性质使得L1-RDA更容易产生稀疏性。此外， RDA 中判定截断的对象是梯度的累加平均值$\bar{g_i}^{t} $ ， 不同于 TG或L1-FOBOS 中针对单次梯度计算的结果进行判定，避免了由于某些维度由于训练不足导致截断的问题。 并且通过调节一个参数$\lambda$，很容易在精度和稀疏性上进行权衡 。</p>
<h2 id="3-4-FTRL"><a href="#3-4-FTRL" class="headerlink" title="3.4 FTRL"></a>3.4 FTRL</h2><p>有实验证明， <strong>L1-FOBOS 这一类基于梯度下降的方法有比较高的精度，但是 L1-RDA 却能在损失一定精度的情况下产生更好的稀疏性。 FTRL则是结合了两者的优点</strong>。</p>
<h3 id="3-4-1-L1-FOBOS和L1-RDA在形式上的统一"><a href="#3-4-1-L1-FOBOS和L1-RDA在形式上的统一" class="headerlink" title="3.4.1 L1-FOBOS和L1-RDA在形式上的统一"></a>3.4.1 L1-FOBOS和L1-RDA在形式上的统一</h3><p>之前提到，L1-FOBOS可以表示为（这里令$\eta^{t+\frac 1 2}=\eta^t=\Theta(\frac 1 {\sqrt t})$  是一个随t变化的非增正序列） </p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^t-\eta^tG^t||^2+\eta^{t}\lambda||w||_1\}</script><p>将其按W的维度分解为N个独立的最优化步骤</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize} \left \{  \frac 1 2 (w_i-w_i^t+\eta^tg_i^t)^2+\eta^t\lambda|w_i| \right \}\\
=\underset{w_i}{minimize}\left \{  \frac 1 2 (w_i-w_i^t)^2 + \frac 1 2(\eta^tg_i^t)^2+w_i\eta^tg_i^t- w_i^t\eta^tg_i^t+    \eta^t\lambda|w_i| \right \}\\</script><p>同时除以$\eta^t$ ，得到</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize}\left \{ w_ig_i^t+\lambda|w_i|+\frac 1 {2\eta^t}(w_i-w_i^t)^2 + [\frac {\eta^t}{2}(g_i^t)2+w_i^tg_i^t] \right \}</script><p>由于$\frac {\eta^t}{2}(g_i^t)2+w_i^tg_i^t$ 与变量$w_i$ 无关，因此上式可以等价于</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize}\left \{ w_ig_i^t+\lambda|w_i|+\frac 1 {2\eta^t}(w_i-w_i^t)^2 +  \right \}</script><p>再将这N个独立的合并，则L1-FOBOS可以写成</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ G^t\cdot W+\lambda||W||_1+\frac 1 {2\eta^t}||W-W^t||_2^2 \right \}</script><p>而对于L1-RDA的公式（3-3-2）</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\lambda||w||_1+\frac {\gamma} {2\sqrt t}||W||_2^2 \right \} \\</script><p>同时乘以t，得到</p>
<script type="math/tex; mode=display">
\begin{aligned} 
W^{t+1} & = \arg \underset{W}{min} \left \{ \sum_{r=1}^t  G^r \cdot W  +t\lambda||w||_1+\frac {1} {2\eta^t}||W-0||_2^2 \right \}\\
& =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +t\lambda||w||_1+\frac {1} {2\eta^t}||W-0||_2^2 \right \}
\end{aligned}</script><p>如果令$\sigma ^s = \frac 1 {\eta^s}-\frac 1 {\eta^{s-1}}$  ，则$\sigma^{1:t} = \frac 1 {\eta^t}$ 。L1-FOBOS和L1-RDA的公式可以写成</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ G^t\cdot W+\lambda||W||_1+\frac 1 2\sigma^{1:t}||W-W^t||_2^2 \right \}\\
W^{t+1} =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +t\lambda||W||_1+\frac 1 2\sigma^{1:t}||W-0||_2^2 \right \}
\tag {3-4-1}</script><p>比较这两个公式，可以看出L1-FOBOS和L1-RDA的区别在于：</p>
<p>（1）前者对梯度只考虑当前的状态，而后者的梯度是累加的形式；</p>
<p>（2）前者的第三项限制了W的变化不能离已经迭代过的解太远，后者限制W不能离0太远。</p>
<h3 id="3-4-2-FTRL算法原理"><a href="#3-4-2-FTRL算法原理" class="headerlink" title="3.4.2 FTRL算法原理"></a>3.4.2 FTRL算法原理</h3><p>FTRL综合考虑了L1-FOBOS和L1-RDA中对正则项和W限制的区别，其特征权重的更新公式为</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +\lambda_1||W||_1+\lambda_2||W||_2^2+\frac 1 2\sum_{s=1}^t \sigma^s ||W-W^s||_2^2 \right \}
\tag {3-4-2}</script><p>其中L2的正则项在论文中并没有出现，但是2013年的FTRL工程化实现的论文却使用。事实上该项的引入并不影响FRTL<br>的稀疏性， 后面的推导过程会显示这一点。 L2正则项的引入仅仅相当于对最优化过程多了一个约束，使得结果求解结果更加“平滑”。 </p>
<p>对（3-4-2）进行变换，将其的最后一项展开</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  (G^{1:t}-\sum_{s=1}^t\sigma^sW^s) \cdot W  +\lambda_1||W||_1+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)||W||_2^2+\frac 1 2\sum_{s=1}^t \sigma^s ||W^s||_2^2 \right \}</script><p>其中，由于$\frac 1 2\sum_{s=1}^t \sigma^s ||W^s||_2^2$ 相对于W是常数项，再令</p>
<script type="math/tex; mode=display">
Z^{t} =G^{1:t}-\sum_{s=1}^t\sigma^sW^s
\tag {3-4-3}</script><p>上式等价于</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  Z^t \cdot W  +\lambda_1||W||_1+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)||W||_2^2 \right \}</script><p>再针对每个维度将其拆解成N个独立的标量最小化问题</p>
<script type="math/tex; mode=display">
 \underset{w_i}{minimize} \left \{  z_i^tw_i  +\lambda_1|w_i|+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)w_i^2 \right \}</script><p>到这里，遇到了与L1-RDA的（3-3-3）类似的优化问题，用相同的分析方法可以得到</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\left\{\begin{matrix}
0 & if\ |z_i^t|<\lambda_1\\ 
-\left ( \lambda_2+\sum_{s=1}^t\sigma^s \right )^{-1}\ \left ( z_i^t-\lambda_1 sgn(z_i^t) \right ) & otherwise
\end{matrix} \right.
\tag {3-4-4}</script><p>可以看出，引入L2并没有对FTRL结果的稀疏性产生影响。</p>
<h3 id="3-4-3-学习率"><a href="#3-4-3-学习率" class="headerlink" title="3.4.3 学习率"></a>3.4.3 学习率</h3><p>前面的推导中，学习率的选择和计算没有被提及。事实上在FTRL中，每个维度的学习率都是单独考虑的。</p>
<p>考虑特征维度的变化率：如果特征 1 比特征 2 的变化更快，那么在维度 1 上的学习率应该下降得更快。我们很容易就可以想到可以用某个维度上梯度分量来反映这种变化率。在FTRL 中，维度 i上的学习率是这样计算的<strong>（原作者没有推导过程）</strong>：</p>
<script type="math/tex; mode=display">
\eta_i^t=\frac {\alpha}{\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}</script><p>由于$\sum_{s=1}^t\sigma^s=\frac 1 {\eta^t}$ ，因此（3-4-4）就变成</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\left\{\begin{matrix}
0 & if\ |z_i^t|<\lambda_1\\ 
-\left ( \lambda_2 + \frac {\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}{\alpha}  \right )^{-1}\ \left ( z_i^t-\lambda_1 sgn(z_i^t) \right ) & otherwise
\end{matrix} \right.
\tag {3-4-5}</script><p>这里的$\alpha, \beta$ 都是要输入的参数。</p>
<h3 id="2-5-4-伪代码解读"><a href="#2-5-4-伪代码解读" class="headerlink" title="2.5.4 伪代码解读"></a>2.5.4 伪代码解读</h3><p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/FTRL伪代码.png" alt="FTRL伪代码"></p>
<p>首先设置各个参数的初始值，包括</p>
<ul>
<li>更新学习率的$\alpha,\beta$。</li>
<li>L1和L2正则化的参数$\lambda_1,\ \lambda_2$ </li>
<li>更新权重时用到的$z_i$ 一维数组（数组的长度是特征项个数），初始值是0</li>
<li>存放梯度累加的$n_i$ 一维数组（数组的长度是特征项个数），初始值是0</li>
</ul>
<p>算法步骤中：</p>
<p>（1）第一阶段，计算第t次迭代的预测值</p>
<p><strong>S1</strong>：用给定的初始值计算权重$w_{t,i}$，并计算出预测值$p_t$ 。见①</p>
<p>（2）第二阶段，更新第t+1次的权重，对当前样本不为0的每个特征项都要进行一次更新。在第i个特征项中，</p>
<p><strong>S1</strong>：采用logloss计算损失函数的梯度$g_{t+1}$，见②</p>
<p><strong>S2</strong>：可以看出①里面还需要计算$n_i$  和$z_i$ 在第t+1次的值。</p>
<p>对于$z_i$，根据公式（2-5-3）</p>
<script type="math/tex; mode=display">
Z^{t} =G^{1:t}-\sum_{s=1}^t\sigma^sW^s</script><p>可以看出z的更新可以通过下式计算</p>
<script type="math/tex; mode=display">
\begin {aligned}
Z^{t+1}& =G^{1:t+1}-\sum_{s=1}^{t+1}\sigma^sW^s\\
&=G^{1:t}-\sum_{s=1}^t\sigma^sW^s + G^{t+1} - \sigma^{t+1}W^{t+1}\\
&=Z^t + G^{t+1} - \sigma^{t+1}W^{t+1}
 \end{aligned}
 \tag {3-4-6}</script><p>则需要计算$\sigma^{t+1}$ 的值。而根据上文的推导</p>
<script type="math/tex; mode=display">
\sigma ^s = \frac 1 {\eta^s}-\frac 1 {\eta^{s-1}}</script><p>又</p>
<script type="math/tex; mode=display">
\eta_i^t=\frac {\alpha}{\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}</script><p>则</p>
<script type="math/tex; mode=display">
\begin {aligned}
\sigma ^{t+1}& = \frac 1 {\eta^{t+1}}-\frac 1 {\eta^t}\\
&=\frac {\beta + \sqrt {\sum_{s=1}^{t+1} (g_i^s)^2}}{\alpha}-\frac {\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}{\alpha}\\
&=\frac 1 \alpha \left ( \sqrt {\sum_{s=1}^{t+1} (g_i^s)^2}- \sqrt {\sum_{s=1}^t (g_i^s)^2}\right )
 \end{aligned}</script><p>由于用$n_i$ 记录$g_i$ 的累加和，上式可以变成</p>
<script type="math/tex; mode=display">
\sigma ^{t+1} = \sqrt {n^t+(g^{t+1})^2}-\sqrt {n^t}
\tag {3-4-7}</script><p>见③。再根据公式（3-4-6），计算$z_i$ 的值，见④。</p>
<p><strong>S3</strong>：对于$n_i$ ，根据公式（3-4-7），</p>
<script type="math/tex; mode=display">
n^{t+1} = n^t +(g^{t+1})^2</script><p>见⑤。</p>
<h3 id="2-5-5-实现代码"><a href="#2-5-5-实现代码" class="headerlink" title="2.5.5 实现代码"></a>2.5.5 实现代码</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span></span>(x: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</div><div class="line">  <span class="keyword">var</span> wTx = <span class="number">0.0</span></div><div class="line"></div><div class="line">  x foreach &#123; x =&gt;</div><div class="line">    <span class="keyword">val</span> sign = <span class="keyword">if</span> (z(x) &lt; <span class="number">0</span>) <span class="number">-1.0</span> <span class="keyword">else</span> <span class="number">1.0</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sign * z(x) &lt;= <span class="type">L1</span>)</div><div class="line">      w(x) = <span class="number">0.0</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      w(x) = (sign * <span class="type">L1</span> - z(x)) / ((beta + math.sqrt(n(x))) / alpha + <span class="type">L2</span>)</div><div class="line"></div><div class="line">    wTx = wTx + w(x)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + math.exp(-math.max(math.min(wTx, <span class="number">35.0</span>), <span class="number">-35.0</span>)))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(x: <span class="type">Array</span>[<span class="type">Int</span>], p: <span class="type">Double</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> g = p - y</div><div class="line"></div><div class="line">  x foreach &#123; x =&gt;</div><div class="line">    <span class="keyword">val</span> sigma = (math.sqrt(n(x) + g * g) - math.sqrt(n(x))) / alpha</div><div class="line">    z(x) = z(x) + g - sigma * w(x)</div><div class="line">    n(x) = n(x) + g * g</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，在更新权重时，SGD和FTRL的区别在于：</p>
<p><del>SGD在遍历每个样本的时候，都会更新所有维度的权重，而FTRL在遍历每个样本的时候只会更新样本对应维度的权重。从而可以节省训练的时间</del></p>
<p>并不是节省时间。SGD也可以用于在线学习，过拟合的限制上没有FTRL好。参数太多，会导致模型复杂度上升，容易过拟合。</p>
<h3 id="3-4-6-实验及结论"><a href="#3-4-6-实验及结论" class="headerlink" title="3.4.6 实验及结论"></a>3.4.6 实验及结论</h3><p>1、</p>
<p>训练：16-10-22的前7天数据</p>
<p>预测：16-10-22当天数据</p>
<p>维度：1048576</p>
<p>参数：默认</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc3.png" alt="roc3"></p>
<p>logloss：</p>
<p>线上方法：0.274321867859</p>
<p>FRTL：0.0326626593411</p>
<p>2、</p>
<p>训练：16-10-22的前7天数据</p>
<p>预测：16-10-22当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：1048576</p>
<p>参数：默认</p>
<p>训练时间：11:54-12:18</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc1.png" alt="roc1"></p>
<p>logloss：</p>
<p>线上方法：0.275704770725</p>
<p>FRTL：0.032281346379</p>
<p>3、</p>
<p>训练集：16-10-18的前10天数据</p>
<p>预测：16-10-18当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：4194304</p>
<p>参数：默认</p>
<p>训练时间：13:50-14:19</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc2.png" alt="roc2"></p>
<p>logloss</p>
<p>线上方法：0.073087783303</p>
<p>FTRL：0.022967801811</p>
<p>4、</p>
<p>训练集：16-10-18的前10天数据</p>
<p>预测：16-10-18当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：4194304</p>
<p>参数：训练的特征项改为1-10</p>
<p>训练时间：17:07-17:45</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc4.png" alt="roc4"></p>
<p>logloss</p>
<p>线上方法：0.073087783303</p>
<p>FTRL：0.0221369813697</p>
<p>特征权重不为0的维度有11301个</p>
<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p>FTRL在线训练时间长了效果往往会下降，因为学习率会逐渐降低，必须要offline结合online。</p>
<h1 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h1><p>【在线最优化求解(Online Optimization)-冯扬】</p>
<p>【逻辑回归从入门到精通-腾讯柳超】</p>
<p>【FTRL的理论论文】Factorization machines with follow-the-regularized-leader for CTR prediction in display advertising  <a href="http://www0.cs.ucl.ac.uk/staff/w.zhang/rtb-papers/fm-ftrl.pdf" target="_blank" rel="noopener">http://www0.cs.ucl.ac.uk/staff/w.zhang/rtb-papers/fm-ftrl.pdf</a></p>
<p>【FTRL的工程实现论文】<a href="https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf" target="_blank" rel="noopener">https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf</a> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/hadoop-spark/spark/spark-streaming笔记/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/hadoop-spark/spark/spark-streaming笔记/" class="post-title-link" itemprop="url">spark-streaming笔记</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2018-01-30 15:47:26" itemprop="dateModified" datetime="2018-01-30T15:47:26+08:00">2018-01-30</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hadoop-spark/" itemprop="url" rel="index"><span itemprop="name">hadoop-spark</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="spark-streaming的示例"><a href="#spark-streaming的示例" class="headerlink" title="spark streaming的示例"></a>spark streaming的示例</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span>   <span class="title">main</span> </span>( args : <span class="type">Array</span>[ <span class="type">String</span> ]): <span class="type">Unit</span> = &#123;</div><div class="line">         <span class="comment">//关闭一些不必要的日志</span></div><div class="line">        <span class="type">Logger</span>. getLogger ( <span class="string">"org.apache.spark"</span> ). setLevel (<span class="type">Level</span>. <span class="type">WARN</span> )</div><div class="line">        <span class="type">Logger</span>. getLogger ( <span class="string">"org.eclipse.jetty.server"</span> ). setLevel (<span class="type">Level</span>. <span class="type">OFF</span> )</div><div class="line">      </div><div class="line">         <span class="keyword">val</span>   conf  =  <span class="keyword">new</span>  <span class="type">SparkConf</span>(). setAppName ( <span class="string">"wordStreaming"</span> ). setMaster ( <span class="string">"local[2]"</span> ).</div><div class="line">         set ( <span class="string">"spark.sql.shuffle.partitions"</span> , <span class="string">"10"</span> ). set ( <span class="string">"spark.network.timeout"</span> , <span class="string">"30s"</span> )</div><div class="line">        . set ( <span class="string">"spark.shuffle.compress"</span> , <span class="string">"true"</span> ). set ( <span class="string">"spark.shuffle.spill.compress"</span> , <span class="string">"true"</span> )</div><div class="line">        . set ( <span class="string">"spark.shuffle.manager"</span> , <span class="string">"sort"</span> )</div><div class="line">         <span class="keyword">val</span>   sc  =  <span class="keyword">new</span>  <span class="type">SparkContext</span>( conf )</div><div class="line">        </div><div class="line">         <span class="comment">// 创建 StreamingContext，1 秒一个批次。这里要用 sc ，而不是 conf ，因为 sc 已经创建了</span></div><div class="line">         <span class="keyword">val</span>   ssc  =  <span class="keyword">new</span>  <span class="type">StreamingContext</span>( sc ,  <span class="type">Seconds</span> ( <span class="number">1</span> ))</div><div class="line">         <span class="comment">// 获得一个 DStream 负责连接 监听端口:地址</span></div><div class="line">         <span class="keyword">val</span>   lines  =  ssc . socketTextStream ( <span class="string">"192.168.37.129"</span> ,  <span class="number">9999</span> )</div><div class="line">         <span class="comment">// 对每一行数据执行 Split 操作</span></div><div class="line">         <span class="keyword">val</span>   words  =  lines . flatMap ( _. split ( <span class="string">" "</span> ) )</div><div class="line">         <span class="comment">// 统计 word 的数量</span></div><div class="line">         <span class="keyword">val</span>   pairs  =  words . map ( word  =&gt; ( word ,  <span class="number">1</span> ))</div><div class="line">         <span class="keyword">val</span>   wordCounts  =  pairs . reduceByKey (_  +  _)</div><div class="line">         <span class="comment">// 输出结果</span></div><div class="line">         wordCounts . print ()</div><div class="line">        </div><div class="line">         ssc . start ()</div><div class="line">         ssc . awaitTermination () &#125;</div></pre></td></tr></table></figure>
<p>一开始会报错：<br>Exception in thread “main”  org.apache.spark.SparkException : Only one SparkContext may be running in this JVM (see SPARK-2243). To ignore this error, set spark.driver.allowMultipleContexts = true. The currently running SparkContext was created at: org.apache.spark.SparkContext.<init>( SparkContext.scala:82 )</init></p>
<p>错误是在<br>val   ssc  =  new  StreamingContext( conf ,  Seconds ( 1 ))   </p>
<p>因为之前sc已经创建了，所以这里的conf要改成sc</p>
<p>之后，在 192.168.37.129上启动netcat<br>nc -lk 9999<br>输入hello world</p>
<p>再启动spark的程序，可以看出会输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Time: 1462790166000 ms</div><div class="line"></div><div class="line">(hello,1)</div><div class="line">(world,1)</div></pre></td></tr></table></figure></p>
<h1 id="streaming读取本地文件"><a href="#streaming读取本地文件" class="headerlink" title="streaming读取本地文件"></a>streaming读取本地文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val lines = ssc.textFileStream(&quot;E:\\spark&quot;)</div></pre></td></tr></table></figure>
<p>每当该文件夹内有新文件生成，就会自动读取</p>
<blockquote>
<p>Spark Streaming将会监控dataDirectory目录，并且处理目录下生成的任何文件（嵌套目录不被支持）。需要注意一下三点：<br>1 所有文件必须具有相同的数据格式<br>2 所有文件必须在<code>dataDirectory</code>目录下创建，文件是自动的移动和重命名到数据目录下<br>3 一旦移动，文件必须被修改。所以如果文件被持续的附加数据，新的数据不会被读取。<br>对于简单的文本文件，有一个更简单的方法streamingContext.textFileStream(dataDirectory)可以被调用。文件流不需要运行一个receiver，所以不需要分配核。</p>
</blockquote>
<h1 id="spark-streaming连接kafka"><a href="#spark-streaming连接kafka" class="headerlink" title="spark streaming连接kafka"></a>spark streaming连接kafka</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val topics = Set(&quot;test1&quot;)</div><div class="line">val kafkaParm = Map(&quot;metadata.broker.list&quot; -&gt; &quot;192.168.255.128:9092&quot;)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/读书/计算机程序的构造和解释/CH3/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/" class="post-title-link" itemprop="url">第三章 模块化、对象和状态</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-28 16:02:58" itemprop="dateModified" datetime="2019-06-28T16:02:58+08:00">2019-06-28</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三章-模块化、对象和状态"><a href="#第三章-模块化、对象和状态" class="headerlink" title="第三章 模块化、对象和状态"></a>第三章 模块化、对象和状态</h1><h2 id="前两章回顾"><a href="#前两章回顾" class="headerlink" title="前两章回顾"></a>前两章回顾</h2><ol>
<li>如何组合<strong>基本过程</strong>和<strong>基本数据</strong></li>
<li>如何构造各种<strong>复合对象</strong>(组合过程/数据)</li>
<li><strong>抽象</strong>在控制和处理程序复杂性中的重要作用</li>
</ol>
<blockquote>
<p>简单问题1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cons、car和cdr的含义</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>简单问题2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; ;写出以下函数的等价lambda表达式</div><div class="line">&gt; (define (add a b)</div><div class="line">&gt;   (+ a b))</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>但对于程序设计而言，上面这三种手段还不够用，有效设计大型系统，还需要一些组织系统的原则，这体现在下面两方面：</p>
<ol>
<li>只有高效算法，不足以构造出良好的大型系统</li>
<li>系统的功能分解，结构组织和管理与算法一样重要(或更甚之)</li>
</ol>
<p>在大型系统的复杂性问题上，仅学会抽象的思维还不够，还需要一些能帮我们<strong>构造模块化的大型系统的策略</strong>。在这一章，会学习两种组织策略。</p>
<ul>
<li><strong>基于对象的策略</strong></li>
</ul>
<blockquote>
<p>真实系统中的对象随着时间的进展不断变化，模拟它们的系统对象也吸引相应地变化</p>
</blockquote>
<ul>
<li><strong>基于流处理的策略</strong></li>
</ul>
<blockquote>
<p>关注流过系统的信息流</p>
</blockquote>
<h2 id="3-1-赋值和局部状态"><a href="#3-1-赋值和局部状态" class="headerlink" title="3.1 赋值和局部状态"></a>3.1 赋值和局部状态</h2><h3 id="3-1-1-局部状态变量"><a href="#3-1-1-局部状态变量" class="headerlink" title="3.1.1 局部状态变量"></a>3.1.1 局部状态变量</h3><blockquote>
<p>例子：银行取钱</p>
</blockquote>
<p>用withdraw表示该行为，入参amount表示取钱的数量，若账户有足够的钱，返回余额；否则返回Insufficient funds。</p>
<p>为了实现withdraw，我们用一个变量balance表示余额，withdraw检查balance是否够amount，如果是，</p>
<p><code>balance -= amount</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> balance <span class="number">100</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">      (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))</div><div class="line"></div><div class="line">-----------------</div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="number">50</span></div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="number">0</span></div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="string">"Insufficient funds"</span></div></pre></td></tr></table></figure>
<p>其中，set的语法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set! &lt;name&gt; &lt;new-value&gt; )</div></pre></td></tr></table></figure>
<p>begin描述对表达式的求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(begin &lt;exp1&gt;&lt;exp2&gt;...&lt;expk&gt;)</div></pre></td></tr></table></figure>
<p>按顺序求值，并返回最后一个表达式的值。</p>
<p>可以看出，这里的balance是全局变量，在哪里都能读取或修改这个值。如果将其作为局部变量，就只能通过withdraw来访问balance，这样才能更准确的模拟balance这个概念。</p>
<p>于是将其转为局部变量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> new-withdraw</div><div class="line">  (<span class="name">let</span> ((<span class="name">balance</span> <span class="number">100</span>))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))))</div></pre></td></tr></table></figure>
<p>其中，let创建一个包含局部变量的环境，并设初始值。</p>
<p>make-withdraw创建一种”提款处理器”，它的形参balance描述了有关账户的初始值。(把balance当形参传入)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>)))</div><div class="line"></div><div class="line">(<span class="name">define</span> W1 (<span class="name">make-withdraw</span> <span class="number">100</span>))</div><div class="line">(<span class="name">define</span> W2 (<span class="name">make-withdraw</span> <span class="number">100</span>))</div><div class="line"></div><div class="line">-----------------</div><div class="line">&gt; (<span class="name">W1</span> <span class="number">50</span>)</div><div class="line"><span class="number">50</span></div><div class="line">&gt; (<span class="name">W2</span> <span class="number">60</span>)</div><div class="line"><span class="number">40</span></div></pre></td></tr></table></figure>
<p>可以看出，W1和W2是完全独立的对象，每个都有自己的局部状态变量balance。</p>
<p>再创建一个存钱的对象make-account</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line"></div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) withdraw)</div><div class="line">          ((<span class="name">eq</span>? m 'deposit) deposit)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></div><div class="line">                       m))))</div><div class="line"></div><div class="line">  dispatch)</div></pre></td></tr></table></figure>
<p>对make-account的每次调用都会设置好一个带有balance的环境，在这个环境中，定义了能访问balance的过程deposit和withdraw，另外还有一个过程dispatch，它以一个字符串作为输入，返回这两个局部过程之一。</p>
<p>该过程可以这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; (define acc (make-account 100))</div><div class="line"></div><div class="line">; 对acc的每次调用将返回局部定义的过程</div><div class="line">&gt; (acc 'withdraw)</div><div class="line">#&lt;procedure:withdraw&gt;</div><div class="line"></div><div class="line">; 这个过程随后被应用于给定的amount</div><div class="line">&gt; ((acc 'withdraw) 50)</div><div class="line">50</div><div class="line"></div><div class="line">&gt; ((acc 'withdraw) 60)</div><div class="line">"Insufficient funds"</div><div class="line"></div><div class="line">&gt; ((acc 'deposit) 40)</div><div class="line">90</div><div class="line"></div><div class="line">&gt; ((acc 'withdraw) 60)</div><div class="line">30</div><div class="line"></div><div class="line">; 这样将产生另一个完全独立的对象，维护自己的局部balance</div><div class="line">&gt; (define acc2 (make-account 1000))</div></pre></td></tr></table></figure>
<h3 id="3-1-2-引进赋值带来的利益"><a href="#3-1-2-引进赋值带来的利益" class="headerlink" title="3.1.2 引进赋值带来的利益"></a>3.1.2 引进赋值带来的利益</h3><blockquote>
<p>例子：考虑设计一个过程rand，每次被调用就返回一个随机整数</p>
</blockquote>
<p>“随机”是指，对rand的反复调用将产生出一系列的数，这一序列具有均匀分布的统计性质。</p>
<p>假设现在有一个过程rand-update，如果给定一个数x1，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x2 = (rand-update x1)</div><div class="line">x3 = (rand-update x2)</div></pre></td></tr></table></figure>
<p>得到序列x1, x2, x3…将具有我们希望的性质</p>
<p>可以将rand时限为一个带局部状态变量x的过程，初始化为某个固定值random-init，对rand的每次调用算出当前x的rand-update值，返回作为随机数，并将其更新为x的新值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> random-init <span class="number">7</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rand-update</span> x)</div><div class="line">  (<span class="name">let</span> ((<span class="name">a</span> <span class="number">27</span>) (<span class="name">b</span> <span class="number">26</span>) (<span class="name">m</span> <span class="number">127</span>))</div><div class="line">    (<span class="name">modulo</span> (<span class="name">+</span> (<span class="name">*</span> a x) b) m)))</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> rand</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</div><div class="line">      x)))</div></pre></td></tr></table></figure>
<p>当然，你也可以在需要随机数的时候直接调用rand-update，生成同样的随机数序列。但缺点是，这就<strong>需要程序中任何使用随机数的地方都必须显式的记住x的值</strong>，在生成下一个时，将x的值传给rand-update作为参数。</p>
<p>考虑用随机数实现<strong><em>蒙特卡洛法</em></strong> monte-carlo</p>
<blockquote>
<p> 蒙特卡洛模拟：从总体抽取大量随机样本，并通过这些随机样本估计这一随机事件的概率，将这个概率作为问题的解。</p>
</blockquote>
<p>比如，$6/\pi^2$是随机选取的两个整数之间没有公共因子（最大公因子（greatest common divisor，GCD）是1）的概率。</p>
<p>则可以通过每次随机选择两个证书并检查它们的GCD是否为1来近似的获得这个概率，π的近似求值。（Cesaro定理）</p>
<p><a href="https://zhuanlan.zhihu.com/p/47978393" target="_blank" rel="noopener">理解黎曼猜想（二）两个自然数互质的概率是多少？</a></p>
<p>那么，这个过程的核心就是蒙特卡洛模拟（monte-carlo），<strong>它以做某个实验的次数，以及这个实现本身作为参数</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">estimate-pi</span> trials)</div><div class="line">  (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> (<span class="name">monte-carlo</span> trials cesaro-test))))</div><div class="line"></div><div class="line"><span class="comment">; Cesaro实验</span></div><div class="line">(<span class="name">define</span> (<span class="name">cesaro-test</span>)</div><div class="line">  (<span class="name">=</span> (<span class="name">gcd</span> (<span class="name">rand</span>) (<span class="name">rand</span>)) <span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">; 做某个实验的次数，以及这个实现本身作为参数</span></div><div class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> trials experiment)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</div><div class="line">           (<span class="name">/</span> trials-passed trials))</div><div class="line">          ((<span class="name">experiment</span>)</div><div class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) (<span class="name">+</span> trials-passed <span class="number">1</span>)))</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) trials-passed))))</div><div class="line">  (<span class="name">iter</span> trials <span class="number">0</span>))</div><div class="line"></div><div class="line">---------------------</div><div class="line">&gt; (<span class="name">estimate-pi</span> <span class="number">50</span>)</div><div class="line"><span class="number">2.449489742783178</span></div></pre></td></tr></table></figure>
<p>现在试一下不用rand，直接用rand-update，如果不使用赋值去模拟局部状态，则</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">random-gcd-test</span> trials initial-x)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed x)</div><div class="line">    (<span class="name">let</span> ((<span class="name">x1</span> (<span class="name">rand-update</span> x)))</div><div class="line">      (<span class="name">let</span> ((<span class="name">x2</span> (<span class="name">rand-update</span> x1)))</div><div class="line">        (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</div><div class="line">               (<span class="name">/</span> trials-passed trials))</div><div class="line">              ((<span class="name">=</span> (<span class="name">gcd</span> x1 x2) <span class="number">1</span>)</div><div class="line">               (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</div><div class="line">                     (<span class="name">+</span> trials-passed <span class="number">1</span>)</div><div class="line">                     x2))</div><div class="line">              (<span class="name">else</span></div><div class="line">                (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</div><div class="line">                      trials-passed</div><div class="line">                      x2))))))</div><div class="line">  (<span class="name">iter</span> trials <span class="number">0</span> initial-x))</div></pre></td></tr></table></figure>
<p>很明显看到区别，在上面的方法中，蒙特卡洛可以<strong>抽象出一个公共方法，不限制experiment的具体形式</strong>，而下面的方法中，由于没有随机数生成器的局部状态，random-gcd-test必须显式的操作随机数x1和x2。</p>
<p>赋值和局部变量的好处：</p>
<blockquote>
<p>从复杂计算的角度来看，其他部分都像是<strong>随着时间不断变化，而它们自己隐藏起随时间变化的内部状态</strong>（比如银行账户和随机数生成器）。因此在进行系统抽象的时候，用<strong>局部变量去模拟系统的状态</strong>，用对这些<strong>变量的赋值去模拟状态的变化</strong>。</p>
</blockquote>
<h3 id="3-1-3-引进赋值的代价"><a href="#3-1-3-引进赋值的代价" class="headerlink" title="3.1.3 引进赋值的代价"></a>3.1.3 引进赋值的代价</h3><p>只要不使用赋值，以同样参数对同意过程的两次求值<strong>一定能产生同样的效果</strong>，就像在计算数学函数。不用任何赋值的程序设计成为<strong>函数式编程</strong>。</p>
<p><em>赋值如何让事情复杂化了？</em></p>
<p>来看make-withdraw的一个简化版本，其中不再关注是否有足够余额的问题：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; The Costs of Introducing Assignment</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-simplified-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">    balance))</div><div class="line">(<span class="name">define</span> W (<span class="name">make-simplified-withdraw</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div><div class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</div><div class="line"><span class="number">-15</span></div></pre></td></tr></table></figure>
<p>如果没有set</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-decrementer</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">-</span> balance amount)))</div><div class="line">(<span class="name">define</span> D (<span class="name">make-decrementer</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>用<strong>代换模型</strong>来解释<code>make-decrementer</code>如何工作。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((<span class="name">make-decrementer</span> <span class="number">25</span>) <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="comment">; 25代替balance</span></div><div class="line">((<span class="name">lambda</span> (<span class="name">amount</span>) (<span class="name">-</span> <span class="number">25</span> amount)) <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="comment">; 应用运算符，20代替lambda中的amount</span></div><div class="line">(<span class="name">-</span> <span class="number">25</span> <span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>类似的，来看<code>make-simplified-withdraw</code>如何工作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((make-simplified-withdraw 25)   20)</div><div class="line"></div><div class="line">; 25代替balance</div><div class="line">((lambda (amount) (set! balance (- 25 amount)) 25)   20))</div><div class="line"></div><div class="line">; 20代替lambda中的amount，先将balance设为5，再返回25</div><div class="line">(set! balance (- 25 20)) 25</div></pre></td></tr></table></figure>
<p>可见这里如果用<strong>代换模型</strong>，则这个过程首先将balance设为5，再返回25，显示是有问题的。造成这种问题的根源是：</p>
<p>在代换模型中，语言的符号（如balance）就是<strong>值的名字</strong>，而一旦引进了<strong>set和变量的值可以变化</strong>的想法，一个变量就不再是一个简单的名字了。</p>
<p><strong>同一和变化</strong></p>
<p>从这里暴露出的问题，远远不是打破了一个简单的计算模型，其意义要深远得多。一旦将变化引入了我们的计算模型，许多以前非常简单明了的概念现在都变得有问题了。</p>
<p>首先考虑两个物体实际上“<strong>同一</strong>”的概念。如果一个语言在表达式里支持“同一的东西可以相互替换”的概念，这样替换不会改变表达式的值，这个语言就称为是具有<font color="#FF0033" size="5">引用透明性</font>。</p>
<p>在我们的计算机语言包含了赋值操作之后，也就打破了引用透明性，产生了<strong>副作用</strong>。</p>
<ul>
<li><strong>修改变量的值</strong></li>
<li>IO 操作，如写数据到磁盘</li>
<li>UI 操作，如修改了一个按钮的可操作状态</li>
</ul>
<p><a href="https://juejin.im/post/5a58134751882573370794cc" target="_blank" rel="noopener">引用透明性和等式推理</a></p>
<p><strong>命令式编程的缺陷</strong></p>
<p>除了引入变量和赋值导致计算模型的复杂性之外，还容易出现一些不会在函数式编程中出现的错误，比如：</p>
<p>1.2.1节的迭代求阶乘</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> product counter)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</div><div class="line">      product</div><div class="line">        <span class="comment">; 注意这里</span></div><div class="line">      (<span class="name">iter</span> (<span class="name">*</span> counter product)</div><div class="line">	    (<span class="name">+</span> counter <span class="number">1</span>))))</div><div class="line">  (<span class="name">iter</span> <span class="number">1</span> <span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>如果用命令式编程，显式的通过赋值去更新变量product和counter的值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">  (<span class="name">let</span> ((<span class="name">product</span> <span class="number">1</span>)</div><div class="line">	(<span class="name">counter</span> <span class="number">1</span>))</div><div class="line">    (<span class="name">define</span> (<span class="name">iter</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</div><div class="line">	product</div><div class="line">          <span class="comment">; 这两行的陷阱</span></div><div class="line">	(<span class="name">begin</span> (<span class="name">set!</span> product (<span class="name">*</span> counter product))</div><div class="line">	       (<span class="name">set!</span> counter (<span class="name">+</span> counter <span class="number">1</span>))</div><div class="line">	       (<span class="name">iter</span>))))</div><div class="line">    (<span class="name">iter</span>)))</div></pre></td></tr></table></figure>
<p>上述写法是正确的，但是如果颠倒其中两行的顺序</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;(set! counter (+ counter 1))</span></div><div class="line"><span class="comment">;(set! product (* counter product))</span></div></pre></td></tr></table></figure>
<p>结果就不对了。一般来说，<strong>带有赋值操作的程序强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本</strong>。</p>
<p>接下来要解决的问题就是，要给涉及赋值的表达式提供一种区别于之前的计算模型。</p>
<h2 id="3-2-求值的环境模型"><a href="#3-2-求值的环境模型" class="headerlink" title="3.2 求值的环境模型"></a>3.2 求值的环境模型</h2><p>之前说<strong>代换模型</strong>不再适用于赋值表达式。由于赋值操作的存在，此时的变量必须以某种方式指定了一个“位置”，相应的值可以存储在那里。在我们的新求值模型里，这种位置将维持在称为 <strong>环境</strong> 的结构中。</p>
<p>一些概念：</p>
<p>1）<strong>环境</strong>：<strong>框架</strong>的一个序列</p>
<p>2）<strong>框架</strong>：每个框架包含着一些 <strong>约束</strong> 的表格</p>
<p>3）<strong>约束</strong>：变量名和值相关联。（在一个框架里，任何变量至多只能有一个约束）</p>
<p>4）<strong>指针</strong>：每个框架还包含着一个<strong>指针</strong>，指向这一框架的<em>外围环境</em>。</p>
<p>5）<strong>变量</strong>：一个<em>变量</em>相对于某个特定环境的<em>值</em>，</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_1.png" alt="img"></p>
<p>​                                                                                一个简单的环境结构</p>
<p>1、2、3是三个框架，  ABCD都是环境指针，其中CD指向同一个环境。</p>
<p>环境对于求值过程是至关重要的，因为它确定了表达式求值的上下文。假设始终有一个全局环境，只包含一个框架（没有外围环境），这个环境包含所有关于基本过程的符号的值。</p>
<h3 id="3-2-1-求值规则"><a href="#3-2-1-求值规则" class="headerlink" title="3.2.1 求值规则"></a>3.2.1 求值规则</h3><p>在求值的环境模型中，过程只能通过一种方式创建，那就是通过求值一个lambda表达式。例如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">  (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p>过程定义的语法形式，不过是作为隐含lambda表达式的语法糖，等价于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> square</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_3.png" alt="img"></p>
<p>过程对象的环境部分是一个指向全局环境的指针，因此产生这个过程的lambda表达式是在全局环境中求值的。</p>
<p>这里增加了一个新约束：将过程对象约束给符号square。一般来说，<strong>define就是把一个新的约束加入到框架中</strong>。</p>
<p>假设现在对表达式<code>(square 5)</code>求值，结果是创建了一个新环境——E1。</p>
<p>1）E1从一个框架开始，这个框架包含5赋值给x的约束。</p>
<p>2）E1引出的指针表示这个框架的外围环境是全局环境</p>
<p><strong>过程应用的环境模型</strong>：</p>
<ul>
<li>将一个过程对象应用于一组实际参数，将<strong>构造出一个新框架</strong>，其中将过程的<strong>形式参数约束到调用时的实际参数</strong>，而后在构造起的这一新环境的<strong>上下文中求值过程体</strong>。这个新框架的外围环境就是作为被应用的那个过程对象的一部分的环境。</li>
<li>相对于一个给定环境<strong>求值一个 lambda表达式</strong>，将会创建起一个过程对象，这个过程对象是一个序对，由该 lambda表达式 的正文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时的环境。</li>
</ul>
<p>关于<code>set!</code>的行为方式</p>
<p>在某个环境里求值 <strong><em>赋值表达式</em></strong> 时，要求我们首先在环境中确定有关变量的约束位置，而后再修改这个约束，使之表示这个新值。</p>
<p>这也就是说，首先需要<strong>找到包含这个变量的约束的第一个框架，而后修改这一框架</strong>。如果该变量在环境中没有约束，将报告一个错误。</p>
<h3 id="3-2-2-简单过程的应用"><a href="#3-2-2-简单过程的应用" class="headerlink" title="3.2.2 简单过程的应用"></a>3.2.2 简单过程的应用</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">  (<span class="name">*</span> x x))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-of-squares</span> x y)</div><div class="line">  (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">f</span> a)</div><div class="line">  (<span class="name">sum-of-squares</span> (<span class="name">+</span> a <span class="number">1</span>) (<span class="name">*</span> a <span class="number">2</span>)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_4.png" alt="img"></p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_5.png" alt="img"></p>
<p>求值 <code>(f 5)</code>：</p>
<ol>
<li>创建一个新环境 <code>E1</code>，参数 <code>a</code> 被约束到 5。在 <code>E1</code> 中求值 <code>(sum-of-square (+ a 1) (* a2))</code></li>
<li>求值组合式，首先求值子表达式。第一个子表达式 <code>sum-of-square</code> 以一个过程对象为值。（在 <code>E1</code> 的框架中未寻找到约束，而后进入有关的外围环境，并找到约束）</li>
<li>创建环境 <code>E2</code>，现在需要把过程对象 <code>sum-of-square</code> 应用于实参 6 和 10。</li>
</ol>
<h2 id="3-3-用变动的数据做模拟"><a href="#3-3-用变动的数据做模拟" class="headerlink" title="3.3 用变动的数据做模拟"></a>3.3 用变动的数据做模拟</h2><h3 id="3-3-1-变动的表结构"><a href="#3-3-1-变动的表结构" class="headerlink" title="3.3.1 变动的表结构"></a>3.3.1 变动的表结构</h3><p>针对序对的基本改变函数是set-car!和set-cdr!。<code>set-car!</code>要求两个参数，其中第一个参数必须是一个序对。然后修改这个序对，将它的car指针替换为指向set-car!第二个参数的指针。</p>
<p>假设x是<code>((a b) c d)</code>，y是<code>(e f)</code>，执行</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190612130259772.png" alt="image-20190612130259772"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set-car! x y)</div></pre></td></tr></table></figure>
<p>修改x约束的那个表，将它的car用y的值取代。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190612130309732.png" alt="image-20190612130309732"></p>
<p><strong>共享和相等</strong></p>
<p>当不同的数据对象共享某些序对时，会产生一些问题。例如，考虑下面的结构：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> x (<span class="name">list</span> 'a 'b))</div><div class="line">(<span class="name">define</span> z1 (<span class="name">cons</span> x x))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617143714166.png" alt="image-20190617143714166"></p>
<p>这里的z1是一个序对，car和cdr都指向同一个序对x。</p>
<p>再看另一个结构</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> z2 </div><div class="line">  (<span class="name">cons</span> (<span class="name">list</span> 'a 'b) (<span class="name">list</span> 'a 'b)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617143741708.png" alt="image-20190617143741708"></p>
<p>两个表(a, b)的各个序对互不相同，虽然其中的符号是共享的。</p>
<p>作为表考虑，z1和z2表示同一个表<code>((a b) a b)</code>。一般而言，如果我们只用cons、car、cdr，z1和z2看不出差别。然而，<strong>如果允许修改表结构，共享的情况就会体现出差别</strong>。考虑下面的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">set-to-wow!</span> x)</div><div class="line">  (<span class="name">set-car!</span> (<span class="name">car</span> x) 'wow)</div><div class="line">  x)</div></pre></td></tr></table></figure>
<p>将<code>set-to-wow!</code>应用于z1和z2，将产生不同的结果。对于z1，修改car也就同时修改了cdr。而对于z2，只修改了car。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; z1</div><div class="line">((<span class="name">a</span> b) a b)</div><div class="line"></div><div class="line">&gt; (<span class="name">set-to-wow!</span> z1)</div><div class="line">((<span class="name">wow</span> b) wow b)</div><div class="line"></div><div class="line">&gt; z2</div><div class="line">((<span class="name">a</span> b) a b)</div><div class="line"></div><div class="line">&gt; (<span class="name">set-to-wow!</span> z2)</div><div class="line">((<span class="name">wow</span> b) a b)</div></pre></td></tr></table></figure>
<p>检测表结构是否共享的一种方式是使用<strong>谓词eq?</strong>。谓词<code>(eq? x y)</code>检查x和y作为指针是否相等。这样，对于z1和z2，<code>(eq? (car z1) (cdr z1))</code> 为true <code>(eq? (car z2) (cdr z2))</code> 为false。</p>
<h3 id="3-3-2-队列的表示"><a href="#3-3-2-队列的表示" class="headerlink" title="3.3.2 队列的表示"></a>3.3.2 队列的表示</h3><p>利用<code>set-car!</code> 和 <code>set-cdr!</code>，我们可以用序对构造出一些单靠cons、car、cdr无法构造的数据结构。这一节展示如何构造<strong>队列</strong>。</p>
<p>一个队列是一个序对，数据只能从一端插入（队列的尾），另一端删除（队列的首）。下面显示一个初始是空的队列，之后插入a和b，再删除a，再插入c和d，再删除b。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617145657417.png" alt="image-20190617145657417"></p>
<p>队列可以看做是由下面一组操作定义的结构：</p>
<ul>
<li>一个构造函数(make-queue) ，返回一个空队列。</li>
<li>两个选择函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(empty-queue? ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>检查队列是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(front-queue ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>返回队首的对象，如果空就报错。</p>
<ul>
<li>两个改变函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(insert-queue! ⟨queue⟩ ⟨item⟩)</div></pre></td></tr></table></figure>
<p>插入队尾，返回修改后的队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(delete-queue! ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>删除队首对象，返回修改后的队列。</p>
<p>队列可以表示成一个常规的表，用car、cdr来完成上述操作。但是效率很低，为了插入一个数据项，需要扫描整个表，有<code>O(n)</code>的时间复杂度。那么简单修改一下表的表示方式，就可以只需<code>O(1)</code>的时间复杂度。方法就是加入一个指向队列尾的指针，这里就有两个指针<code>front-ptr</code> 和<code>rear-ptr</code>。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617155741378.png" alt="image-20190617155741378"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">front-ptr</span> queue) (<span class="name">car</span> queue))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rear-ptr</span> queue) (<span class="name">cdr</span> queue))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-front-ptr!</span> queue item) </div><div class="line">  (<span class="name">set-car!</span> queue item))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-rear-ptr!</span> queue item) </div><div class="line">  (<span class="name">set-cdr!</span> queue item))</div></pre></td></tr></table></figure>
<p>现在来实现队列的其他操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(define (empty-queue? queue) </div><div class="line">  (null? (front-ptr queue)))</div><div class="line">  </div><div class="line">(define (make-queue) (cons '() '()))</div><div class="line"></div><div class="line">(define (front-queue queue)</div><div class="line">  (if (empty-queue? queue)</div><div class="line">      (error "FRONT called with an </div><div class="line">              empty queue" queue)</div><div class="line">      (car (front-ptr queue))))</div></pre></td></tr></table></figure>
<p>如果要插入一个对象，按照下图的方式，</p>
<p>1）创建一个新队列，car是需要插入的项，cdr是空表。</p>
<p>2）若队列原来是空，就让<code>front-ptr</code> 和<code>rear-ptr</code>共同指向新序对。否则就修改rear-ptr，而指向新序对。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617162453179.png" alt="image-20190617162453179"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert-queue!</span> queue item)</div><div class="line">  (<span class="name">let</span> ((<span class="name">new-pair</span> (<span class="name">cons</span> item '())))</div><div class="line">    (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">           (<span class="name">set-front-ptr!</span> queue new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue)</div><div class="line">          (<span class="name">else</span> (<span class="name">set-cdr!</span> (<span class="name">rear-ptr</span> queue) </div><div class="line">                          new-pair)</div><div class="line">                (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">                queue))))</div></pre></td></tr></table></figure>
<p>要删除对象，就修改front-ptr，指向第二个数据项。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(define (delete-queue! queue)</div><div class="line">  (cond ((empty-queue? queue)</div><div class="line">         (error "DELETE! called with </div><div class="line">                 an empty queue" queue))</div><div class="line">        (else (set-front-ptr! </div><div class="line">               queue </div><div class="line">               (cdr (front-ptr queue)))</div><div class="line">              queue)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617165406898.png" alt="image-20190617165406898"></p>
<h3 id="3-3-3-表格的表示"><a href="#3-3-3-表格的表示" class="headerlink" title="3.3.3 表格的表示"></a>3.3.3 表格的表示</h3><p>首先考虑一维表格的问题，每个记录实现为key和value的序对。这些记录连接起来就构成一个序对的表。为了向表格里面插入记录时有可以修改的位置，将这种表格构造为一种<strong>带有表头单元的表</strong>。表开头有一个“哑”记录——存放一个特殊符号，<code>*table*</code>。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617170617702.png" alt="image-20190617170617702"></p>
<p>为了从表格中提取信息，定义lookup过程，以key为参数，返回value。lookup基于assoc定义。assoc返回key的那条记录。lookup检查assoc返回的记录是否为假，而后返回value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">cdr</span> record)</div><div class="line">        false)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">assoc</span> key records)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? records) false)</div><div class="line">        ((<span class="name">equal</span>? key (<span class="name">caar</span> records)) </div><div class="line">         (<span class="name">car</span> records))</div><div class="line">        (<span class="name">else</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> records)))))</div></pre></td></tr></table></figure>
<p>如果是插入操作，</p>
<p>1）首先用assoc检查表格中是否有这个key，如果没有，就cons这个key和value，构造出一个新记录。接着插入到表的最前面，位于哑记录之后。</p>
<p>2）如果表格中存在这个记录，就用该记录的cdr设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">set-cdr!</span> record value)</div><div class="line">        (<span class="name">set-cdr!</span> table</div><div class="line">                  (<span class="name">cons</span> (<span class="name">cons</span> key value) </div><div class="line">                        (<span class="name">cdr</span> table)))))</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<p>在构造一个新表时，只需创建起一个包含符号<code>*table*</code>的表。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</div><div class="line">  (<span class="name">list</span> '*table*))</div></pre></td></tr></table></figure>
<p><strong>二维表格</strong></p>
<p>二维表格的每个值用两个key索引。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/../../../../../../Desktop/image-20190617172806860.png" alt="image-20190617172806860"></p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617172821310.png" alt="image-20190617172821310"></p>
<p>二维表的查询。先用第一个key确定对应的子表格，而后用第二个key确定value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key-1 key-2 table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> subtable</div><div class="line">        (<span class="name">let</span> ((<span class="name">record</span> </div><div class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</div><div class="line">          (<span class="name">if</span> record (<span class="name">cdr</span> record) false))</div><div class="line">        false)))</div></pre></td></tr></table></figure>
<p>二维表的插入。首先用assoc查看key-1是否有一个子表格，没有就构造，其中只包含一个记录<code>(key-2, value)</code>。若有，就将新值插入该子表格。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key-1 key-2 value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> subtable</div><div class="line">        (<span class="name">let</span> ((<span class="name">record</span> </div><div class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</div><div class="line">          (<span class="name">if</span> record</div><div class="line">              (<span class="name">set-cdr!</span> record value)</div><div class="line">              (<span class="name">set-cdr!</span> </div><div class="line">               subtable</div><div class="line">               (<span class="name">cons</span> (<span class="name">cons</span> key-2 value)</div><div class="line">                     (<span class="name">cdr</span> subtable)))))</div><div class="line">        (<span class="name">set-cdr!</span> </div><div class="line">         table</div><div class="line">         (<span class="name">cons</span> (<span class="name">list</span> key-1 (<span class="name">cons</span> key-2 value))</div><div class="line">               (<span class="name">cdr</span> table)))))</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<p><strong>创建局部表格</strong></p>
<p>上述的lookup和insert!都以整个表格为参数，这也使我们可以将它们用到包含多个表格的程序中。处理多个表格的方式是为每个表格提供一对独立的lookup和insert！过程。</p>
<p>实现的方案是，用过程表示表格，将表格表示为一个以局部状态的方式维持一个内部表格的对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">(define (make-table)</div><div class="line">  (let ((local-table (list '*table*)))</div><div class="line">    (define (lookup key-1 key-2)</div><div class="line">      (let ((subtable </div><div class="line">             (assoc key-1 (cdr local-table))))</div><div class="line">        (if subtable</div><div class="line">            (let ((record </div><div class="line">                   (assoc key-2 </div><div class="line">                          (cdr subtable))))</div><div class="line">              (if record (cdr record) false))</div><div class="line">            false)))</div><div class="line">    (define (insert! key-1 key-2 value)</div><div class="line">      (let ((subtable </div><div class="line">             (assoc key-1 (cdr local-table))))</div><div class="line">        (if subtable</div><div class="line">            (let ((record </div><div class="line">                   (assoc key-2 </div><div class="line">                          (cdr subtable))))</div><div class="line">              (if record</div><div class="line">                  (set-cdr! record value)</div><div class="line">                  (set-cdr! </div><div class="line">                   subtable</div><div class="line">                   (cons (cons key-2 value)</div><div class="line">                         (cdr subtable)))))</div><div class="line">            (set-cdr! </div><div class="line">             local-table</div><div class="line">             (cons (list key-1</div><div class="line">                         (cons key-2 value))</div><div class="line">                   (cdr local-table)))))</div><div class="line">      'ok)</div><div class="line">    (define (dispatch m)</div><div class="line">      (cond ((eq? m 'lookup-proc) lookup)</div><div class="line">            ((eq? m 'insert-proc!) insert!)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          TABLE" m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure>
<p>利用make-table，我们可以实现get和put操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> operation-table (<span class="name">make-table</span>))</div><div class="line">(<span class="name">define</span> get (<span class="name">operation-table</span> 'lookup-proc))</div><div class="line">(<span class="name">define</span> put (<span class="name">operation-table</span> 'insert-proc!))</div></pre></td></tr></table></figure>
<p>这两个操作都访问同一个局部表格，这一表格被封装在由对make-table的调用创建起的对象里面。</p>
<h3 id="3-3-4-数字电路的模拟器"><a href="#3-3-4-数字电路的模拟器" class="headerlink" title="3.3.4 数字电路的模拟器"></a>3.3.4 数字电路的模拟器</h3><p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618100752926.png" alt="image-20190618100752926"></p>
<p>连接基本组件来构造更复杂的功能。比如下面的<strong>半加器</strong>电路，包括一个或门，两个与门和一个非门。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618101130329.png" alt="image-20190618101130329"></p>
<p>当A=1或B=1之一是1时，S=1，当A=1且B=1时，C=1。</p>
<blockquote>
<p><strong>半加器</strong></p>
<p>半加器是实现两个一位二进制数加法运算的器件。它具有两个输入端(被加数A和加数B)及输出端Y。 [1] </p>
<p>A和B是相加的两个数，S是半加和数，C是进位数。</p>
<p>所谓半加就是不考虑进位的加法，它的真值表如下 (见表)：</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618103146103.png" alt="image-20190618103146103"></p>
</blockquote>
<p>现在要构造一个程序来模拟数字逻辑电路。最基本元素是make-wire，用于构造连线。比如可以构造出</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> a (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> b (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> c (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> d (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> e (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> s (<span class="name">make-wire</span>))</div></pre></td></tr></table></figure>
<p>如果需要把一个功能连到一组连线上，就调用一个构造这类功能的过程，参数就是连线。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">or-gate</span> a b d)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">and-gate</span> a b c)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">inverter</span> c e)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">and-gate</span> d e s)</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>再拼接成<strong>半加器</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">half-adder</span> a b s c)</div><div class="line">  (<span class="name">let</span> ((<span class="name">d</span> (<span class="name">make-wire</span>)) (<span class="name">e</span> (<span class="name">make-wire</span>)))</div><div class="line">    (<span class="name">or-gate</span> a b d)</div><div class="line">    (<span class="name">and-gate</span> a b c)</div><div class="line">    (<span class="name">inverter</span> c e)</div><div class="line">    (<span class="name">and-gate</span> d e s)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<p>在这个基础上，可以再构建<strong>全加器</strong>。</p>
<blockquote>
<p><strong>全加器</strong></p>
<p>全加器能进行加数、被加数和低位来的进位信号相加，并根据求和结果给出该位的进位信号。</p>
<p>当多位数相加时，半加器可用于最低位求和，并给出进位数。第二位的相加有两个待加数和，还有一个来自前面低位送来的进位数。这三个数相加，得出本位和数（全加和数）和进位数。这种就是“全加“，下表为全加器的逻辑状态表。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/o4YBAFtYGTaAfKmzAAAvuawUHgA437.png" alt="åå å¨åå¨å å¨çåçååºå«ï¼ç»æååè½ï¼"></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">full-adder</span> a b c-in sum c-out)</div><div class="line">  (<span class="name">let</span> ((<span class="name">c1</span> (<span class="name">make-wire</span>)) </div><div class="line">        (<span class="name">c2</span> (<span class="name">make-wire</span>))</div><div class="line">        (<span class="name">s</span>  (<span class="name">make-wire</span>)))</div><div class="line">    (<span class="name">half-adder</span> b c-in s c1)</div><div class="line">    (<span class="name">half-adder</span> a s sum c2)</div><div class="line">    (<span class="name">or-gate</span> c1 c2 c-out)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618113425796.png" alt="image-20190618113425796"></p>
<p>从模拟器的角度，各种功能块构成了基础，将功能块连接起来就是这里的组合方法，而将特定的连接模式定义为过程就是这里的抽象方法。</p>
<h4 id="基本功能块"><a href="#基本功能块" class="headerlink" title="基本功能块"></a><strong>基本功能块</strong></h4><p>基本功能块使得在一根连线上的信号变化能够影响其他连线上的信号。我们添加如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(get-signal ⟨wire⟩)</div></pre></td></tr></table></figure>
<p>返回连线上信号的当前值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set-signal! ⟨wire⟩ ⟨new value⟩)</div></pre></td></tr></table></figure>
<p>将连线上信号修改为新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)</div></pre></td></tr></table></figure>
<p>改变信号值就需要执行该过程。这种过程是一些媒介，能够将相应连线上值的变化传递到其他的连线。</p>
<p>利用这些过程，可以定义基本的数字逻辑功能了。为了把输入通过一个反门连接到输出，用add-action! 为输入关联一个过程，当输入路线的值改变时，执行这一过程。</p>
<p>先看<strong>非门</strong>，在一个inverter-delay后将输出线路设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">inverter</span> input output)</div><div class="line">  (<span class="name">define</span> (<span class="name">invert-input</span>)</div><div class="line">    (<span class="name">let</span> ((<span class="name">new-value</span> </div><div class="line">           (<span class="name">logical-not</span> (<span class="name">get-signal</span> input))))</div><div class="line">      (<span class="name">after-delay</span> </div><div class="line">       inverter-delay</div><div class="line">       (<span class="name">lambda</span> ()</div><div class="line">         (<span class="name">set-signal!</span> output new-value)))))</div><div class="line">  </div><div class="line">  (<span class="name">add-action!</span> input invert-input)</div><div class="line">  'ok)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">logical-not</span> s)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> s <span class="number">0</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">=</span> s <span class="number">1</span>) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s))))</div></pre></td></tr></table></figure>
<p>下面是<strong>与门</strong>的定义。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">and-gate</span> a1 a2 output)</div><div class="line">  (<span class="name">define</span> (<span class="name">and-action-procedure</span>)</div><div class="line">    (<span class="name">let</span> ((<span class="name">new-value</span></div><div class="line">           (<span class="name">logical-and</span> (<span class="name">get-signal</span> a1) </div><div class="line">                        (<span class="name">get-signal</span> a2))))</div><div class="line">      (<span class="name">after-delay</span> </div><div class="line">       and-gate-delay</div><div class="line">       (<span class="name">lambda</span> ()</div><div class="line">         (<span class="name">set-signal!</span> output new-value)))))</div><div class="line">  </div><div class="line">  (<span class="name">add-action!</span> a1 and-action-procedure)</div><div class="line">  (<span class="name">add-action!</span> a2 and-action-procedure)</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<h4 id="线路的表示"><a href="#线路的表示" class="headerlink" title="线路的表示"></a><strong>线路的表示</strong></h4><p>一条线路是一个具有两个局部状态变量的计算对象：一个是信号值signal-value（初值为0），一个是一组过程action-procedures，在信号值改变时，这些过程需要运行。类似于在3.1.1中处理银行账户的做法实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(define (make-wire)</div><div class="line">  (let ((signal-value 0) </div><div class="line">        (action-procedures '()))</div><div class="line">       </div><div class="line">    (define (set-my-signal! new-value)</div><div class="line">      (if (not (= signal-value new-value))</div><div class="line">          (begin (set! signal-value new-value)</div><div class="line">                 (call-each </div><div class="line">                  action-procedures))</div><div class="line">          'done))</div><div class="line">       </div><div class="line">    (define (accept-action-procedure! proc)</div><div class="line">      (set! action-procedures </div><div class="line">            (cons proc action-procedures))</div><div class="line">      (proc))</div><div class="line">       </div><div class="line">    (define (dispatch m)</div><div class="line">      (cond ((eq? m 'get-signal) </div><div class="line">             signal-value)</div><div class="line">            ((eq? m 'set-signal!) </div><div class="line">             set-my-signal!)</div><div class="line">            ((eq? m 'add-action!) </div><div class="line">             accept-action-procedure!)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          WIRE" m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure>
<p><code>set-my-signal!</code>检查新的信号值是否实际改变了线路上的信号，如果是，就用<code>call-each</code>运行每个动作过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">call-each</span> procedures)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? procedures)</div><div class="line">      'done</div><div class="line">      (<span class="name">begin</span> ((<span class="name">car</span> procedures))</div><div class="line">             (<span class="name">call-each</span> (<span class="name">cdr</span> procedures)))))</div></pre></td></tr></table></figure>
<p>一旦设置好dispatch过程，就可以提供以下访问线路中局部操作的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">get-signal</span> wire)</div><div class="line">  (<span class="name">wire</span> 'get-signal))</div><div class="line">(<span class="name">define</span> (<span class="name">set-signal!</span> wire new-value)</div><div class="line">  ((<span class="name">wire</span> 'set-signal!) new-value))</div><div class="line">(<span class="name">define</span> (<span class="name">add-action!</span> wire action-procedure)</div><div class="line">  ((<span class="name">wire</span> 'add-action!) action-procedure))</div></pre></td></tr></table></figure>
<h4 id="待处理表agenda"><a href="#待处理表agenda" class="headerlink" title="待处理表agenda"></a><strong>待处理表agenda</strong></h4><p>最后是after-delay的实现。要维护一个称为待处理表的数据结构，包含需要完成的事项清单。定义如下操作：</p>
<ul>
<li><code>(make-agenda)</code> 返回一个新的空agenda.</li>
<li><code>(empty-agenda? ⟨agenda⟩)</code> .</li>
<li><code>(first-agenda-item ⟨agenda⟩)</code> 返回agenda第一个item.</li>
<li><code>(remove-first-agenda-item! ⟨agenda⟩)</code> .</li>
<li><code>(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)</code> </li>
<li><code>(current-time ⟨agenda⟩)</code> 返回当时的模拟时间。</li>
</ul>
<p>用<code>the-agenda</code>表示特定的待处理表。以下过程向<code>the-agenda</code>中插入一个新item</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">after-delay</span> delay action)</div><div class="line">  (<span class="name">add-to-agenda!</span> </div><div class="line">   (<span class="name">+</span> delay (<span class="name">current-time</span> the-agenda))</div><div class="line">   action</div><div class="line">   the-agenda))</div></pre></td></tr></table></figure>
<p>agenda中的模拟过程用propagate实现，它操作<code>the-agenda</code>，顺序执行agenda的每个过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">propagate</span>)</div><div class="line">  (<span class="name">if</span> (<span class="name">empty-agenda</span>? the-agenda)</div><div class="line">      'done</div><div class="line">      (<span class="name">let</span> ((<span class="name">first-item</span> </div><div class="line">             (<span class="name">first-agenda-item</span> the-agenda)))</div><div class="line">        (<span class="name">first-item</span>)</div><div class="line">        (<span class="name">remove-first-agenda-item!</span> the-agenda)</div><div class="line">        (<span class="name">propagate</span>))))</div></pre></td></tr></table></figure>
<h4 id="一个简单的实例模拟"><a href="#一个简单的实例模拟" class="headerlink" title="一个简单的实例模拟"></a>一个简单的实例模拟</h4><p>下面过程将一个<strong>监测器</strong>放到一个线路上，用于显示模拟器的活动。这一过程会告诉相应线路，只要它的值改变了，就打印出新的值，同时打印当前时间和线路名称。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">probe</span> name wire)</div><div class="line">  (<span class="name">add-action!</span> </div><div class="line">   wire</div><div class="line">   (<span class="name">lambda</span> ()</div><div class="line">     (<span class="name">newline</span>)</div><div class="line">     (<span class="name">display</span> name)</div><div class="line">     (<span class="name">display</span> <span class="string">" "</span>)</div><div class="line">     (<span class="name">display</span> (<span class="name">current-time</span> the-agenda))</div><div class="line">     (<span class="name">display</span> <span class="string">"  New-value = "</span>)</div><div class="line">     (<span class="name">display</span> (<span class="name">get-signal</span> wire)))))</div></pre></td></tr></table></figure>
<p>我们从初始化待处理表和描述各种功能块的延时开始</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> the-agenda (<span class="name">make-agenda</span>))</div><div class="line">(<span class="name">define</span> inverter-delay <span class="number">2</span>)</div><div class="line">(<span class="name">define</span> and-gate-delay <span class="number">3</span>)</div><div class="line">(<span class="name">define</span> or-gate-delay <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>现在定义4条线路，在其中两条线路上安装监测器</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> input-1 (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> input-2 (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> sum (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> carry (<span class="name">make-wire</span>))</div><div class="line"></div><div class="line">(<span class="name">probe</span> 'sum sum)</div><div class="line">sum <span class="number">0</span>  New-value = <span class="number">0</span></div><div class="line"></div><div class="line">(<span class="name">probe</span> 'carry carry)</div><div class="line">carry <span class="number">0</span>  New-value = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>然后将这些线路连接到一个半加器电路上</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">half-adder</span> input-1 input-2 sum carry)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">set-signal!</span> input-1 <span class="number">1</span>)</div><div class="line">done</div><div class="line"></div><div class="line">(<span class="name">propagate</span>)</div><div class="line">sum <span class="number">8</span>  New-value = <span class="number">1</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>在时间8, sum上的信号变为1。现在到了模拟开始之后的8个时间单位。在这一点上，我们可 以将input-2上的信号设置为1，并让有关的值向前传播：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">set-signal!</span> input-2 <span class="number">1</span>)</div><div class="line">done</div><div class="line"></div><div class="line">(<span class="name">propagate</span>)</div><div class="line">carry <span class="number">11</span>  New-value = <span class="number">1</span></div><div class="line">sum <span class="number">16</span>  New-value = <span class="number">0</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>在时间11处，carry变成1，16处sum变成0。</p>
<h4 id="agenda的实现"><a href="#agenda的实现" class="headerlink" title="agenda的实现"></a>agenda的实现</h4><p>这种待处理表由一些时间段组成，每个时间段是由一个数值（表示时间）和一个队列(见练习3.32)组成的序对，在这个队列里，保存着那些已经安排好的，应该在这一时间段运行的过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-time-segment</span> time queue)</div><div class="line">  (<span class="name">cons</span> time queue))</div><div class="line">(<span class="name">define</span> (<span class="name">segment-time</span> s) (<span class="name">car</span> s))</div><div class="line">(<span class="name">define</span> (<span class="name">segment-queue</span> s) (<span class="name">cdr</span> s))</div></pre></td></tr></table></figure>
<p>我们将用3.3.2节描述的队列操作完成在时间段队列上的操作。<br>待处理表本身就是时间段的一个一维表格。与3.3.3节所示的表格的不同之处，就在于这 些时间段应该按照时间递增的顺序排列。此外，我们还需在待处理表的头部保存一个当前时 间（即，此前最后被处理的那个动作的时间）。一个新构造出的待处理表里没有时间段，其当前时间是0。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-agenda</span>) (<span class="name">list</span> <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">current-time</span> agenda) (<span class="name">car</span> agenda))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-current-time!</span> agenda time)</div><div class="line">  (<span class="name">set-car!</span> agenda time))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">segments</span> agenda) (<span class="name">cdr</span> agenda))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-segments!</span> agenda segments)</div><div class="line">  (<span class="name">set-cdr!</span> agenda segments))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">first-segment</span> agenda) </div><div class="line">  (<span class="name">car</span> (<span class="name">segments</span> agenda)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rest-segments</span> agenda) </div><div class="line">  (<span class="name">cdr</span> (<span class="name">segments</span> agenda)))</div></pre></td></tr></table></figure>
<p>若一个agenda没有时间段，那它就是空的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">empty-agenda</span>? agenda)</div><div class="line">  (<span class="name">null</span>? (<span class="name">segments</span> agenda)))</div></pre></td></tr></table></figure>
<p>为了将一个动作加入待处理表，</p>
<p>1）我们首先要检査这个待处理表是否为空。如果真是这样，那么就<strong>创建一个新的时间段</strong>，并将这个时间段装入待处理表里。</p>
<p>2）否则我们就扫描整个的待处理表，检査其中各个时间段的时间。如果发现某个时间段具有合适的时间，那么就把这个动作加入与之关联的队列里。如果碰到了某个比需要预约的时间更晚的时间，那么就将一个新的时间段插入待处理表，插入这个位置之前。如果到达了待处理表的末尾，我们就必须在最后加上一个新的时间段。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-to-agenda!</span> time action agenda)</div><div class="line">  (<span class="name">define</span> (<span class="name">belongs-before</span>? segments)</div><div class="line">    (<span class="name">or</span> (<span class="name">null</span>? segments)</div><div class="line">        (<span class="name">&lt;</span> time </div><div class="line">           (<span class="name">segment-time</span> (<span class="name">car</span> segments)))))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">make-new-time-segment</span> time action)</div><div class="line">    (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">make-queue</span>)))</div><div class="line">      (<span class="name">insert-queue!</span> q action)</div><div class="line">      (<span class="name">make-time-segment</span> time q)))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">add-to-segments!</span> segments)</div><div class="line">    (<span class="name">if</span> (<span class="name">=</span> (<span class="name">segment-time</span> (<span class="name">car</span> segments)) time)</div><div class="line">        (<span class="name">insert-queue!</span> </div><div class="line">         (<span class="name">segment-queue</span> (<span class="name">car</span> segments))</div><div class="line">         action)</div><div class="line">        (<span class="name">let</span> ((<span class="name">rest</span> (<span class="name">cdr</span> segments)))</div><div class="line">          (<span class="name">if</span> (<span class="name">belongs-before</span>? rest)</div><div class="line">              (<span class="name">set-cdr!</span></div><div class="line">               segments</div><div class="line">               (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </div><div class="line">                      time </div><div class="line">                      action)</div><div class="line">                     (<span class="name">cdr</span> segments)))</div><div class="line">              (<span class="name">add-to-segments!</span> rest)))))</div><div class="line">  (<span class="name">let</span> ((<span class="name">segments</span> (<span class="name">segments</span> agenda)))</div><div class="line">    (<span class="name">if</span> (<span class="name">belongs-before</span>? segments)</div><div class="line">        (<span class="name">set-segments!</span></div><div class="line">         agenda</div><div class="line">         (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </div><div class="line">                time </div><div class="line">                action)</div><div class="line">               segments))</div><div class="line">        (<span class="name">add-to-segments!</span> segments))))</div></pre></td></tr></table></figure>
<p>从待处理表中<strong>删除第一项</strong>的过程，应该删去第一个时间段的队列前端的那一项。如果删 除使这个时间段变空了，我们就将这个时间段也从时间段的表里删去:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">remove-first-agenda-item!</span> agenda)</div><div class="line">  (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">segment-queue</span> </div><div class="line">            (<span class="name">first-segment</span> agenda))))</div><div class="line">    (<span class="name">delete-queue!</span> q)</div><div class="line">    (<span class="name">if</span> (<span class="name">empty-queue</span>? q)</div><div class="line">        (<span class="name">set-segments!</span> </div><div class="line">         agenda </div><div class="line">         (<span class="name">rest-segments</span> agenda)))))</div></pre></td></tr></table></figure>
<p>找出待处理表中里第一项，也就是找出其第一个时间段队列里的第一项。无论何时提取 这个项时，都需要更新待处理表的当前时间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(define (first-agenda-item agenda)</div><div class="line">  (if (empty-agenda? agenda)</div><div class="line">      (error "Agenda is empty: </div><div class="line">              FIRST-AGENDA-ITEM")</div><div class="line">      (let ((first-seg </div><div class="line">             (first-segment agenda)))</div><div class="line">        (set-current-time! </div><div class="line">         agenda </div><div class="line">         (segment-time first-seg))</div><div class="line">        (front-queue </div><div class="line">         (segment-queue first-seg)))))</div></pre></td></tr></table></figure>
<h3 id="3-3-5-约束的传播"><a href="#3-3-5-约束的传播" class="headerlink" title="3.3.5 约束的传播"></a>3.3.5 约束的传播</h3><p>在传统上，<strong>计算机程序总被组织成一种单向的计算，它们对一些事先给定的参数执行某些操作，产生出所需要的输出。</strong>但在另一方面，我们也经常需要模拟一些<strong>由各种量之间的关系描述的系统</strong>。例如，某个机械结构的数学模型里可能包含着这样的一些信息：在一个金属杆的偏转量d与作用于这个杆的力F、杆的长度L、截面面积A和弹性模数之间的关系可以由下面方程描述</p>
<script type="math/tex; mode=display">
dAE=FL</script><p>这种关系并不是单向的，<strong>给定了其中任意的4个量，我们就可以利用它计算出第5个量</strong>。然而，<strong>要将这种方程翻译到传统的程序设计语言，就会迫使我们选出一个量，要求基于另外的4个量去计算出它</strong>。这样，一个用于计算面积A的过程将不能用于计算偏转量。虽然对于A和d的计算都出自这同一个方程。</p>
<p>在这一节里，我们要描绘一种语言的设计，这种语言将使我们可以基于各种关系进行工作。这一语言里的基本元素就是基本约束，它们描述了在不同量之间的某种特定关系。例如，<code>(adder a b c)</code>描述的是量a、b和c之间必须有关系$a+b=c$，<code>(multiplier x y z)</code>描述的是约束关系$xy=z$，而<code>(constant 3.14 x)</code>表示x的值永远都是3.14。</p>
<p>我们的语言里还提供了一些方法，使它们可以用于组合各种基本约束，以便去描述更复杂的关系。在这里，我们将通过构造<strong>约束网络</strong>的方式组合起各种约束，在这种约束网络里，约束通过<strong>连接器</strong>连接起来。连接器是一种对象，它们可以“保存”一个值，使之能参与一个<br>或者多个约束。例如，我们知道在华氏温度和摄氏温度之间的关系是：</p>
<script type="math/tex; mode=display">
9C=5(F-32)</script><p>这样的约束就可以看做是一个网络。通过基本<strong>加法约束</strong>、<strong>乘法约束</strong>和<strong>常量约束</strong>组成。在这个图里，我们看到左边的乘法块有三个引线，分别标记为 m1 、 m2 和p。该乘法约束的这些引线以如下方式连接到网络的其他部分：引线 m1连到连接器 C ，这个连接器将保存摄氏温度。引线 m2 接在连接器 w ，该连接器还连接着一个保存常量 9 的约束块。引线 p 被这一乘法块约束到 m1和 m2 的乘积，它还连接到另一个乘法块的引线p。另一乘法块的 m2连接到常量 5 ，它的 m1 连接到另一加法块的一条引线上。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618163207055.png" alt="image-20190618163207055"></p>
<h4 id="约束系统的使用"><a href="#约束系统的使用" class="headerlink" title="约束系统的使用"></a>约束系统的使用</h4><p>首先调用构造函数make-connector，创建起两个连接器C和F</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> C (<span class="name">make-connector</span>))</div><div class="line">(<span class="name">define</span> F (<span class="name">make-connector</span>))</div><div class="line">(<span class="name">celsius-fahrenheit-converter</span> C F)</div><div class="line">ok</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">celsius-fahrenheit-converter</span> c f)</div><div class="line">  (<span class="name">let</span> ((<span class="name">u</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">v</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">w</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">x</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">y</span> (<span class="name">make-connector</span>)))</div><div class="line">    (<span class="name">multiplier</span> c w u)</div><div class="line">    (<span class="name">multiplier</span> v x u)</div><div class="line">    (<span class="name">adder</span> v y f)</div><div class="line">    (<span class="name">constant</span> <span class="number">9</span> w)</div><div class="line">    (<span class="name">constant</span> <span class="number">5</span> x)</div><div class="line">    (<span class="name">constant</span> <span class="number">32</span> y)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<h4 id="约束系统的实现"><a href="#约束系统的实现" class="headerlink" title="约束系统的实现"></a>约束系统的实现</h4><p>类似于数字电路模拟器。虽然约束系统里的基本对象在某些方面更复杂一些,但整个系统却更为简单,因为这里完全不需要关心待处理表和时间延迟等等问题。</p>
<p>连接器的基本操作包括</p>
<ul>
<li><code>(has-value? ⟨connector⟩)</code> .</li>
<li><code>(get-value ⟨connector⟩)</code> .</li>
<li><code>(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)</code> </li>
<li><code>(forget-value! ⟨connector⟩ ⟨retractor⟩)</code> 要求连接器忘记改值。</li>
<li><code>(connect ⟨connector⟩ ⟨new-constraint⟩)</code> 通过连接器参与一个新约束。</li>
</ul>
<p>通过<code>inform-about-value</code>与各个相关约束通信，这一过程告知给定的约束，该连接器有了新值。而<code>inform-about-no-value</code>告知该连接器丧失了原有的值。</p>
<p><code>adder</code>在被求和连接器a1和a2和连接器sum之间构造出一个加法约束。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">; adder将一个新的加法约束连接到指定连接器。me就代表那个加法约束。</div><div class="line">(define (adder a1 a2 sum)</div><div class="line">  ; 当加法约束得到了通知，知道自己的一个连接器有了新值后，process-new-value就会被调用。</div><div class="line">  (define (process-new-value)</div><div class="line">    (cond ((and (has-value? a1) </div><div class="line">                (has-value? a2))</div><div class="line">           (set-value! sum</div><div class="line">                       (+ (get-value a1) </div><div class="line">                          (get-value a2))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? a1) </div><div class="line">                (has-value? sum))</div><div class="line">           (set-value! a2</div><div class="line">                       (- (get-value sum) </div><div class="line">                          (get-value a1))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? a2) </div><div class="line">                (has-value? sum))</div><div class="line">           (set-value! a1</div><div class="line">                       (- (get-value sum) </div><div class="line">                          (get-value a2))</div><div class="line">                       me))))</div><div class="line">  ; 如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行process-new-value。</div><div class="line">  (define (process-forget-value)</div><div class="line">    (forget-value! sum me)</div><div class="line">    (forget-value! a1 me)</div><div class="line">    (forget-value! a2 me)</div><div class="line">    (process-new-value))</div><div class="line">  </div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else (error "Unknown request: </div><div class="line">                        ADDER" request))))</div><div class="line">  (connect a1 me)</div><div class="line">  (connect a2 me)</div><div class="line">  (connect sum me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<p><code>adder</code>将一个新的加法约束连接到指定连接器。<code>me</code>就代表那个加法约束。</p>
<p>当加法约束得到了通知，知道自己的一个连接器有了新值后，<code>process-new-value</code>就会被调用。</p>
<p>如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行<code>process-new-value</code>。</p>
<p>乘法对象类似于加法对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">(define (multiplier m1 m2 product)</div><div class="line">  </div><div class="line">  (define (process-new-value)</div><div class="line">    (cond ((or (and (has-value? m1) </div><div class="line">                    (= (get-value m1) 0))</div><div class="line">               (and (has-value? m2) </div><div class="line">                    (= (get-value m2) 0)))</div><div class="line">           (set-value! product 0 me))</div><div class="line">          ((and (has-value? m1) </div><div class="line">                (has-value? m2))</div><div class="line">           (set-value! product</div><div class="line">                       (* (get-value m1) </div><div class="line">                          (get-value m2))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? product) </div><div class="line">                (has-value? m1))</div><div class="line">           (set-value! m2</div><div class="line">                       (/ (get-value product) </div><div class="line">                          (get-value m1))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? product) </div><div class="line">                (has-value? m2))</div><div class="line">           (set-value! m1</div><div class="line">                       (/ (get-value product) </div><div class="line">                          (get-value m2))</div><div class="line">                       me))))</div><div class="line">  </div><div class="line">  (define (process-forget-value)</div><div class="line">    (forget-value! product me)</div><div class="line">    (forget-value! m1 me)</div><div class="line">    (forget-value! m2 me)</div><div class="line">    (process-new-value))</div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else</div><div class="line">           (error "Unknown request: </div><div class="line">                   MULTIPLIER" </div><div class="line">                  request))))</div><div class="line">  (connect m1 me)</div><div class="line">  (connect m2 me)</div><div class="line">  (connect product me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<p>最后，<strong>监视器</strong>在指定连接器被设置或取消值的时候打印出一个消息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(define (probe name connector)</div><div class="line">  (define (print-probe value)</div><div class="line">    (newline) (display "Probe: ")</div><div class="line">    (display name) (display " = ")</div><div class="line">    (display value))</div><div class="line">  (define (process-new-value)</div><div class="line">    (print-probe (get-value connector)))</div><div class="line">  (define (process-forget-value)</div><div class="line">    (print-probe "?"))</div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else (error "Unknown request: </div><div class="line">                        PROBE" request))))</div><div class="line">  (connect connector me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<h4 id="连接器的表示"><a href="#连接器的表示" class="headerlink" title="连接器的表示"></a>连接器的表示</h4><p>连接器用带有局部状态变量value，informant和constraint的过程对象表示，value中保存这个连接器的当前值，informant是设置连接器值的对象，constraint是这一连接器所涉及的所有约束的表。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">(define (make-connector)</div><div class="line">  (let ((value false) </div><div class="line">        (informant false) </div><div class="line">        (constraints '()))</div><div class="line">    ; 当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。</div><div class="line">    (define (set-my-value newval setter)</div><div class="line">      ; 如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束</div><div class="line">      (cond ((not (has-value? me))</div><div class="line">             (set! value newval)</div><div class="line">             (set! informant setter)</div><div class="line">             ; 而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的那个约束之外</div><div class="line">             (for-each-except </div><div class="line">              setter</div><div class="line">              inform-about-value</div><div class="line">              constraints))</div><div class="line">            ((not (= value newval))</div><div class="line">             (error "Contradiction" </div><div class="line">                    (list value newval)))</div><div class="line">            (else 'ignored)))</div><div class="line">       </div><div class="line">    ; 当连接器被要求忘记自己的值时，它就会去运行局部过程forget-my-value。</div><div class="line">    (define (forget-my-value retractor)</div><div class="line">      ; 首先检査这一要求是否来自原先设置值的同一个对象</div><div class="line">      (if (eq? retractor informant)</div><div class="line">          (begin (set! informant false)</div><div class="line">                 ; 如果情况确实如此，连接器就通知它所参与的所有约束，告知它们自己的值已经没有了。</div><div class="line">                 (for-each-except </div><div class="line">                  retractor</div><div class="line">                  inform-about-no-value</div><div class="line">                  constraints))</div><div class="line">          'ignored))</div><div class="line">       </div><div class="line">    ; connect向约束表里加入一个新约束（如果它以前不在表里)。如果这个连接器已经有值，它就会将这一事实通知这个新约束。</div><div class="line">    (define (connect new-constraint)</div><div class="line">      (if (not (memq new-constraint </div><div class="line">                     constraints))</div><div class="line">          (set! constraints</div><div class="line">                (cons new-constraint </div><div class="line">                      constraints)))</div><div class="line">      (if (has-value? me)</div><div class="line">          (inform-about-value new-constraint))</div><div class="line">      'done)</div><div class="line">       </div><div class="line">    ; 连接器过程me完成对于内部过程服务的分派工作，它同时也作为这个连接器对象的代表</div><div class="line">    (define (me request)</div><div class="line">      (cond ((eq? request 'has-value?)</div><div class="line">             (if informant true false))</div><div class="line">            ((eq? request 'value) value)</div><div class="line">            ((eq? request 'set-value!) </div><div class="line">             set-my-value)</div><div class="line">            ((eq? request 'forget) </div><div class="line">             forget-my-value)</div><div class="line">            ((eq? request 'connect) connect)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          CONNECTOR"</div><div class="line">                         request))))</div><div class="line">    me))</div></pre></td></tr></table></figure>
<p>当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束。而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的<br>那个约束之外。这一工作通过下面的迭代过程完成，它将一个指定过程应用于一个表中的所有对象，除了一个给定的例外：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; 将一个指定过程应用于一个表中的所有对象</span></div><div class="line">(<span class="name">define</span> (<span class="name">for-each-except</span> exception </div><div class="line">                         procedure </div><div class="line">                         list)</div><div class="line">  (<span class="name">define</span> (<span class="name">loop</span> items)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">null</span>? items) 'done)</div><div class="line">          ((<span class="name">eq</span>? (<span class="name">car</span> items) exception) </div><div class="line">           (<span class="name">loop</span> (<span class="name">cdr</span> items)))</div><div class="line">          (<span class="name">else</span> (<span class="name">procedure</span> (<span class="name">car</span> items))</div><div class="line">                (<span class="name">loop</span> (<span class="name">cdr</span> items)))))</div><div class="line">  (<span class="name">loop</span> list))</div></pre></td></tr></table></figure>
<p>下面几个过程为分派提供了一个语法界面：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">has-value</span>? connector)</div><div class="line">  (<span class="name">connector</span> 'has-value?))</div><div class="line">(<span class="name">define</span> (<span class="name">get-value</span> connector)</div><div class="line">  (<span class="name">connector</span> 'value))</div><div class="line">(<span class="name">define</span> (<span class="name">set-value!</span> connector </div><div class="line">                    new-value </div><div class="line">                    informant)</div><div class="line">  ((<span class="name">connector</span> 'set-value!) </div><div class="line">   new-value </div><div class="line">   informant))</div><div class="line">(<span class="name">define</span> (<span class="name">forget-value!</span> connector retractor)</div><div class="line">  ((<span class="name">connector</span> 'forget) retractor))</div><div class="line">(<span class="name">define</span> (<span class="name">connect</span> connector new-constraint)</div><div class="line">  ((<span class="name">connector</span> 'connect) new-constraint))</div></pre></td></tr></table></figure>
<h2 id="3-4-并发：时间是一个本质问题"><a href="#3-4-并发：时间是一个本质问题" class="headerlink" title="3.4 并发：时间是一个本质问题"></a>3.4 并发：时间是一个本质问题</h2><p>在并发的情况下，由赋值引入的复杂性问题将变得更加严重。</p>
<h3 id="3-4-1-并发系统中时间的性质"><a href="#3-4-1-并发系统中时间的性质" class="headerlink" title="3.4.1 并发系统中时间的性质"></a>3.4.1 并发系统中时间的性质</h3><p>假设由Peter和Paul进行的取款被实现为两个独立的进程，共享同一个变量balance</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/TB2lzajiVXXXXcHXXXXXXXXXXXX_!!581166664.png" alt="Peterä¸Paulåæ¶ååä¸ä¸ªè´¦æ·çä¸ç§åºæ¯"></p>
<p><strong>并发程序的正确行为</strong></p>
<ul>
<li>1）对并发地一种可能限制方式是：规定能修改共享状态变量的两个操作都不允许同时发生。（<strong>低效</strong>）</li>
<li>2）另一种不严厉的方式是：保证并发系统产生的结果与各个进程<strong>按照某种方式顺序运行产生出的结果</strong>完全一样。<ul>
<li>2.1）它并没有要求各个进程实际上顺序地运行，而只是要求它们<strong>产生的结果与 <em>假设</em> 它们顺序运行所产生的结果相同</strong>。</li>
<li>2.2）一个并发程序完全可能产生多于一个 “正确的” 结果，因为我们只要求其结果与按照 <em>某种</em> 方式顺序化的结果相同。</li>
</ul>
</li>
</ul>
<p>对于2.2），比如Peter和Paul的共享账户有100，Peter存入40，同时Paul取出账户中钱的一半。则可能产生两种余额，70或90。</p>
<h3 id="3-4-2-控制并发的机制"><a href="#3-4-2-控制并发的机制" class="headerlink" title="3.4.2 控制并发的机制"></a>3.4.2 控制并发的机制</h3><p>在设计并发系统时，设法做出一些一般性的机制，使我们可能<strong>限制并行进程之间的交错情况</strong>，以保证程序具有正确的行为方式。<br>人们已经为此目的而开发了许多不同的机制，我们讨论其中的一种：<strong>串行化组</strong>（serializer）</p>
<p><strong>对共享变量的串行访问</strong></p>
<p><strong>串行化</strong>：使进程可以并发地执行，但是其中也有一些过程不能并发地执行。</p>
<p>Scheme的串行化</p>
<p>通过<strong>串行化组</strong>实现这种限制。构造的方式是调用make-serializer，这一过程的实现将在后面给出。对一个给定串行化组的所有调用返回的串行化过程都属于同一个集合。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line"></div><div class="line">  <span class="comment">; 关键改动</span></div><div class="line">  (<span class="name">let</span> ((<span class="name">protected</span> (<span class="name">make-serializer</span>)))</div><div class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) (<span class="name">protected</span> withdraw))</div><div class="line">            ((<span class="name">eq</span>? m 'deposit) (<span class="name">protected</span> deposit))</div><div class="line">            ((<span class="name">eq</span>? m 'balance) deposit)</div><div class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></div><div class="line">                         m))))</div></pre></td></tr></table></figure>
<p><strong>使用多重共享资源的复杂性</strong></p>
<p>如果只存在一个共享资源（如银行账户），串行化的使用问题相对简单。如果存在多项共享资源，并发程序的设计就可能变得非常难以把握了。</p>
<p>比如现在可以交换两个账户的余额。假设Peter和Paul都能访问账户a1, a2, a3。Peter要交换a1和a3，同时Paul要交换a1和a2，虽然对单个账户做了串行化，但交换操作还是可能产生不正确的结果。</p>
<p><strong>串行化的实现</strong></p>
<p>使用<strong>互斥元（mutex）</strong>的同步机制来实现串行化。mutex是一种对象，提供两种操作</p>
<p>1）获取（acquired）</p>
<p>2）释放（released）</p>
<p>一旦一个mutex被获取，对它的任何操作都必须等released之后。</p>
<p>在make-serializer的实现中，关联一个mutex。<strong>给定一个过程p，串行化组先返回一个mutex，再运行p，然后释放mutex，这样就能保证这个串行化组产生的所有过程中，一次只能运行一个p</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-serializer</span>)</div><div class="line">   (<span class="name">let</span> ((<span class="name">mutex</span> (<span class="name">make-mutex</span>))</div><div class="line">         (<span class="name">lambda</span> (<span class="name">p</span>)</div><div class="line">           (<span class="name">define</span> (<span class="name">serialized-p</span> . args)</div><div class="line">             (<span class="name">mutex</span> 'acquired)</div><div class="line">             (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">apply</span> p args)))</div><div class="line">               (<span class="name">mutex</span> 'release)</div><div class="line">               val))</div><div class="line">           serialized-p))))</div></pre></td></tr></table></figure>
<p>mutex是一个Boolean，在mutex的构造函数中，初始化为false。</p>
<p>在acquired时，先判断是否为false，若是，设置为true然后使用；否则在循环中等待，直到检测为false。</p>
<p>在acquired操作时，有一个<code>test-and-set!</code>方法，用于检查mutex并返回结果，其中若检查结果为false，在返回false之前还要设置为true。</p>
<p>这里的关键是，<code>test-and-set!</code>必须以原子操作的方式执行。比如说，一旦某进程检查了一个mutex发现是false，就必须在其他进程检查这个mutex之前完成为true的设置，否则mutex的机制就失效了。目前多CPU的电脑中提供了专门指令，直接在硬件中支持原子操作。</p>
<p><strong>死锁</strong></p>
<p>比如Peter要交换a2和a1，则进入了保护a2的串行化进程；Paul同时要交换a1和a2，则进入了保护a1的串行化进程。于是双方都无法继续了。</p>
<p>避免死锁的一种方式，就是首先给每个账户确定一个<strong>唯一的标识编号</strong>，再重写serialized-exchange，使每个进程总是首先去<strong>保护较低编号</strong>的账户。</p>
<p><strong>并发性、时间和通信</strong></p>
<p>我们已经看到，在并发系统的程序设计中，为什么需要去控制不同进程访问共享变量的事件发生的顺序，也看到了如何通过审慎地使用串行化去完成这方面的控制。但是并发性的基本问题比这些更深刻，因为，从一种更基本的观点看，“共享状态”究竟意味着什么，这件事常常并不清楚。</p>
<p>像<code>test-and-set!</code>这样的机制，都要求进程能在任意时刻去检查一个全局性的共享标志。在实现新型高速处理器时，由于在那里需要采用各种优化技术，例如流水线和缓存，因此就不可能在每个时刻都保持存储器内容的一致性，此时完成上述的检查将很有问题，也必然非常低效。正因为这样，在当前的多处理器系统里，串行化方式正在被并发控制的各种新技术取代，比如<strong>屏障同步</strong></p>
<h2 id="3-5-流"><a href="#3-5-流" class="headerlink" title="3.5 流"></a>3.5 流</h2><p>流是另一种模拟现实物理世界的设计策略，其核心思想就是<strong>用数学概念上的函数来表示一现实物体的改变</strong>，比如对象X，可以用<code>X(t)</code>来表示，如果我们想集中关心的是一个个时刻的x，那么就可以将它看作一个变化的量。如果关注的是这些值的整个时间史，那么就不需要强调其中的变化——这一函数本身是没有改变的。</p>
<p>在第二章我们学习了<strong>序列</strong>和<strong>表</strong>的概念（P84）。从抽象的观点看，流也是一个序列，但如果把流表示为表，必能完全揭示流处理的威力。这里要引入一种叫“<strong>延时求值</strong>”的技术。</p>
<h3 id="3-5-1-流作为延时的表"><a href="#3-5-1-流作为延时的表" class="headerlink" title="3.5.1 流作为延时的表"></a>3.5.1 流作为延时的表</h3><p>我们之前建立了一些对序列操作的抽象机制，比如map、filter、accumulate等。但如果我们将序列表示为表，表达可以更优雅，但效率很低。</p>
<p>例如，要计算一个区间内的素数之和。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? sequence)</div><div class="line">    initial</div><div class="line">    (<span class="name">op</span> (<span class="name">car</span> sequence)</div><div class="line">        (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">prime</span>? n)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> n next)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> n next) #t)</div><div class="line">          ((<span class="name">=</span> <span class="number">0</span> (<span class="name">remainder</span> n next)) #f)</div><div class="line">          (<span class="name">else</span> (<span class="name">iter</span> n (<span class="name">+</span> next <span class="number">1</span>)))))</div><div class="line">  (<span class="name">iter</span> n <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">    '()</div><div class="line">    (<span class="name">cons</span> low (<span class="name">enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>) high))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">filter</span> predicate sequence)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? sequence) '())</div><div class="line">        ((<span class="name">predicate</span> (<span class="name">car</span> sequence))</div><div class="line">         (<span class="name">cons</span> (<span class="name">car</span> sequence)</div><div class="line">               (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence))))</div><div class="line">        (<span class="name">else</span> (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> count accum)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">&gt;</span> count b) accum)</div><div class="line">          ((<span class="name">prime</span>? count) (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) (<span class="name">+</span> count accum))</div><div class="line">          (<span class="name">else</span> (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) accum))))</div><div class="line">    (<span class="name">iter</span> a <span class="number">0</span>)))</div></pre></td></tr></table></figure>
<p>如果用序列操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</div><div class="line">  (<span class="name">accumulate</span> + </div><div class="line">              <span class="number">0</span></div><div class="line">              (<span class="name">filter</span> prime? (<span class="name">enumerate-interval</span> a b))))</div></pre></td></tr></table></figure>
<p>在执行计算时，第一个程序只需要<strong>维护正在累积的和</strong>。第二个程序只有<strong>等enumate-interval构造完成这一区间所有整数的表之后</strong>，过滤器才能开始工作。这就需要大量的中间存储，增加计算开销。</p>
<p>流是一种非常巧妙的想法，使我们<strong>既可以利用各种序列操作，又不会带来将序列作为表操作的性能代价</strong>。</p>
<p>从表面上看，流也是表，但对他们进行操作的过程的名字不同。有构造函数cons-stream，以及两个选择函数stream-car和stream-cdr，满足如下约束</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">stream-car</span> (<span class="name">cons-stream</span> x y))=x</div><div class="line">(<span class="name">stream-cdr</span> (<span class="name">cons-stream</span> x y))=y</div></pre></td></tr></table></figure>
<p>我们用和第二章各种表操作（如list-ref，map和for-each等）类似的方式来操作流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">stream-car</span> s)</div><div class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc s)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span> </div><div class="line">       (<span class="name">proc</span> (<span class="name">stream-car</span> s))</div><div class="line">       (<span class="name">stream-map</span> proc (<span class="name">stream-cdr</span> s)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-for-each</span> proc s)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</div><div class="line">      'done</div><div class="line">      (<span class="name">begin</span> </div><div class="line">        (<span class="name">proc</span> (<span class="name">stream-car</span> s))</div><div class="line">        (<span class="name">stream-for-each</span> proc </div><div class="line">                         (<span class="name">stream-cdr</span> s)))))</div></pre></td></tr></table></figure>
<p>核心的诉求是，<strong>对于流的cdr的求值要等到真正通过过程stream-cdr去访问它的时候再做，而不是在构造stream-cdr的时候做</strong>。</p>
<p>流的实现将基于一种称为<strong>delay</strong>的特殊形式，对于<code>(delay &lt;exp&gt;)</code>的求值不是对表达式求值，而是返回一个称为 <strong>延时对象</strong> 的对象。这个对象可以看做是对未来某个时间要对表达式求值的一个允诺。</p>
<p>和delay一起的还有一个<strong>force</strong>的过程，它以一个延时对象为参数，执行相应的求值工作，也就是说，force就用来迫使delay完成所允诺的求值。下面用这两个概念来构造流。</p>
<p>cons-stream的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cons-stream ⟨a⟩ ⟨b⟩)</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cons ⟨a⟩ (delay ⟨b⟩))</div></pre></td></tr></table></figure>
<p>可见，定义的时候，b还没有放到cons的cdr中。再看对cons的取值，</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) </div><div class="line">  (<span class="name">car</span> stream))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) </div><div class="line">  (<span class="name">force</span> (<span class="name">cdr</span> stream)))</div></pre></td></tr></table></figure>
<p><strong>流实现的行为方式</strong></p>
<p>我们再来看之前的过滤出素数的例子</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">stream-car</span> </div><div class="line"> (<span class="name">stream-cdr</span></div><div class="line">  (<span class="name">stream-filter</span> </div><div class="line">   prime? (<span class="name">stream-enumerate-interval</span> </div><div class="line">           <span class="number">10000</span> <span class="number">1000000</span>))))</div></pre></td></tr></table></figure>
<p>计算开始于对参数10000 1000000调用stream-enumerate-interval。它的实现是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span></div><div class="line">       low</div><div class="line">       (<span class="name">stream-enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>)</div><div class="line">                                  high))))</div></pre></td></tr></table></figure>
<p>这样，由stream-enumerate-interval返回的结果就是通过cons-stream形成的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10000</span></div><div class="line">      (<span class="name">delay</span> </div><div class="line">        (<span class="name">stream-enumerate-interval</span> </div><div class="line">         <span class="number">10001</span> </div><div class="line">         <span class="number">1000000</span>)))</div></pre></td></tr></table></figure>
<p>也就是说，当stream-enumerate-interval返回一个流的时候，car是10000，而cdr是一个<strong>允诺</strong>，表示当需要的时候，才在这个区间中枚举更多的内容。</p>
<p>再来看这个流程构建后的过滤</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) </div><div class="line">         the-empty-stream)</div><div class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</div><div class="line">         (<span class="name">cons-stream</span> </div><div class="line">          (<span class="name">stream-car</span> stream)</div><div class="line">          (<span class="name">stream-filter</span> </div><div class="line">           pred</div><div class="line">           (<span class="name">stream-cdr</span> stream))))</div><div class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> </div><div class="line">               pred </div><div class="line">               (<span class="name">stream-cdr</span> stream)))))</div></pre></td></tr></table></figure>
<p>首先检查stream-car，因为这个数不是素数（10000），再进一步检查stream-cdr，这个时候对stream-cdr的调用会迫使系统对延时的stream-enumerate-interval求值，这一次就返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10001</span></div><div class="line">      (<span class="name">delay</span> </div><div class="line">        (<span class="name">stream-enumerate-interval</span> </div><div class="line">         <span class="number">10002</span> </div><div class="line">         <span class="number">1000000</span>)))</div></pre></td></tr></table></figure>
<p>如此进行，直到找到第一个素数10007，此时stream-filter根据其定义返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons-stream</span> </div><div class="line"> (<span class="name">stream-car</span> stream)</div><div class="line"> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))</div></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10007</span></div><div class="line">      (<span class="name">delay</span></div><div class="line">        (<span class="name">stream-filter</span></div><div class="line">         prime?</div><div class="line">         (<span class="name">cons</span> <span class="number">10008</span></div><div class="line">               (<span class="name">delay</span></div><div class="line">                 (<span class="name">stream-enumerate-interval</span> </div><div class="line">                  <span class="number">10009</span> <span class="number">1000000</span>))))))</div></pre></td></tr></table></figure>
<p>这样在stream-cdr中，又迫使延时的stream-filter求值，转而再去迫使stream-enumerate-interval求值，直到再找到下一个素数……</p>
<p>一般而言，可以将延时求值看做是一种“由需要驱动”的设计，其中流处理的每个阶段都仅仅活动到足够满足下一阶段的需要。</p>
<p><strong>delay和force的实现</strong></p>
<p>delay必须包装起一个表达式，使其可以在以后根据需要求值。delay实际上也是一个lambda表达式的语法糖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(delay ⟨exp⟩)</div><div class="line">=</div><div class="line">(lambda () ⟨exp⟩)</div></pre></td></tr></table></figure>
<p>而force就是简单调用由delay产生的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(define (force delayed-object)</div><div class="line">  (delayed-object))</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/congyihao/article/details/60747909" target="_blank" rel="noopener">Java 8 - 通过lambda表达式进行惰性计算</a></p>
<p>lambda表达式的出现使得JDK8内部发生了很多有趣的变化, 其中就包括惰性计算的特性.<br>这里以JDK标准库中的Logger为例, 1.8以前的log方法有如下签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String msg)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</div><div class="line">&gt;             <span class="keyword">return</span>;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msg);</div><div class="line">&gt;         doLog(lr);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>也就是说客户端程序调用log方法的时候, 无论最终是否触发log行为, <code>msg</code>始终是要被计算的. 若计算<code>msg</code>是非常耗时的行为, 那么无疑会造成不必要的开销. 下面是一个调用的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; log(Level.WARNING, <span class="string">"Log msg: "</span> + someExpensiveOperation());</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在java 1.8版本出现之后, 该方法多了如下重载:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, Supplier&lt;String&gt; msgSupplier)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</div><div class="line">&gt;             <span class="keyword">return</span>;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msgSupplier.get());</div><div class="line">&gt;         doLog(lr);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><code>Supplier</code>是一个<code>FunctionalInterface</code>, 也就是说现在的<code>log</code>方法可以接受一个无参的lambda表达式作为参数, 而计算的过程也被延迟到了<code>supplier.get()</code>的调用时. 改进后的调用例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// 注意: 传入的lambda表达式并不会立即执行, 而是在log中判断isLoggable(level)成功后才会执行</span></div><div class="line">&gt; log(Level.WARNING, () -&gt; <span class="string">"Log msg: "</span> + someExpensiveOperation());</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>这里还存在一个优化。有时需要多次对同一个delay求值，这就需要delay能保存上一次求出的值。于是可以将delay实现为一种特殊的记忆过程，它以一个无参过程为参数，返回该过程的记忆性版本。这种记忆性过程在第一次执行时将结果保存，下一次求值时再返回之前保存的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">memo-proc</span> proc)</div><div class="line">  (<span class="name">let</span> ((<span class="name">already-run</span>? false) (<span class="name">result</span> false))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">if</span> (<span class="name">not</span> already-run?)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> result (<span class="name">proc</span>))</div><div class="line">                 (<span class="name">set!</span> already-run? true)</div><div class="line">                 result)</div><div class="line">          result))))</div></pre></td></tr></table></figure>
<p>此后再定义delay，使得<code>(delay ⟨exp⟩)</code>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(memo-proc (lambda () ⟨exp⟩))</div></pre></td></tr></table></figure>
<h3 id="3-5-2-无穷流"><a href="#3-5-2-无穷流" class="headerlink" title="3.5.2 无穷流"></a>3.5.2 无穷流</h3><p>用流表示无穷长的序列。</p>
<p>比如以下的流可以表示所有正整数序列。这是一个无穷长的流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</div><div class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">100</span>)</div><div class="line"><span class="number">101</span></div></pre></td></tr></table></figure>
<p>用这个就可以表示，例如不能被7整除的整数的流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">divisible</span>? x y) (<span class="name">=</span> (<span class="name">remainder</span> x y) <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> no-sevens</div><div class="line">  (<span class="name">stream-filter</span> (<span class="name">lambda</span> (<span class="name">x</span>) </div><div class="line">                   (<span class="name">not</span> (<span class="name">divisible</span>? x <span class="number">7</span>)))</div><div class="line">                 integers))</div></pre></td></tr></table></figure>
<p>之后在用访问这个流元素的方式找出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; (stream-ref no-sevens 100)</div><div class="line">117</div></pre></td></tr></table></figure>
<p>也可以定义斐波那契数列的无穷流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">fibgen</span> a b)</div><div class="line">  (<span class="name">cons-stream</span> a (<span class="name">fibgen</span> b (<span class="name">+</span> a b))))</div><div class="line">(<span class="name">define</span> fibs (<span class="name">fibgen</span> <span class="number">0</span> <span class="number">1</span>))</div><div class="line"></div><div class="line">------------------</div><div class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">6</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<p>这样定义出的<code>fibs</code>是一个序对，其car是0，cdr是一个求值<code>(fibgen 1 1)</code>的允诺。求该表达式时，又将产生一个序对，car是，cdr是<code>(fibgen 1 2)</code>。</p>
<p><strong>隐式的定义流</strong></p>
<p>上面的integers和fibs是通过描述“生成”过程的方式定义的，这种过程是一个个的计算出流的元素。另一种就是<strong>隐式的求值</strong>。</p>
<p>例如，下面表达式将ones定义为1的一个无穷流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(define ones (cons-stream 1 ones))</div></pre></td></tr></table></figure>
<p>这种方式就像在定义一个递归过程：这里的ones是一个序对，car是1，cdr是求值ones的一个允诺。而对cdr的求值又得到了一个1和cdr的允诺。</p>
<p>add-streams操作产生出两个给定流的逐对元素之和</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-streams</span> s1 s2) </div><div class="line">  (<span class="name">stream-map</span> + s1 s2))</div></pre></td></tr></table></figure>
<p>现在可以用另一种方式定义整数流integers</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> integers </div><div class="line">  (<span class="name">cons-stream</span> <span class="number">1</span> (<span class="name">add-streams</span> ones integers)))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">10</span>)</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>首元素是1，其余是ones和integers之和。这样，integers的第二个元素就是1加上integers的第一个元素，也就是2。第三个元素就是1加上integers的第二个元素，也就是3。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; 原版integers定义</span></div><div class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</div><div class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>同样的风格也可以定义出斐波那契数列</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> fibs </div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   <span class="number">0</span> (<span class="name">cons-stream</span></div><div class="line">      <span class="number">1</span> (<span class="name">add-streams</span> </div><div class="line">         (<span class="name">stream-cdr</span> fibs) fibs))))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">11</span>)</div><div class="line"><span class="number">89</span></div></pre></td></tr></table></figure>
<p>这个定义是fib是一个从0和1开始的流，而这个流的其余部分都可以通过加起流fibs和移动了一个位置的fibs而得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    1 1 2 3 5  8 13 21 … = (stream-cdr fibs)</div><div class="line">    0 1 1 2 3  5  8 13 … = fibs</div><div class="line">0 1 1 2 3 5 8 13 21 34 … = fibs</div></pre></td></tr></table></figure>
<h3 id="3-5-5-函数式程序的模块化和对象的模块化"><a href="#3-5-5-函数式程序的模块化和对象的模块化" class="headerlink" title="3.5.5 函数式程序的模块化和对象的模块化"></a>3.5.5 函数式程序的模块化和对象的模块化</h3><p>正如在3.1.2中看到的，引进赋值的主要收益就是使我们可以<strong>增强系统的模块化</strong>，把一个大系统的状态中的某些部分封装，或者说<strong>“隐藏”到局部变量里</strong>。</p>
<p>流模型可以<strong>提供等价的模块化，同时又不必使用赋值</strong>。为了展示这方面的情况，我们可以重新实现前面在 3.1.2 节看过的π的蒙特卡罗估计，这次从流的观点出发来做。</p>
<p>这里的一个关键性的模块化问题，就是我们希望<strong>将一个随机数生成器的内部状态隐蔽起来，隔离在使用随机数的程序之外</strong>。从过程 <code>rand-update</code> 开始，它所提供的一系列值就是我们所需的随机数，用它作为一个随机数生成器：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> rand</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</div><div class="line">      x)))</div></pre></td></tr></table></figure>
<p>在这个流的描述中，看不到什么随机数生成器。在这里只有一个随机数的流，通过对rand-update的一系列顺序调用产生：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> random-numbers</div><div class="line">  (<span class="name">cons-stream</span> random-init</div><div class="line">               (<span class="name">stream-map</span> rand-update </div><div class="line">                           random-numbers)))</div></pre></td></tr></table></figure>
<p>用它构造出在<code>random-numbers</code>流中顺序的数对上的的Cesaro实验的输出流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">map-successive-pairs</span> f s)</div><div class="line">  (<span class="name">cons-stream</span></div><div class="line">   (<span class="name">f</span> (<span class="name">stream-car</span> s) </div><div class="line">      (<span class="name">stream-car</span> (<span class="name">stream-cdr</span> s)))</div><div class="line">   (<span class="name">map-successive-pairs</span> </div><div class="line">    f (<span class="name">stream-cdr</span> (<span class="name">stream-cdr</span> s)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> cesaro-stream</div><div class="line">  (<span class="name">map-successive-pairs</span></div><div class="line">   (<span class="name">lambda</span> (<span class="name">r1</span> r2) (<span class="name">=</span> (<span class="name">gcd</span> r1 r2) <span class="number">1</span>))</div><div class="line">   random-numbers))</div></pre></td></tr></table></figure>
<p>现在将<code>cesaro-stream</code>扔进<code>monte-carlo</code>过程，该过程生成一个可能性估计的流。得到的结果就变换到一个估计π值的流。这一版本的程序<strong>不需要用参数去告诉它试多少次</strong>，只要查看更后面的值，就可以得到更好的π的估计。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> experiment-stream </div><div class="line">                     passed </div><div class="line">                     failed)</div><div class="line">  (<span class="name">define</span> (<span class="name">next</span> passed failed)</div><div class="line">    (<span class="name">cons-stream</span></div><div class="line">     (<span class="name">/</span> passed (<span class="name">+</span> passed failed))</div><div class="line">     (<span class="name">monte-carlo</span></div><div class="line">      (<span class="name">stream-cdr</span> experiment-stream) </div><div class="line">      passed </div><div class="line">      failed)))</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-car</span> experiment-stream)</div><div class="line">      (<span class="name">next</span> (<span class="name">+</span> passed <span class="number">1</span>) failed)</div><div class="line">      (<span class="name">next</span> passed (<span class="name">+</span> failed <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> pi</div><div class="line">  (<span class="name">stream-map</span></div><div class="line">   (<span class="name">lambda</span> (<span class="name">p</span>) (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> p)))</div><div class="line">   (<span class="name">monte-carlo</span> cesaro-stream <span class="number">0</span> <span class="number">0</span>)))</div><div class="line"></div><div class="line">------------------------</div><div class="line">&gt; (<span class="name">stream-ref</span> pi <span class="number">1000</span>)</div><div class="line"><span class="number">3.24037034920393</span></div></pre></td></tr></table></figure>
<p>而且，这一方法也非常模块化，这里<strong>构造了一个一般性的monte-carlo过程，它可以处理任何试验，而且这里没有赋值，也没有局部状态</strong>。</p>
<p>附：流执行的预先定义函数</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; stream-&gt;list</span></div><div class="line"></div><div class="line">(<span class="name">define</span> stream-&gt;list</div><div class="line">  (<span class="name">lambda</span> (<span class="name">strm</span> n)</div><div class="line">    (<span class="name">if</span> (<span class="name">or</span> (<span class="name">stream-null</span>? strm) (<span class="name">zero</span>? n))</div><div class="line">        '()</div><div class="line">        (<span class="name">cons</span> (<span class="name">stream-car</span> strm)</div><div class="line">              (<span class="name">stream-&gt;list</span> (<span class="name">stream-cdr</span> strm) (<span class="name">sub1</span> n))))))</div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define-syntax</span> delay</div><div class="line">  (<span class="name">syntax-rules</span> ()</div><div class="line">    ((<span class="name">_</span> exp) (<span class="name">lambda</span> () exp))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">force</span> delayed-object)</div><div class="line">  (<span class="name">delayed-object</span>))</div><div class="line"></div><div class="line">(<span class="name">define-syntax</span> cons-stream</div><div class="line">  (<span class="name">syntax-rules</span> ()</div><div class="line">    ((<span class="name">_</span> a b) (<span class="name">cons</span> a (<span class="name">delay</span> b)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) (<span class="name">car</span> stream))</div><div class="line"> </div><div class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) (<span class="name">force</span> (<span class="name">cdr</span> stream)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-null</span>? stream)</div><div class="line">  (<span class="name">null</span>? stream))</div><div class="line"></div><div class="line">(<span class="name">define</span> the-empty-stream '())</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">stream-car</span> s)</div><div class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc . argstreams)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? (<span class="name">car</span> argstreams))</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span></div><div class="line">       (<span class="name">apply</span> proc (<span class="name">map</span> stream-car argstreams))</div><div class="line">       (<span class="name">apply</span> stream-map</div><div class="line">              (<span class="name">cons</span> proc</div><div class="line">                    (<span class="name">map</span> stream-cdr</div><div class="line">                         argstreams))))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) the-empty-stream)</div><div class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</div><div class="line">         (<span class="name">cons-stream</span> (<span class="name">stream-car</span> stream)</div><div class="line">                      (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream))))</div><div class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))))</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liujiacai.net/blog/2015/12/26/sicp-chapter3-summary/" target="_blank" rel="noopener">SICP 第三章总结</a></p>
<p><a href="https://github.com/rsy56640/daily_learning/tree/master/SICP#3" target="_blank" rel="noopener">SICP note</a></p>
<p><a href="https://sicp.liujiacai.net/chap3/exercise.html" target="_blank" rel="noopener">第三章习题索引</a></p>
<p><a href="https://sarabander.github.io/sicp/html/3_002e5.xhtml" target="_blank" rel="noopener">第三章英文版</a></p>
<p><a href="https://wizardforcel.gitbooks.io/sicp-py/content/" target="_blank" rel="noopener">SICP Python 描述 中文版</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/编程语言学习/JAVA/java出错汇总/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/编程语言学习/JAVA/java出错汇总/" class="post-title-link" itemprop="url">java出错汇总</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2018-05-25 15:43:50" itemprop="dateModified" datetime="2018-05-25T15:43:50+08:00">2018-05-25</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MD5线程不安全"><a href="#MD5线程不安全" class="headerlink" title="MD5线程不安全"></a>MD5线程不安全</h1><p>MessageDigest线程不安全，多线程下会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">java.lang.ArrayIndexOutOfBoundsException</div><div class="line"></div><div class="line">	at java.lang.System.arraycopy(Native Method)</div><div class="line"></div><div class="line">	at sun.security.provider.DigestBase.engineUpdate(DigestBase.java:114)</div><div class="line"></div><div class="line">	at java.security.MessageDigest$Delegate.engineUpdate(MessageDigest.java:584)</div><div class="line"></div><div class="line">	at java.security.MessageDigest.update(MessageDigest.java:335)</div><div class="line"></div><div class="line">	at com.buzzinate.common.util.hash.MD5Util.getMD5String(MD5Util.java:98)</div><div class="line"></div><div class="line">	at com.buzzinate.common.util.hash.MD5Util.getMD5String(MD5Util.java:94)</div></pre></td></tr></table></figure>
<p>改用apache的commons-codec</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt; </div><div class="line"></div><div class="line">           &lt;groupId&gt;commons-codec&lt;/groupId&gt; </div><div class="line"></div><div class="line">           &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; </div><div class="line"></div><div class="line">           &lt;version&gt;1.10&lt;/version&gt; </div><div class="line"></div><div class="line">       &lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static String encodeMD5Hex(String data)     </div><div class="line"></div><div class="line"> &#123;</div><div class="line"></div><div class="line">          return DigestUtils.md5Hex(data);      </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法是线程安全的</p>
<h1 id="Eclipse闪退"><a href="#Eclipse闪退" class="headerlink" title="Eclipse闪退"></a>Eclipse闪退</h1><p>每次闪退后都提示查看\workspace.metadata.log，发现有如下异常信息记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">!ENTRY org.eclipse.e4.ui.workbench.swt 4 2 2016-08-23 08:42:49.516  </div><div class="line">!MESSAGE Problems occurred when invoking code from plug-in: &quot;org.eclipse.e4.ui.workbench.swt&quot;.  </div><div class="line">!STACK 0  </div><div class="line">java.lang.IllegalArgumentException: Argument cannot be null</div></pre></td></tr></table></figure>
<p>出现该问题的原因是：由于项目没有正常关闭运行而导致”workbench.xmi”中的”persistedState”标签还保持在运行时的配置造成的。</p>
<p>解决办法：</p>
<p>找到<code>&lt;workspace&gt;/.metadata/.plugins/org.eclipse.e4.workbench/workbench.xmi</code>文件，将其删掉，再重启Eclipse，恢复正常。</p>
<h1 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h1><p><a href="http://www.cnblogs.com/dolphin0520/p/3933551.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3933551.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/NLP/网页关键词提取/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/NLP/网页关键词提取/" class="post-title-link" itemprop="url">网页关键词提取</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2018-03-31 10:28:31" itemprop="dateModified" datetime="2018-03-31T10:28:31+08:00">2018-03-31</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代码位于<code>nlp</code> 项目</p>
<h1 id="jsoup解析html的DOM"><a href="#jsoup解析html的DOM" class="headerlink" title="jsoup解析html的DOM"></a>jsoup解析html的DOM</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Document doc =Jsoup.connect(url).userAgent(&quot;Mozilla&quot;).get();</div></pre></td></tr></table></figure>
<h1 id="提取网页"><a href="#提取网页" class="headerlink" title="提取网页"></a>提取网页</h1><p><code>getPageDetail</code>获取网页提取的结果，返回<code>WebPageInfo</code>类，该类包括</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String domain;</div><div class="line"><span class="keyword">public</span> String url;</div><div class="line"><span class="keyword">public</span> String rawTitle;</div><div class="line"><span class="keyword">public</span> String title;</div><div class="line"><span class="keyword">public</span> String content;</div><div class="line"><span class="keyword">public</span> String summary;</div><div class="line"><span class="keyword">public</span> HashMap&lt;String, String&gt; meta;</div><div class="line"><span class="keyword">public</span> HashMap&lt;String, List&lt;String&gt;&gt; calculation;</div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> freq = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> String createTime;</div></pre></td></tr></table></figure>
<p><code>meta_desc</code>，来自网页meta的<code>description</code>元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta.put(&quot;description&quot;, meta_desc);</div></pre></td></tr></table></figure>
<p><code>meta_keywords</code>，来自网页meta的<code>keywords</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta.put(&quot;keywords&quot;, meta_keywords);</div></pre></td></tr></table></figure>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><code>rawTitle=doc.title()</code></p>
<p><code>title</code>，通过<code>ExtractUtil.extractTitle(doc.body(), rawTitle)</code>进一步抽取。目的是去掉标题中的无关信息，如网站信息等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractTitle</span></span>(root: <span class="type">Element</span>, rawTitle:<span class="type">String</span>): <span class="type">String</span> = &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="type">StringUtils</span>.isBlank(rawTitle)) </div><div class="line">      <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">val</span> titleCnt = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>] <span class="keyword">with</span> <span class="type">HashMapUtil</span>.<span class="type">IntHashMap</span>[<span class="type">String</span>]</div><div class="line">    titleCnt.adjustOrPut(te.extract(rawTitle).trim, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">    titleCnt.adjustOrPut(te.extractFirst(rawTitle).trim, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">val</span> tq = <span class="keyword">new</span> <span class="type">PriorityQueue</span>[<span class="type">String</span>](<span class="number">2</span>)</div><div class="line">    extractTitle0(root, rawTitle, <span class="number">1</span>, tq)</div><div class="line">    <span class="keyword">for</span> (candidate &lt;- tq.values) titleCnt.adjustOrPut(candidate.trim, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> maxCnt = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> title = rawTitle</div><div class="line">    titleCnt.foreach &#123; <span class="keyword">case</span> (candidate, cnt) =&gt;</div><div class="line">      <span class="keyword">if</span> (maxCnt &lt; cnt) &#123;</div><div class="line">        maxCnt = cnt</div><div class="line">        title = candidate</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (maxCnt == cnt &amp;&amp; candidate.length &gt; title.length) title = candidate</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    title</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>te.extract</code>，</p>
<p>首先要<code>split</code>。通过判断unicode字符的类别（<a href="http://blog.csdn.net/weixin_36082485/article/details/53154065" target="_blank" rel="noopener">Unicode字符类</a>）来分割标题 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; title.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> ch = title.charAt(i);</div><div class="line">			<span class="keyword">int</span> type = Character.getType(ch);</div><div class="line">  			<span class="comment">// 标点，前引号</span></div><div class="line">			<span class="keyword">if</span> (type == Character.INITIAL_QUOTE_PUNCTUATION) quoteCnt++;</div><div class="line">  			<span class="comment">// 标点，开始</span></div><div class="line">			<span class="keyword">if</span> (type == Character.START_PUNCTUATION) quoteCnt++;</div><div class="line">			<span class="keyword">if</span> (quoteCnt == <span class="number">0</span> &amp;&amp; !lastLetter &amp;&amp; !lastDigit &amp;&amp; splitChars.contains(ch)) &#123;</div><div class="line">				parts.add(title.substring(last, i));</div><div class="line">				last = i + <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">  			<span class="comment">// 标点，后引号</span></div><div class="line">			<span class="keyword">if</span> (type == Character.FINAL_QUOTE_PUNCTUATION) quoteCnt--;</div><div class="line">  			<span class="comment">// 标点，结束</span></div><div class="line">			<span class="keyword">if</span> (type == Character.END_PUNCTUATION) quoteCnt--;</div><div class="line">			<span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span> || ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) lastLetter = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">else</span> lastLetter = <span class="keyword">false</span>;</div><div class="line">			<span class="keyword">if</span> (Character.isDigit(ch)) lastDigit = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!splitChars.contains(ch)) lastDigit = <span class="keyword">false</span>;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后提取最长的part。提取的原则是，</p>
<p>1、如果出现不重要的字符前缀后缀<code>ignoreSuffixes</code>、<code>ignorePrefixes</code>，降低part的长度</p>
<p>2、第一个part的长度翻倍，可能是考虑到真的标题往往出现在第一块，如</p>
<p><code>清润饮食“熄灭”冬季之火 - 素食 - 大渡网-佛教资讯，生活，人文，心灵感悟，佛艺时尚杂志，佛教音乐，佛教常识，佛教视频</code></p>
<p><code>从草根到精英——大陆网络民族主义流变-观点评论-时事评论-四月网-青年思想门户-M4.CN</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ignoreSuffixes = Arrays.asList(<span class="string">"频道"</span>, <span class="string">"站"</span>, <span class="string">"网"</span>, <span class="string">"报"</span>, <span class="string">"集"</span>, <span class="string">"公司"</span>, <span class="string">".com"</span>, <span class="string">".cn"</span>, <span class="string">"平台"</span>, <span class="string">"门户"</span>, <span class="string">"博客"</span>, <span class="string">"精选"</span>, <span class="string">"博客精选"</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ignorePrefixes = Arrays.asList(<span class="string">"Powered by"</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;Character&gt; splitChars = <span class="keyword">new</span> HashSet&lt;Character&gt;(Arrays.asList(<span class="string">'|'</span>, <span class="string">'_'</span>, <span class="string">'-'</span>, <span class="string">'—'</span>, <span class="string">'－'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;'</span>, <span class="string">'«'</span>, <span class="string">'»'</span>));</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLongestPart</span><span class="params">(List&lt;String&gt; parts)</span> </span>&#123;</div><div class="line">		<span class="keyword">double</span> longestNumWords = <span class="number">0</span>;</div><div class="line">		String longestPart = <span class="string">""</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.size(); i++) &#123;</div><div class="line">			String p = parts.get(i).trim();</div><div class="line">			</div><div class="line">			<span class="keyword">int</span> ignoreCount = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (String is: ignoreSuffixes) <span class="keyword">if</span> (p.toLowerCase().endsWith(is)) ignoreCount++;</div><div class="line">			<span class="keyword">for</span> (String ip: ignorePrefixes) <span class="keyword">if</span> (p.toLowerCase().startsWith(ip)) ignoreCount++;</div><div class="line">			<span class="keyword">int</span> colonCnt = StringUtils.countMatches(p, <span class="string">","</span>);</div><div class="line">			<span class="keyword">if</span> (colonCnt &gt; <span class="number">0</span>) ignoreCount += colonCnt - <span class="number">1</span>;</div><div class="line">			colonCnt = StringUtils.countMatches(p, <span class="string">"，"</span>);</div><div class="line">			<span class="keyword">if</span> (colonCnt &gt; <span class="number">0</span>) ignoreCount += colonCnt - <span class="number">1</span>;</div><div class="line">			<span class="keyword">double</span> numWords = TextUtil.countNumWords(p);</div><div class="line">			numWords = numWords / (<span class="number">1</span> + <span class="number">2</span> * ignoreCount);</div><div class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) numWords = numWords * <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (numWords &gt; longestNumWords) &#123;</div><div class="line">            	longestNumWords = numWords;</div><div class="line">            	longestPart = p;</div><div class="line">            &#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (longestPart.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> longestPart.trim();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>extractTitle0(root, rawTitle, 1, tq)</code> </p>
<p>传入root和刚才提取的rawTitle，递归遍历root的各个head元素，<code>h</code>，<code>title</code>，每种赋值不同权重。再寻找与rawTitle的最长公共子串。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTitle0</span></span>(node: <span class="type">Node</span>, title: <span class="type">String</span>, weight: <span class="type">Double</span>, tq: <span class="type">PriorityQueue</span>[<span class="type">String</span>], depth: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    node <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> textNode: <span class="type">TextNode</span> =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> text = textNode.text.trim</div><div class="line">        <span class="keyword">if</span> (text.length &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">val</span> lcs = <span class="type">TextUtil</span>.findLcs(title, text)</div><div class="line">          <span class="keyword">val</span> nwords = <span class="type">TextUtil</span>.countNumWords(lcs)</div><div class="line">          <span class="keyword">val</span> pos = title.indexOf(lcs)</div><div class="line">          <span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; nwords &gt; <span class="number">0</span>) &#123;</div><div class="line">            tq.add(nwords * weight / (<span class="number">1</span> + math.log(<span class="number">2</span> + pos)), lcs)</div><div class="line">          &#125;</div><div class="line">        &#125; </div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> e: <span class="type">Element</span> =&gt; &#123;</div><div class="line">        <span class="keyword">var</span> w = weight</div><div class="line">        <span class="keyword">if</span> (e.tagName.startsWith(<span class="string">"h"</span>)) w = w * <span class="number">1.2</span></div><div class="line">        <span class="keyword">if</span> (e.tagName == <span class="string">"a"</span>) w = w / <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> (e.className.contains(<span class="string">"title"</span>)) w = w * <span class="number">1.5</span></div><div class="line">        <span class="keyword">if</span> (e.tagName != <span class="string">"title"</span> &amp;&amp; !isNegativeBlock(e.className + <span class="string">" "</span> + e.id) &amp;&amp; depth &lt; <span class="type">Extract_STOP_DEPTH</span>) &#123;</div><div class="line">          <span class="keyword">for</span> (n &lt;- e.childNodes.asScala) extractTitle0(n, title, w, tq, depth + <span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> _ =&gt; &#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过以上方法提取出各种title后，选出出现频率最高的作为最终的title。</p>
<h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractContent</span></span>(url: <span class="type">String</span>, doc: <span class="type">Document</span>): <span class="type">List</span>[<span class="type">String</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> rawTitle = doc.title</div><div class="line">    <span class="keyword">if</span>(doc.body == <span class="literal">null</span>)</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">    <span class="type">ExtractUtil</span>.cleanup(doc.body)</div><div class="line">    <span class="keyword">val</span> title = <span class="type">ExtractUtil</span>.extractTitle(doc.body, rawTitle)</div><div class="line">    <span class="keyword">val</span> metaKeywords = <span class="type">ExtractUtil</span>.extractMeta(doc, <span class="string">"keywords"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> blocks = <span class="type">ExtractUtil</span>.extractBlocks(doc, title) map &#123; block =&gt;</div><div class="line">      <span class="type">SnippetBlock</span>(block.snippets map &#123; snippet =&gt; <span class="type">TextProcess</span>.normalize(urlReg.matcher(snippet).replaceAll(<span class="string">""</span>)) &#125;, block.score, block.isArticle, block.imgs)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> normalTitle = <span class="type">TextUtil</span>.fillText(title)</div><div class="line">    <span class="keyword">val</span> normalRawTitle = <span class="type">TextUtil</span>.fillText(doc.title)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> allsnippets = blocks.filter(_.isArticle).flatMap &#123; b =&gt; b.snippets &#125;</div><div class="line">    <span class="keyword">return</span> allsnippets;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="清洗doc"><a href="#清洗doc" class="headerlink" title="清洗doc"></a>清洗doc</h3><p><code>ExtractUtil.cleanup(doc.body)</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanup</span></span>(root: <span class="type">Element</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> cleanNodes = <span class="keyword">for</span> &#123;</div><div class="line">      e &lt;- root.getAllElements.asScala</div><div class="line">      <span class="keyword">if</span> <span class="type">INVALID_TAGS</span>.contains(e.tagName) || e.attr(<span class="string">"style"</span>).contains(<span class="string">"display:none"</span>)</div><div class="line">    &#125; <span class="keyword">yield</span> e</div><div class="line">    <span class="keyword">for</span> (cn &lt;- cleanNodes) cn.remove</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="提取title、metakeywords"><a href="#提取title、metakeywords" class="headerlink" title="提取title、metakeywords"></a>提取title、metakeywords</h3><h3 id="提取blocks"><a href="#提取blocks" class="headerlink" title="提取blocks"></a>提取blocks</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractBlocks</span></span>(doc: <span class="type">Document</span>, title: <span class="type">String</span>): <span class="type">List</span>[<span class="type">SnippetBlock</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> blocks = <span class="keyword">new</span> <span class="type">ListBuffer</span>[<span class="type">BlockDetail</span>]</div><div class="line">    <span class="keyword">val</span> bd = <span class="keyword">new</span> <span class="type">BlockDetailBuffer</span></div><div class="line">    extractBlocks(doc.body, blocks, bd)</div><div class="line">    <span class="keyword">if</span> (bd.isDefined) blocks += bd.result</div><div class="line">    calcScore(title, blocks.result filterNot(b =&gt; hasICP(b))) ++ <span class="type">List</span>(<span class="type">SnippetBlock</span>(<span class="type">List</span>(extractMeta(doc, <span class="string">"keywords"</span>)), <span class="number">1</span>d, <span class="literal">true</span>, <span class="type">List</span>()), <span class="type">SnippetBlock</span>(<span class="type">List</span>(extractMeta(doc, <span class="string">"description"</span>)), <span class="number">0</span>d, <span class="literal">false</span>, <span class="type">List</span>()))</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">extractBlocks</span></span>(root: <span class="type">Node</span>, blocks: <span class="type">ListBuffer</span>[<span class="type">BlockDetail</span>], bd: <span class="type">BlockDetailBuffer</span>, inLink: <span class="type">Boolean</span> = <span class="literal">false</span>, depth: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  root <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> tn: <span class="type">TextNode</span> =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> text = <span class="type">StringUtils</span>.replace(tn.text, <span class="string">"\u00a0"</span>, <span class="string">" "</span>).trim</div><div class="line">      <span class="keyword">if</span> (text.length &gt; <span class="number">0</span>) bd.add(text, inLink)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> e: <span class="type">Element</span> =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> isLink = inLink || (e.tagName == <span class="string">"a"</span>) </div><div class="line">      <span class="keyword">if</span>(depth &lt; <span class="type">Extract_STOP_DEPTH</span>)&#123;</div><div class="line">      	e.childNodes.asScala foreach &#123; c =&gt; extractBlocks(c, blocks, bd, isLink, depth + <span class="number">1</span>) &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (e.tagName == <span class="string">"img"</span> || e.tagName == <span class="string">"embed"</span>) &#123;</div><div class="line">        bd.addImg(e)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (e.isBlock) &#123;</div><div class="line">        <span class="keyword">if</span> (bd.isDefined) blocks += bd.result</div><div class="line">        bd.clear</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> _ =&gt; &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提取每个TextNode的文本，放到<code>BlockDetailBuffer</code>中。将每个<code>BlockDetailBuffer</code>的内容放到<code>BlockDetail</code>的list <code>blocks</code>中。</p>
<p>过滤掉包含<code>icp备</code>或<code>icp证</code>的文本，再对所有的blocks计算打分<code>calcScore</code></p>
<p>最后提取所有是文本的snippet，作为content</p>
<h3 id="提取keywords"><a href="#提取keywords" class="headerlink" title="提取keywords"></a>提取keywords</h3><p>同样是先clean，提取title、metaKeyword，</p>
<p>再提取blocks</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> blocks:<span class="type">List</span>[<span class="type">SnippetBlock</span>] =  <span class="type">ExtractUtil</span>.extractBlocks(doc, title).map &#123; block =&gt;</div><div class="line">      &#123;</div><div class="line">              <span class="type">SnippetBlock</span>(block.snippets map &#123; snippet =&gt; <span class="type">TextProcess</span>.normalize(urlReg.matcher(snippet).replaceAll(<span class="string">""</span>)) &#125;, block.score, block.isArticle, block.imgs)</div><div class="line"></div><div class="line">	      <span class="keyword">val</span> temp  = block.snippets map &#123; snippet =&gt; <span class="type">TextProcess</span>.normalize(urlReg.matcher(snippet).replaceAll(<span class="string">""</span>)) &#125;</div><div class="line">	      maxLen += temp.map(<span class="type">AtomSplit</span>.count(_)).sum	</div><div class="line">	      <span class="keyword">val</span> retVal:<span class="type">SnippetBlock</span> = <span class="keyword">if</span>(maxLen &lt; <span class="type">MAX_CONTENT_LENGTH</span> || maxflag)&#123;<span class="type">SnippetBlock</span>(temp, block.score, block.isArticle, block.imgs)&#125; <span class="keyword">else</span> <span class="literal">null</span></div><div class="line">	      <span class="keyword">if</span>(maxLen &gt; <span class="type">MAX_CONTENT_LENGTH</span>)&#123;</div><div class="line">	        maxflag = <span class="literal">false</span></div><div class="line">	      &#125;</div><div class="line">	      retVal</div><div class="line">      &#125;</div><div class="line">    &#125;.filter( _ != <span class="literal">null</span>)</div></pre></td></tr></table></figure>
<h4 id="dlg"><a href="#dlg" class="headerlink" title="dlg"></a>dlg</h4><p>再提取dlg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val dlg = DlgExtractor.extract(normalTitle, TextUtil.fillText(doc.title), blocks, 6)/*.filter(_._2 &gt; 1.0)*/</div></pre></td></tr></table></figure>
<p>分词后，计算每个词的权重，</p>
<p>First of all, for any web page, we can use jsoup to  obtain the Document Object Model (DOM) , which can access all the HTML elements of it.</p>
<p>After that，we clean up  HTML elements by drop some invalid or useless tags, such as the tags with “display:none” property. </p>
<p>At last, We extract the Content and Keywords of HTML. </p>
<p>For extracting Content, we iterate through the DOM tree to find all TextNode elements, extract the text and take them as the Snippets. Then we calculate the scores of all Snippets, and get the available Snippets as Content.</p>
<p>For extracing Keywords, besides the Snippets from TextNode elements, we also collect the title, keywords and description from <meta> tag, store them as Blocks.   For every Block, we segment words to generate the corpus by ansj_seg, and calculate the weight of every word using TFIDF. Finally, we get the TOP 10 words as Keywords of web page.</p>
<p>我们解析了10万左右的网页，根据解析的网页content打上safe和unsafe的label，后期我们会对safe和unsafe进一步细分。</p>
<p>训练过程：我们载入所有含标签的训练样本，由于fasttext提供了适用于各种语言的Word2Vec预向量集，将网页内容转为词向量，通过fasttext训练出模型并保存到本地。</p>
<p>预测过程：载入模型到内存，当输入一个网页的content后，转为词向量，根据模型给出safe或unsafe的分类结果。</p>
<p>We have analyzed some 100 thousand web pages, classified text in categories, such as safe and unsafe by content of these web pages, and we will extent more categories in future.</p>
<p>In order to train the text classifier model, we load all samples containing a training sentence per line along with the labels, and transfer all words to vectors using  pre-trained word vectors model published by fastText.  Then we use the code from Github to run the training program. Once the model was trained, we save it on disk as a file.</p>
<p>When input a content of web page, we transfer it to word vectors and run the prediction program, as a result we get the category of this web page.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/算法与数据结构/动态规划讲解/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/算法与数据结构/动态规划讲解/" class="post-title-link" itemprop="url">动态规划理论</a>
              
            
          </h2>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2019-06-03 09:22:50" itemprop="dateModified" datetime="2019-06-03T09:22:50+08:00">2019-06-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法与数据结构/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态规划理论讲解"><a href="#动态规划理论讲解" class="headerlink" title="动态规划理论讲解"></a>动态规划理论讲解</h1><p>[TOC]</p>
<h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><p><strong>什么是动态规划？什么时候要用动态规划？怎么使用动态规划？</strong></p>
<p><strong>1、什么是动态规划？</strong> </p>
<p>求解决策过程<strong>最优化</strong>的数学方法。把<strong>多阶段过程转化为一系列单阶段</strong>问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。</p>
<p><strong>2、什么时候要用动态规划？</strong></p>
<p>如果要求一个问题的<strong>最优解</strong>（通常是最大值或者最小值），而且该问题能够<strong>分解成若干个子问题，并且小问题之间也存在重叠的子问题</strong>，则考虑采用动态规划。</p>
<p><strong>3、怎么使用动态规划？</strong> </p>
<ol>
<li>判题题意是否为找出一个问题的最优解 </li>
<li>从上往下分析问题，大问题可以分解为子问题，子问题中还有更小的子问题 </li>
<li>从下往上分析问题 ，找出这些问题之间的关联（状态转移方程） </li>
<li>讨论边界的初始条件</li>
<li>解决问题（通常使用数组进行迭代求出最优解）</li>
</ol>
<h1 id="代表算法-硬币问题"><a href="#代表算法-硬币问题" class="headerlink" title="代表算法-硬币问题"></a>代表算法-硬币问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 11 元，问如何组合才能使硬币的数量最少？</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>乍看之下，我们简单的运用一下心算就能解出需要 2 个 5 元和 1 个 1 元的解。当然这里只是列出了这个问题比较简单的情况。当硬币的币制或者种类变化，并且需要凑出的总价值变大时，就很难靠简单的计算得出结论了。贪心算法可以在一定的程度上得出较优解，但不是每次都能得出最优解。</p>
<p>这里运用动态规划的思路解决该问题。按照一般思路，我们先从最基本的情况来一步一步地推导。</p>
<p>我们先假设一个函数 <em>d(i)</em> 来表示需要凑出 <em>i</em> 的总价值需要的最少硬币数量。</p>
<ol>
<li>当 <em>i = 0</em> 时，很显然我们可以知道 <em>d(0) = 0</em>。因为不要凑钱了嘛，当然也不需要任何硬币了。<strong>注意这是很重要的一步，其后所有的结果都从这一步延伸开来</strong>。</li>
<li>当 <em>i = 1</em> 时，因为我们有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 <em>d(1) = 1</em>。</li>
<li>当 <em>i = 2</em> 时，因为我们并没有 2 元的硬币，所以只能拿 1 元的硬币来凑。在第 2 步的基础上，加上 1 个 1 元硬币，得出 <em>d(2) = 2</em>。</li>
<li>当 <em>i = 3</em> 时，我们可以在第 3 步的基础上加上 1 个 1 元硬币，得到 <em>3</em> 这个结果。但其实我们有 3 元硬币，所以这一步的最优结果不是建立在第 3 步的结果上得来的，而是应该建立在第 1 步上，加上 1 个 3 元硬币，得到 <em>d(3) = 1</em>。</li>
</ol>
<p>接着就不再举例了，我们来分析一下。可以看出，除了第 1 步这个看似基本的公理外，其他往后的结果都是建立在它之前得到的某一步的最优解上，加上 1 个硬币得到。得出：</p>
<p><em>d(i) = d(j) + 1</em></p>
<p>这里 <em>j &lt; i</em>。通俗地讲，我们需要凑出 <em>i</em> 元，就在凑出 <em>j</em> 的结果上再加上某一个硬币就行了。</p>
<p>那这里我们加上的是哪个硬币呢。嗯，其实很简单，把每个硬币试一下就行了：</p>
<ol>
<li>假设最后加上的是 1 元硬币，那 <em>d(i) = d(j) + 1 = d(i - 1) + 1</em>。</li>
<li>假设最后加上的是 3 元硬币，那 <em>d(i) = d(j) + 1 = d(i - 3) + 1</em>。</li>
<li>假设最后加上的是 5 元硬币，那 <em>d(i) = d(j) + 1 = d(i - 5) + 1</em>。</li>
</ol>
<p>我们分别计算出 <em>d(i - 1) + 1</em>，<em>d(i - 3) + 1</em>，<em>d(i - 5) + 1</em> 的值，取其中的最小值，即为最优解，也就是 <em>d(i)</em>。</p>
<p>最后公式：</p>
<p><img src="/2017/07/12/算法与数据结构/动态规划讲解/Users/david/david/00projects/00markdown/pic/1046505-20161024143029437-524511140.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCoins</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] coins = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</div><div class="line">        <span class="keyword">int</span> value = <span class="number">11</span>;</div><div class="line">        CoinDp(value, coins);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CoinDp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] coinValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 记录执行次数</span></div><div class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">// 用来存储得到n块钱需要的硬币数的最小值</span></div><div class="line">        min[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            min[i] = Integer.MAX_VALUE;<span class="comment">// 初始化数组中的每个值都是最大的整数</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coinValue.length; j++) &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (i &gt;= coinValue[j] &amp;&amp; min[i] &gt; min[i - coinValue[j]] + <span class="number">1</span>) &#123;</div><div class="line">                    min[i] = min[i - coinValue[j]] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"获取"</span> + i + <span class="string">"块钱，最少需要的硬币数："</span> + min[i] + <span class="string">",执行的次数："</span> + count);</div><div class="line">        &#125;</div><div class="line">        System.out.println(min[n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://blog.csdn.net/weixin_38278878/article/details/80037455" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38278878/article/details/80037455</a></p>
<p><a href="https://www.cnblogs.com/snowInPluto/p/5992846.html" target="_blank" rel="noopener">https://www.cnblogs.com/snowInPluto/p/5992846.html</a></p>
<p><a href="https://www.cnblogs.com/wuyuegb2312/p/3281264.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuyuegb2312/p/3281264.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/29/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Schwimmer</p>
              <div class="site-description motion-element" itemprop="description">Record and Think!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">315</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">Kategorien</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">schlagwörter</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Schwimmer</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.5.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
