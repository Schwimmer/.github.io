<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Record and Think!">
<meta property="og:type" content="website">
<meta property="og:title" content="Schwimmer&#39;s Blog">
<meta property="og:url" content="https://schwimmer.github.io/page/28/index.html">
<meta property="og:site_name" content="Schwimmer&#39;s Blog">
<meta property="og:description" content="Record and Think!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Schwimmer&#39;s Blog">
<meta name="twitter:description" content="Record and Think!">





  
  
  <link rel="canonical" href="https://schwimmer.github.io/page/28/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Schwimmer's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143240576-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-143240576-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Schwimmer's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/数学/利率计算/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/数学/利率计算/" class="post-title-link" itemprop="url">利率计算</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-29 21:42:24" itemprop="dateModified" datetime="2018-01-29T21:42:24+08:00">2018-01-29</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数学/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/数学/利率计算/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/数学/利率计算/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>等额本息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">每月月供额=〔贷款本金×月利率×(1＋月利率)＾还款月数〕÷〔(1＋月利率)＾还款月数-1〕</div><div class="line">每月应还利息=贷款本金×月利率×〔(1+月利率)^还款月数-(1+月利率)^(还款月序号-1)〕÷〔(1+月利率)^还款月数-1〕</div><div class="line">每月应还本金=贷款本金×月利率×(1+月利率)^(还款月序号-1)÷〔(1+月利率)^还款月数-1〕</div><div class="line">总利息=还款月数×每月月供额-贷款本金</div></pre></td></tr></table></figure>
<p>等额本金</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">每月月供额=(贷款本金÷还款月数)+(贷款本金-已归还本金累计额)×月利率</div><div class="line">每月应还本金=贷款本金÷还款月数</div><div class="line">每月应还利息=剩余本金×月利率=(贷款本金-已归还本金累计额)×月利率</div><div class="line">每月月供递减额=每月应还本金×月利率=贷款本金÷还款月数×月利率</div><div class="line">总利息=还款月数×(总贷款额×月利率-月利率×(总贷款额÷还款月数)*(还款月数-1)÷2+总贷款额÷还款月数)</div></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/22920169" target="_blank" rel="noopener">信用卡账单分期真实年化利率</a></p>
<p><img src="https://pic4.zhimg.com/v2-177bf28088e8ef5462e3b5cc3d1ab2eb_b.png" alt=""></p>
<h1 id="年利率"><a href="#年利率" class="headerlink" title="年利率"></a>年利率</h1><p>利息率=利息量÷本金÷时间×100%</p>
<h1 id="IRR"><a href="#IRR" class="headerlink" title="IRR"></a>IRR</h1><p><strong>内部收益率 (IRR) 的定义是：净现值 (NPV) 为零时的折现率。</strong></p>
<p>综合考虑了每期的流入流出现金的量和时间，加权出来的结果。<br>IRR实质上是一个折现率，用IRR折现时会达到该项目的净现值NPV为0的状态。也可以理解为一个项目的预期收益率。<br>举例来说，如IRR为8%，可以简单解释为以8%的利率借钱投资于此项目，刚好可以不赚不赔。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/读书/计算机程序的构造和解释/CH3/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/" class="post-title-link" itemprop="url">第三章 模块化、对象和状态</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 16:02:58" itemprop="dateModified" datetime="2019-06-28T16:02:58+08:00">2019-06-28</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/读书/计算机程序的构造和解释/CH3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三章-模块化、对象和状态"><a href="#第三章-模块化、对象和状态" class="headerlink" title="第三章 模块化、对象和状态"></a>第三章 模块化、对象和状态</h1><h2 id="前两章回顾"><a href="#前两章回顾" class="headerlink" title="前两章回顾"></a>前两章回顾</h2><ol>
<li>如何组合<strong>基本过程</strong>和<strong>基本数据</strong></li>
<li>如何构造各种<strong>复合对象</strong>(组合过程/数据)</li>
<li><strong>抽象</strong>在控制和处理程序复杂性中的重要作用</li>
</ol>
<blockquote>
<p>简单问题1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cons、car和cdr的含义</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>简单问题2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; ;写出以下函数的等价lambda表达式</div><div class="line">&gt; (define (add a b)</div><div class="line">&gt;   (+ a b))</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>但对于程序设计而言，上面这三种手段还不够用，有效设计大型系统，还需要一些组织系统的原则，这体现在下面两方面：</p>
<ol>
<li>只有高效算法，不足以构造出良好的大型系统</li>
<li>系统的功能分解，结构组织和管理与算法一样重要(或更甚之)</li>
</ol>
<p>在大型系统的复杂性问题上，仅学会抽象的思维还不够，还需要一些能帮我们<strong>构造模块化的大型系统的策略</strong>。在这一章，会学习两种组织策略。</p>
<ul>
<li><strong>基于对象的策略</strong></li>
</ul>
<blockquote>
<p>真实系统中的对象随着时间的进展不断变化，模拟它们的系统对象也吸引相应地变化</p>
</blockquote>
<ul>
<li><strong>基于流处理的策略</strong></li>
</ul>
<blockquote>
<p>关注流过系统的信息流</p>
</blockquote>
<h2 id="3-1-赋值和局部状态"><a href="#3-1-赋值和局部状态" class="headerlink" title="3.1 赋值和局部状态"></a>3.1 赋值和局部状态</h2><h3 id="3-1-1-局部状态变量"><a href="#3-1-1-局部状态变量" class="headerlink" title="3.1.1 局部状态变量"></a>3.1.1 局部状态变量</h3><blockquote>
<p>例子：银行取钱</p>
</blockquote>
<p>用withdraw表示该行为，入参amount表示取钱的数量，若账户有足够的钱，返回余额；否则返回Insufficient funds。</p>
<p>为了实现withdraw，我们用一个变量balance表示余额，withdraw检查balance是否够amount，如果是，</p>
<p><code>balance -= amount</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> balance <span class="number">100</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">      (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))</div><div class="line"></div><div class="line">-----------------</div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="number">50</span></div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="number">0</span></div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="string">"Insufficient funds"</span></div></pre></td></tr></table></figure>
<p>其中，set的语法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set! &lt;name&gt; &lt;new-value&gt; )</div></pre></td></tr></table></figure>
<p>begin描述对表达式的求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(begin &lt;exp1&gt;&lt;exp2&gt;...&lt;expk&gt;)</div></pre></td></tr></table></figure>
<p>按顺序求值，并返回最后一个表达式的值。</p>
<p>可以看出，这里的balance是全局变量，在哪里都能读取或修改这个值。如果将其作为局部变量，就只能通过withdraw来访问balance，这样才能更准确的模拟balance这个概念。</p>
<p>于是将其转为局部变量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> new-withdraw</div><div class="line">  (<span class="name">let</span> ((<span class="name">balance</span> <span class="number">100</span>))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))))</div></pre></td></tr></table></figure>
<p>其中，let创建一个包含局部变量的环境，并设初始值。</p>
<p>make-withdraw创建一种”提款处理器”，它的形参balance描述了有关账户的初始值。(把balance当形参传入)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>)))</div><div class="line"></div><div class="line">(<span class="name">define</span> W1 (<span class="name">make-withdraw</span> <span class="number">100</span>))</div><div class="line">(<span class="name">define</span> W2 (<span class="name">make-withdraw</span> <span class="number">100</span>))</div><div class="line"></div><div class="line">-----------------</div><div class="line">&gt; (<span class="name">W1</span> <span class="number">50</span>)</div><div class="line"><span class="number">50</span></div><div class="line">&gt; (<span class="name">W2</span> <span class="number">60</span>)</div><div class="line"><span class="number">40</span></div></pre></td></tr></table></figure>
<p>可以看出，W1和W2是完全独立的对象，每个都有自己的局部状态变量balance。</p>
<p>再创建一个存钱的对象make-account</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line"></div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) withdraw)</div><div class="line">          ((<span class="name">eq</span>? m 'deposit) deposit)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></div><div class="line">                       m))))</div><div class="line"></div><div class="line">  dispatch)</div></pre></td></tr></table></figure>
<p>对make-account的每次调用都会设置好一个带有balance的环境，在这个环境中，定义了能访问balance的过程deposit和withdraw，另外还有一个过程dispatch，它以一个字符串作为输入，返回这两个局部过程之一。</p>
<p>该过程可以这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; (define acc (make-account 100))</div><div class="line"></div><div class="line">; 对acc的每次调用将返回局部定义的过程</div><div class="line">&gt; (acc 'withdraw)</div><div class="line">#&lt;procedure:withdraw&gt;</div><div class="line"></div><div class="line">; 这个过程随后被应用于给定的amount</div><div class="line">&gt; ((acc 'withdraw) 50)</div><div class="line">50</div><div class="line"></div><div class="line">&gt; ((acc 'withdraw) 60)</div><div class="line">"Insufficient funds"</div><div class="line"></div><div class="line">&gt; ((acc 'deposit) 40)</div><div class="line">90</div><div class="line"></div><div class="line">&gt; ((acc 'withdraw) 60)</div><div class="line">30</div><div class="line"></div><div class="line">; 这样将产生另一个完全独立的对象，维护自己的局部balance</div><div class="line">&gt; (define acc2 (make-account 1000))</div></pre></td></tr></table></figure>
<h3 id="3-1-2-引进赋值带来的利益"><a href="#3-1-2-引进赋值带来的利益" class="headerlink" title="3.1.2 引进赋值带来的利益"></a>3.1.2 引进赋值带来的利益</h3><blockquote>
<p>例子：考虑设计一个过程rand，每次被调用就返回一个随机整数</p>
</blockquote>
<p>“随机”是指，对rand的反复调用将产生出一系列的数，这一序列具有均匀分布的统计性质。</p>
<p>假设现在有一个过程rand-update，如果给定一个数x1，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x2 = (rand-update x1)</div><div class="line">x3 = (rand-update x2)</div></pre></td></tr></table></figure>
<p>得到序列x1, x2, x3…将具有我们希望的性质</p>
<p>可以将rand时限为一个带局部状态变量x的过程，初始化为某个固定值random-init，对rand的每次调用算出当前x的rand-update值，返回作为随机数，并将其更新为x的新值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> random-init <span class="number">7</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rand-update</span> x)</div><div class="line">  (<span class="name">let</span> ((<span class="name">a</span> <span class="number">27</span>) (<span class="name">b</span> <span class="number">26</span>) (<span class="name">m</span> <span class="number">127</span>))</div><div class="line">    (<span class="name">modulo</span> (<span class="name">+</span> (<span class="name">*</span> a x) b) m)))</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> rand</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</div><div class="line">      x)))</div></pre></td></tr></table></figure>
<p>当然，你也可以在需要随机数的时候直接调用rand-update，生成同样的随机数序列。但缺点是，这就<strong>需要程序中任何使用随机数的地方都必须显式的记住x的值</strong>，在生成下一个时，将x的值传给rand-update作为参数。</p>
<p>考虑用随机数实现<strong><em>蒙特卡洛法</em></strong> monte-carlo</p>
<blockquote>
<p> 蒙特卡洛模拟：从总体抽取大量随机样本，并通过这些随机样本估计这一随机事件的概率，将这个概率作为问题的解。</p>
</blockquote>
<p>比如，$6/\pi^2$是随机选取的两个整数之间没有公共因子（最大公因子（greatest common divisor，GCD）是1）的概率。</p>
<p>则可以通过每次随机选择两个证书并检查它们的GCD是否为1来近似的获得这个概率，π的近似求值。（Cesaro定理）</p>
<p><a href="https://zhuanlan.zhihu.com/p/47978393" target="_blank" rel="noopener">理解黎曼猜想（二）两个自然数互质的概率是多少？</a></p>
<p>那么，这个过程的核心就是蒙特卡洛模拟（monte-carlo），<strong>它以做某个实验的次数，以及这个实现本身作为参数</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">estimate-pi</span> trials)</div><div class="line">  (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> (<span class="name">monte-carlo</span> trials cesaro-test))))</div><div class="line"></div><div class="line"><span class="comment">; Cesaro实验</span></div><div class="line">(<span class="name">define</span> (<span class="name">cesaro-test</span>)</div><div class="line">  (<span class="name">=</span> (<span class="name">gcd</span> (<span class="name">rand</span>) (<span class="name">rand</span>)) <span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">; 做某个实验的次数，以及这个实现本身作为参数</span></div><div class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> trials experiment)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</div><div class="line">           (<span class="name">/</span> trials-passed trials))</div><div class="line">          ((<span class="name">experiment</span>)</div><div class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) (<span class="name">+</span> trials-passed <span class="number">1</span>)))</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) trials-passed))))</div><div class="line">  (<span class="name">iter</span> trials <span class="number">0</span>))</div><div class="line"></div><div class="line">---------------------</div><div class="line">&gt; (<span class="name">estimate-pi</span> <span class="number">50</span>)</div><div class="line"><span class="number">2.449489742783178</span></div></pre></td></tr></table></figure>
<p>现在试一下不用rand，直接用rand-update，如果不使用赋值去模拟局部状态，则</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">random-gcd-test</span> trials initial-x)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed x)</div><div class="line">    (<span class="name">let</span> ((<span class="name">x1</span> (<span class="name">rand-update</span> x)))</div><div class="line">      (<span class="name">let</span> ((<span class="name">x2</span> (<span class="name">rand-update</span> x1)))</div><div class="line">        (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</div><div class="line">               (<span class="name">/</span> trials-passed trials))</div><div class="line">              ((<span class="name">=</span> (<span class="name">gcd</span> x1 x2) <span class="number">1</span>)</div><div class="line">               (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</div><div class="line">                     (<span class="name">+</span> trials-passed <span class="number">1</span>)</div><div class="line">                     x2))</div><div class="line">              (<span class="name">else</span></div><div class="line">                (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</div><div class="line">                      trials-passed</div><div class="line">                      x2))))))</div><div class="line">  (<span class="name">iter</span> trials <span class="number">0</span> initial-x))</div></pre></td></tr></table></figure>
<p>很明显看到区别，在上面的方法中，蒙特卡洛可以<strong>抽象出一个公共方法，不限制experiment的具体形式</strong>，而下面的方法中，由于没有随机数生成器的局部状态，random-gcd-test必须显式的操作随机数x1和x2。</p>
<p>赋值和局部变量的好处：</p>
<blockquote>
<p>从复杂计算的角度来看，其他部分都像是<strong>随着时间不断变化，而它们自己隐藏起随时间变化的内部状态</strong>（比如银行账户和随机数生成器）。因此在进行系统抽象的时候，用<strong>局部变量去模拟系统的状态</strong>，用对这些<strong>变量的赋值去模拟状态的变化</strong>。</p>
</blockquote>
<h3 id="3-1-3-引进赋值的代价"><a href="#3-1-3-引进赋值的代价" class="headerlink" title="3.1.3 引进赋值的代价"></a>3.1.3 引进赋值的代价</h3><p>只要不使用赋值，以同样参数对同意过程的两次求值<strong>一定能产生同样的效果</strong>，就像在计算数学函数。不用任何赋值的程序设计成为<strong>函数式编程</strong>。</p>
<p><em>赋值如何让事情复杂化了？</em></p>
<p>来看make-withdraw的一个简化版本，其中不再关注是否有足够余额的问题：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; The Costs of Introducing Assignment</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-simplified-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">    balance))</div><div class="line">(<span class="name">define</span> W (<span class="name">make-simplified-withdraw</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div><div class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</div><div class="line"><span class="number">-15</span></div></pre></td></tr></table></figure>
<p>如果没有set</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-decrementer</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">-</span> balance amount)))</div><div class="line">(<span class="name">define</span> D (<span class="name">make-decrementer</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>用<strong>代换模型</strong>来解释<code>make-decrementer</code>如何工作。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((<span class="name">make-decrementer</span> <span class="number">25</span>) <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="comment">; 25代替balance</span></div><div class="line">((<span class="name">lambda</span> (<span class="name">amount</span>) (<span class="name">-</span> <span class="number">25</span> amount)) <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="comment">; 应用运算符，20代替lambda中的amount</span></div><div class="line">(<span class="name">-</span> <span class="number">25</span> <span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>类似的，来看<code>make-simplified-withdraw</code>如何工作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((make-simplified-withdraw 25)   20)</div><div class="line"></div><div class="line">; 25代替balance</div><div class="line">((lambda (amount) (set! balance (- 25 amount)) 25)   20))</div><div class="line"></div><div class="line">; 20代替lambda中的amount，先将balance设为5，再返回25</div><div class="line">(set! balance (- 25 20)) 25</div></pre></td></tr></table></figure>
<p>可见这里如果用<strong>代换模型</strong>，则这个过程首先将balance设为5，再返回25，显示是有问题的。造成这种问题的根源是：</p>
<p>在代换模型中，语言的符号（如balance）就是<strong>值的名字</strong>，而一旦引进了<strong>set和变量的值可以变化</strong>的想法，一个变量就不再是一个简单的名字了。</p>
<p><strong>同一和变化</strong></p>
<p>从这里暴露出的问题，远远不是打破了一个简单的计算模型，其意义要深远得多。一旦将变化引入了我们的计算模型，许多以前非常简单明了的概念现在都变得有问题了。</p>
<p>首先考虑两个物体实际上“<strong>同一</strong>”的概念。如果一个语言在表达式里支持“同一的东西可以相互替换”的概念，这样替换不会改变表达式的值，这个语言就称为是具有<font color="#FF0033" size="5">引用透明性</font>。</p>
<p>在我们的计算机语言包含了赋值操作之后，也就打破了引用透明性，产生了<strong>副作用</strong>。</p>
<ul>
<li><strong>修改变量的值</strong></li>
<li>IO 操作，如写数据到磁盘</li>
<li>UI 操作，如修改了一个按钮的可操作状态</li>
</ul>
<p><a href="https://juejin.im/post/5a58134751882573370794cc" target="_blank" rel="noopener">引用透明性和等式推理</a></p>
<p><strong>命令式编程的缺陷</strong></p>
<p>除了引入变量和赋值导致计算模型的复杂性之外，还容易出现一些不会在函数式编程中出现的错误，比如：</p>
<p>1.2.1节的迭代求阶乘</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> product counter)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</div><div class="line">      product</div><div class="line">        <span class="comment">; 注意这里</span></div><div class="line">      (<span class="name">iter</span> (<span class="name">*</span> counter product)</div><div class="line">	    (<span class="name">+</span> counter <span class="number">1</span>))))</div><div class="line">  (<span class="name">iter</span> <span class="number">1</span> <span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>如果用命令式编程，显式的通过赋值去更新变量product和counter的值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">  (<span class="name">let</span> ((<span class="name">product</span> <span class="number">1</span>)</div><div class="line">	(<span class="name">counter</span> <span class="number">1</span>))</div><div class="line">    (<span class="name">define</span> (<span class="name">iter</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</div><div class="line">	product</div><div class="line">          <span class="comment">; 这两行的陷阱</span></div><div class="line">	(<span class="name">begin</span> (<span class="name">set!</span> product (<span class="name">*</span> counter product))</div><div class="line">	       (<span class="name">set!</span> counter (<span class="name">+</span> counter <span class="number">1</span>))</div><div class="line">	       (<span class="name">iter</span>))))</div><div class="line">    (<span class="name">iter</span>)))</div></pre></td></tr></table></figure>
<p>上述写法是正确的，但是如果颠倒其中两行的顺序</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;(set! counter (+ counter 1))</span></div><div class="line"><span class="comment">;(set! product (* counter product))</span></div></pre></td></tr></table></figure>
<p>结果就不对了。一般来说，<strong>带有赋值操作的程序强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本</strong>。</p>
<p>接下来要解决的问题就是，要给涉及赋值的表达式提供一种区别于之前的计算模型。</p>
<h2 id="3-2-求值的环境模型"><a href="#3-2-求值的环境模型" class="headerlink" title="3.2 求值的环境模型"></a>3.2 求值的环境模型</h2><p>之前说<strong>代换模型</strong>不再适用于赋值表达式。由于赋值操作的存在，此时的变量必须以某种方式指定了一个“位置”，相应的值可以存储在那里。在我们的新求值模型里，这种位置将维持在称为 <strong>环境</strong> 的结构中。</p>
<p>一些概念：</p>
<p>1）<strong>环境</strong>：<strong>框架</strong>的一个序列</p>
<p>2）<strong>框架</strong>：每个框架包含着一些 <strong>约束</strong> 的表格</p>
<p>3）<strong>约束</strong>：变量名和值相关联。（在一个框架里，任何变量至多只能有一个约束）</p>
<p>4）<strong>指针</strong>：每个框架还包含着一个<strong>指针</strong>，指向这一框架的<em>外围环境</em>。</p>
<p>5）<strong>变量</strong>：一个<em>变量</em>相对于某个特定环境的<em>值</em>，</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_1.png" alt="img"></p>
<p>​                                                                                一个简单的环境结构</p>
<p>1、2、3是三个框架，  ABCD都是环境指针，其中CD指向同一个环境。</p>
<p>环境对于求值过程是至关重要的，因为它确定了表达式求值的上下文。假设始终有一个全局环境，只包含一个框架（没有外围环境），这个环境包含所有关于基本过程的符号的值。</p>
<h3 id="3-2-1-求值规则"><a href="#3-2-1-求值规则" class="headerlink" title="3.2.1 求值规则"></a>3.2.1 求值规则</h3><p>在求值的环境模型中，过程只能通过一种方式创建，那就是通过求值一个lambda表达式。例如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">  (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p>过程定义的语法形式，不过是作为隐含lambda表达式的语法糖，等价于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> square</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_3.png" alt="img"></p>
<p>过程对象的环境部分是一个指向全局环境的指针，因此产生这个过程的lambda表达式是在全局环境中求值的。</p>
<p>这里增加了一个新约束：将过程对象约束给符号square。一般来说，<strong>define就是把一个新的约束加入到框架中</strong>。</p>
<p>假设现在对表达式<code>(square 5)</code>求值，结果是创建了一个新环境——E1。</p>
<p>1）E1从一个框架开始，这个框架包含5赋值给x的约束。</p>
<p>2）E1引出的指针表示这个框架的外围环境是全局环境</p>
<p><strong>过程应用的环境模型</strong>：</p>
<ul>
<li>将一个过程对象应用于一组实际参数，将<strong>构造出一个新框架</strong>，其中将过程的<strong>形式参数约束到调用时的实际参数</strong>，而后在构造起的这一新环境的<strong>上下文中求值过程体</strong>。这个新框架的外围环境就是作为被应用的那个过程对象的一部分的环境。</li>
<li>相对于一个给定环境<strong>求值一个 lambda表达式</strong>，将会创建起一个过程对象，这个过程对象是一个序对，由该 lambda表达式 的正文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时的环境。</li>
</ul>
<p>关于<code>set!</code>的行为方式</p>
<p>在某个环境里求值 <strong><em>赋值表达式</em></strong> 时，要求我们首先在环境中确定有关变量的约束位置，而后再修改这个约束，使之表示这个新值。</p>
<p>这也就是说，首先需要<strong>找到包含这个变量的约束的第一个框架，而后修改这一框架</strong>。如果该变量在环境中没有约束，将报告一个错误。</p>
<h3 id="3-2-2-简单过程的应用"><a href="#3-2-2-简单过程的应用" class="headerlink" title="3.2.2 简单过程的应用"></a>3.2.2 简单过程的应用</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">  (<span class="name">*</span> x x))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-of-squares</span> x y)</div><div class="line">  (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">f</span> a)</div><div class="line">  (<span class="name">sum-of-squares</span> (<span class="name">+</span> a <span class="number">1</span>) (<span class="name">*</span> a <span class="number">2</span>)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_4.png" alt="img"></p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_5.png" alt="img"></p>
<p>求值 <code>(f 5)</code>：</p>
<ol>
<li>创建一个新环境 <code>E1</code>，参数 <code>a</code> 被约束到 5。在 <code>E1</code> 中求值 <code>(sum-of-square (+ a 1) (* a2))</code></li>
<li>求值组合式，首先求值子表达式。第一个子表达式 <code>sum-of-square</code> 以一个过程对象为值。（在 <code>E1</code> 的框架中未寻找到约束，而后进入有关的外围环境，并找到约束）</li>
<li>创建环境 <code>E2</code>，现在需要把过程对象 <code>sum-of-square</code> 应用于实参 6 和 10。</li>
</ol>
<h2 id="3-3-用变动的数据做模拟"><a href="#3-3-用变动的数据做模拟" class="headerlink" title="3.3 用变动的数据做模拟"></a>3.3 用变动的数据做模拟</h2><h3 id="3-3-1-变动的表结构"><a href="#3-3-1-变动的表结构" class="headerlink" title="3.3.1 变动的表结构"></a>3.3.1 变动的表结构</h3><p>针对序对的基本改变函数是set-car!和set-cdr!。<code>set-car!</code>要求两个参数，其中第一个参数必须是一个序对。然后修改这个序对，将它的car指针替换为指向set-car!第二个参数的指针。</p>
<p>假设x是<code>((a b) c d)</code>，y是<code>(e f)</code>，执行</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190612130259772.png" alt="image-20190612130259772"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set-car! x y)</div></pre></td></tr></table></figure>
<p>修改x约束的那个表，将它的car用y的值取代。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190612130309732.png" alt="image-20190612130309732"></p>
<p><strong>共享和相等</strong></p>
<p>当不同的数据对象共享某些序对时，会产生一些问题。例如，考虑下面的结构：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> x (<span class="name">list</span> 'a 'b))</div><div class="line">(<span class="name">define</span> z1 (<span class="name">cons</span> x x))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617143714166.png" alt="image-20190617143714166"></p>
<p>这里的z1是一个序对，car和cdr都指向同一个序对x。</p>
<p>再看另一个结构</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> z2 </div><div class="line">  (<span class="name">cons</span> (<span class="name">list</span> 'a 'b) (<span class="name">list</span> 'a 'b)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617143741708.png" alt="image-20190617143741708"></p>
<p>两个表(a, b)的各个序对互不相同，虽然其中的符号是共享的。</p>
<p>作为表考虑，z1和z2表示同一个表<code>((a b) a b)</code>。一般而言，如果我们只用cons、car、cdr，z1和z2看不出差别。然而，<strong>如果允许修改表结构，共享的情况就会体现出差别</strong>。考虑下面的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">set-to-wow!</span> x)</div><div class="line">  (<span class="name">set-car!</span> (<span class="name">car</span> x) 'wow)</div><div class="line">  x)</div></pre></td></tr></table></figure>
<p>将<code>set-to-wow!</code>应用于z1和z2，将产生不同的结果。对于z1，修改car也就同时修改了cdr。而对于z2，只修改了car。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; z1</div><div class="line">((<span class="name">a</span> b) a b)</div><div class="line"></div><div class="line">&gt; (<span class="name">set-to-wow!</span> z1)</div><div class="line">((<span class="name">wow</span> b) wow b)</div><div class="line"></div><div class="line">&gt; z2</div><div class="line">((<span class="name">a</span> b) a b)</div><div class="line"></div><div class="line">&gt; (<span class="name">set-to-wow!</span> z2)</div><div class="line">((<span class="name">wow</span> b) a b)</div></pre></td></tr></table></figure>
<p>检测表结构是否共享的一种方式是使用<strong>谓词eq?</strong>。谓词<code>(eq? x y)</code>检查x和y作为指针是否相等。这样，对于z1和z2，<code>(eq? (car z1) (cdr z1))</code> 为true <code>(eq? (car z2) (cdr z2))</code> 为false。</p>
<h3 id="3-3-2-队列的表示"><a href="#3-3-2-队列的表示" class="headerlink" title="3.3.2 队列的表示"></a>3.3.2 队列的表示</h3><p>利用<code>set-car!</code> 和 <code>set-cdr!</code>，我们可以用序对构造出一些单靠cons、car、cdr无法构造的数据结构。这一节展示如何构造<strong>队列</strong>。</p>
<p>一个队列是一个序对，数据只能从一端插入（队列的尾），另一端删除（队列的首）。下面显示一个初始是空的队列，之后插入a和b，再删除a，再插入c和d，再删除b。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617145657417.png" alt="image-20190617145657417"></p>
<p>队列可以看做是由下面一组操作定义的结构：</p>
<ul>
<li>一个构造函数(make-queue) ，返回一个空队列。</li>
<li>两个选择函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(empty-queue? ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>检查队列是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(front-queue ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>返回队首的对象，如果空就报错。</p>
<ul>
<li>两个改变函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(insert-queue! ⟨queue⟩ ⟨item⟩)</div></pre></td></tr></table></figure>
<p>插入队尾，返回修改后的队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(delete-queue! ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>删除队首对象，返回修改后的队列。</p>
<p>队列可以表示成一个常规的表，用car、cdr来完成上述操作。但是效率很低，为了插入一个数据项，需要扫描整个表，有<code>O(n)</code>的时间复杂度。那么简单修改一下表的表示方式，就可以只需<code>O(1)</code>的时间复杂度。方法就是加入一个指向队列尾的指针，这里就有两个指针<code>front-ptr</code> 和<code>rear-ptr</code>。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617155741378.png" alt="image-20190617155741378"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">front-ptr</span> queue) (<span class="name">car</span> queue))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rear-ptr</span> queue) (<span class="name">cdr</span> queue))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-front-ptr!</span> queue item) </div><div class="line">  (<span class="name">set-car!</span> queue item))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-rear-ptr!</span> queue item) </div><div class="line">  (<span class="name">set-cdr!</span> queue item))</div></pre></td></tr></table></figure>
<p>现在来实现队列的其他操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(define (empty-queue? queue) </div><div class="line">  (null? (front-ptr queue)))</div><div class="line">  </div><div class="line">(define (make-queue) (cons '() '()))</div><div class="line"></div><div class="line">(define (front-queue queue)</div><div class="line">  (if (empty-queue? queue)</div><div class="line">      (error "FRONT called with an </div><div class="line">              empty queue" queue)</div><div class="line">      (car (front-ptr queue))))</div></pre></td></tr></table></figure>
<p>如果要插入一个对象，按照下图的方式，</p>
<p>1）创建一个新队列，car是需要插入的项，cdr是空表。</p>
<p>2）若队列原来是空，就让<code>front-ptr</code> 和<code>rear-ptr</code>共同指向新序对。否则就修改rear-ptr，而指向新序对。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617162453179.png" alt="image-20190617162453179"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert-queue!</span> queue item)</div><div class="line">  (<span class="name">let</span> ((<span class="name">new-pair</span> (<span class="name">cons</span> item '())))</div><div class="line">    (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">           (<span class="name">set-front-ptr!</span> queue new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue)</div><div class="line">          (<span class="name">else</span> (<span class="name">set-cdr!</span> (<span class="name">rear-ptr</span> queue) </div><div class="line">                          new-pair)</div><div class="line">                (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">                queue))))</div></pre></td></tr></table></figure>
<p>要删除对象，就修改front-ptr，指向第二个数据项。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(define (delete-queue! queue)</div><div class="line">  (cond ((empty-queue? queue)</div><div class="line">         (error "DELETE! called with </div><div class="line">                 an empty queue" queue))</div><div class="line">        (else (set-front-ptr! </div><div class="line">               queue </div><div class="line">               (cdr (front-ptr queue)))</div><div class="line">              queue)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617165406898.png" alt="image-20190617165406898"></p>
<h3 id="3-3-3-表格的表示"><a href="#3-3-3-表格的表示" class="headerlink" title="3.3.3 表格的表示"></a>3.3.3 表格的表示</h3><p>首先考虑一维表格的问题，每个记录实现为key和value的序对。这些记录连接起来就构成一个序对的表。为了向表格里面插入记录时有可以修改的位置，将这种表格构造为一种<strong>带有表头单元的表</strong>。表开头有一个“哑”记录——存放一个特殊符号，<code>*table*</code>。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617170617702.png" alt="image-20190617170617702"></p>
<p>为了从表格中提取信息，定义lookup过程，以key为参数，返回value。lookup基于assoc定义。assoc返回key的那条记录。lookup检查assoc返回的记录是否为假，而后返回value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">cdr</span> record)</div><div class="line">        false)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">assoc</span> key records)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? records) false)</div><div class="line">        ((<span class="name">equal</span>? key (<span class="name">caar</span> records)) </div><div class="line">         (<span class="name">car</span> records))</div><div class="line">        (<span class="name">else</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> records)))))</div></pre></td></tr></table></figure>
<p>如果是插入操作，</p>
<p>1）首先用assoc检查表格中是否有这个key，如果没有，就cons这个key和value，构造出一个新记录。接着插入到表的最前面，位于哑记录之后。</p>
<p>2）如果表格中存在这个记录，就用该记录的cdr设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">set-cdr!</span> record value)</div><div class="line">        (<span class="name">set-cdr!</span> table</div><div class="line">                  (<span class="name">cons</span> (<span class="name">cons</span> key value) </div><div class="line">                        (<span class="name">cdr</span> table)))))</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<p>在构造一个新表时，只需创建起一个包含符号<code>*table*</code>的表。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</div><div class="line">  (<span class="name">list</span> '*table*))</div></pre></td></tr></table></figure>
<p><strong>二维表格</strong></p>
<p>二维表格的每个值用两个key索引。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/../../../../../../Desktop/image-20190617172806860.png" alt="image-20190617172806860"></p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617172821310.png" alt="image-20190617172821310"></p>
<p>二维表的查询。先用第一个key确定对应的子表格，而后用第二个key确定value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key-1 key-2 table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> subtable</div><div class="line">        (<span class="name">let</span> ((<span class="name">record</span> </div><div class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</div><div class="line">          (<span class="name">if</span> record (<span class="name">cdr</span> record) false))</div><div class="line">        false)))</div></pre></td></tr></table></figure>
<p>二维表的插入。首先用assoc查看key-1是否有一个子表格，没有就构造，其中只包含一个记录<code>(key-2, value)</code>。若有，就将新值插入该子表格。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key-1 key-2 value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> subtable</div><div class="line">        (<span class="name">let</span> ((<span class="name">record</span> </div><div class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</div><div class="line">          (<span class="name">if</span> record</div><div class="line">              (<span class="name">set-cdr!</span> record value)</div><div class="line">              (<span class="name">set-cdr!</span> </div><div class="line">               subtable</div><div class="line">               (<span class="name">cons</span> (<span class="name">cons</span> key-2 value)</div><div class="line">                     (<span class="name">cdr</span> subtable)))))</div><div class="line">        (<span class="name">set-cdr!</span> </div><div class="line">         table</div><div class="line">         (<span class="name">cons</span> (<span class="name">list</span> key-1 (<span class="name">cons</span> key-2 value))</div><div class="line">               (<span class="name">cdr</span> table)))))</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<p><strong>创建局部表格</strong></p>
<p>上述的lookup和insert!都以整个表格为参数，这也使我们可以将它们用到包含多个表格的程序中。处理多个表格的方式是为每个表格提供一对独立的lookup和insert！过程。</p>
<p>实现的方案是，用过程表示表格，将表格表示为一个以局部状态的方式维持一个内部表格的对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">(define (make-table)</div><div class="line">  (let ((local-table (list '*table*)))</div><div class="line">    (define (lookup key-1 key-2)</div><div class="line">      (let ((subtable </div><div class="line">             (assoc key-1 (cdr local-table))))</div><div class="line">        (if subtable</div><div class="line">            (let ((record </div><div class="line">                   (assoc key-2 </div><div class="line">                          (cdr subtable))))</div><div class="line">              (if record (cdr record) false))</div><div class="line">            false)))</div><div class="line">    (define (insert! key-1 key-2 value)</div><div class="line">      (let ((subtable </div><div class="line">             (assoc key-1 (cdr local-table))))</div><div class="line">        (if subtable</div><div class="line">            (let ((record </div><div class="line">                   (assoc key-2 </div><div class="line">                          (cdr subtable))))</div><div class="line">              (if record</div><div class="line">                  (set-cdr! record value)</div><div class="line">                  (set-cdr! </div><div class="line">                   subtable</div><div class="line">                   (cons (cons key-2 value)</div><div class="line">                         (cdr subtable)))))</div><div class="line">            (set-cdr! </div><div class="line">             local-table</div><div class="line">             (cons (list key-1</div><div class="line">                         (cons key-2 value))</div><div class="line">                   (cdr local-table)))))</div><div class="line">      'ok)</div><div class="line">    (define (dispatch m)</div><div class="line">      (cond ((eq? m 'lookup-proc) lookup)</div><div class="line">            ((eq? m 'insert-proc!) insert!)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          TABLE" m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure>
<p>利用make-table，我们可以实现get和put操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> operation-table (<span class="name">make-table</span>))</div><div class="line">(<span class="name">define</span> get (<span class="name">operation-table</span> 'lookup-proc))</div><div class="line">(<span class="name">define</span> put (<span class="name">operation-table</span> 'insert-proc!))</div></pre></td></tr></table></figure>
<p>这两个操作都访问同一个局部表格，这一表格被封装在由对make-table的调用创建起的对象里面。</p>
<h3 id="3-3-4-数字电路的模拟器"><a href="#3-3-4-数字电路的模拟器" class="headerlink" title="3.3.4 数字电路的模拟器"></a>3.3.4 数字电路的模拟器</h3><p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618100752926.png" alt="image-20190618100752926"></p>
<p>连接基本组件来构造更复杂的功能。比如下面的<strong>半加器</strong>电路，包括一个或门，两个与门和一个非门。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618101130329.png" alt="image-20190618101130329"></p>
<p>当A=1或B=1之一是1时，S=1，当A=1且B=1时，C=1。</p>
<blockquote>
<p><strong>半加器</strong></p>
<p>半加器是实现两个一位二进制数加法运算的器件。它具有两个输入端(被加数A和加数B)及输出端Y。 [1] </p>
<p>A和B是相加的两个数，S是半加和数，C是进位数。</p>
<p>所谓半加就是不考虑进位的加法，它的真值表如下 (见表)：</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618103146103.png" alt="image-20190618103146103"></p>
</blockquote>
<p>现在要构造一个程序来模拟数字逻辑电路。最基本元素是make-wire，用于构造连线。比如可以构造出</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> a (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> b (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> c (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> d (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> e (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> s (<span class="name">make-wire</span>))</div></pre></td></tr></table></figure>
<p>如果需要把一个功能连到一组连线上，就调用一个构造这类功能的过程，参数就是连线。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">or-gate</span> a b d)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">and-gate</span> a b c)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">inverter</span> c e)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">and-gate</span> d e s)</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>再拼接成<strong>半加器</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">half-adder</span> a b s c)</div><div class="line">  (<span class="name">let</span> ((<span class="name">d</span> (<span class="name">make-wire</span>)) (<span class="name">e</span> (<span class="name">make-wire</span>)))</div><div class="line">    (<span class="name">or-gate</span> a b d)</div><div class="line">    (<span class="name">and-gate</span> a b c)</div><div class="line">    (<span class="name">inverter</span> c e)</div><div class="line">    (<span class="name">and-gate</span> d e s)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<p>在这个基础上，可以再构建<strong>全加器</strong>。</p>
<blockquote>
<p><strong>全加器</strong></p>
<p>全加器能进行加数、被加数和低位来的进位信号相加，并根据求和结果给出该位的进位信号。</p>
<p>当多位数相加时，半加器可用于最低位求和，并给出进位数。第二位的相加有两个待加数和，还有一个来自前面低位送来的进位数。这三个数相加，得出本位和数（全加和数）和进位数。这种就是“全加“，下表为全加器的逻辑状态表。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/o4YBAFtYGTaAfKmzAAAvuawUHgA437.png" alt="åå å¨åå¨å å¨çåçååºå«ï¼ç»æååè½ï¼"></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">full-adder</span> a b c-in sum c-out)</div><div class="line">  (<span class="name">let</span> ((<span class="name">c1</span> (<span class="name">make-wire</span>)) </div><div class="line">        (<span class="name">c2</span> (<span class="name">make-wire</span>))</div><div class="line">        (<span class="name">s</span>  (<span class="name">make-wire</span>)))</div><div class="line">    (<span class="name">half-adder</span> b c-in s c1)</div><div class="line">    (<span class="name">half-adder</span> a s sum c2)</div><div class="line">    (<span class="name">or-gate</span> c1 c2 c-out)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618113425796.png" alt="image-20190618113425796"></p>
<p>从模拟器的角度，各种功能块构成了基础，将功能块连接起来就是这里的组合方法，而将特定的连接模式定义为过程就是这里的抽象方法。</p>
<h4 id="基本功能块"><a href="#基本功能块" class="headerlink" title="基本功能块"></a><strong>基本功能块</strong></h4><p>基本功能块使得在一根连线上的信号变化能够影响其他连线上的信号。我们添加如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(get-signal ⟨wire⟩)</div></pre></td></tr></table></figure>
<p>返回连线上信号的当前值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set-signal! ⟨wire⟩ ⟨new value⟩)</div></pre></td></tr></table></figure>
<p>将连线上信号修改为新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)</div></pre></td></tr></table></figure>
<p>改变信号值就需要执行该过程。这种过程是一些媒介，能够将相应连线上值的变化传递到其他的连线。</p>
<p>利用这些过程，可以定义基本的数字逻辑功能了。为了把输入通过一个反门连接到输出，用add-action! 为输入关联一个过程，当输入路线的值改变时，执行这一过程。</p>
<p>先看<strong>非门</strong>，在一个inverter-delay后将输出线路设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">inverter</span> input output)</div><div class="line">  (<span class="name">define</span> (<span class="name">invert-input</span>)</div><div class="line">    (<span class="name">let</span> ((<span class="name">new-value</span> </div><div class="line">           (<span class="name">logical-not</span> (<span class="name">get-signal</span> input))))</div><div class="line">      (<span class="name">after-delay</span> </div><div class="line">       inverter-delay</div><div class="line">       (<span class="name">lambda</span> ()</div><div class="line">         (<span class="name">set-signal!</span> output new-value)))))</div><div class="line">  </div><div class="line">  (<span class="name">add-action!</span> input invert-input)</div><div class="line">  'ok)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">logical-not</span> s)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> s <span class="number">0</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">=</span> s <span class="number">1</span>) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s))))</div></pre></td></tr></table></figure>
<p>下面是<strong>与门</strong>的定义。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">and-gate</span> a1 a2 output)</div><div class="line">  (<span class="name">define</span> (<span class="name">and-action-procedure</span>)</div><div class="line">    (<span class="name">let</span> ((<span class="name">new-value</span></div><div class="line">           (<span class="name">logical-and</span> (<span class="name">get-signal</span> a1) </div><div class="line">                        (<span class="name">get-signal</span> a2))))</div><div class="line">      (<span class="name">after-delay</span> </div><div class="line">       and-gate-delay</div><div class="line">       (<span class="name">lambda</span> ()</div><div class="line">         (<span class="name">set-signal!</span> output new-value)))))</div><div class="line">  </div><div class="line">  (<span class="name">add-action!</span> a1 and-action-procedure)</div><div class="line">  (<span class="name">add-action!</span> a2 and-action-procedure)</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<h4 id="线路的表示"><a href="#线路的表示" class="headerlink" title="线路的表示"></a><strong>线路的表示</strong></h4><p>一条线路是一个具有两个局部状态变量的计算对象：一个是信号值signal-value（初值为0），一个是一组过程action-procedures，在信号值改变时，这些过程需要运行。类似于在3.1.1中处理银行账户的做法实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(define (make-wire)</div><div class="line">  (let ((signal-value 0) </div><div class="line">        (action-procedures '()))</div><div class="line">       </div><div class="line">    (define (set-my-signal! new-value)</div><div class="line">      (if (not (= signal-value new-value))</div><div class="line">          (begin (set! signal-value new-value)</div><div class="line">                 (call-each </div><div class="line">                  action-procedures))</div><div class="line">          'done))</div><div class="line">       </div><div class="line">    (define (accept-action-procedure! proc)</div><div class="line">      (set! action-procedures </div><div class="line">            (cons proc action-procedures))</div><div class="line">      (proc))</div><div class="line">       </div><div class="line">    (define (dispatch m)</div><div class="line">      (cond ((eq? m 'get-signal) </div><div class="line">             signal-value)</div><div class="line">            ((eq? m 'set-signal!) </div><div class="line">             set-my-signal!)</div><div class="line">            ((eq? m 'add-action!) </div><div class="line">             accept-action-procedure!)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          WIRE" m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure>
<p><code>set-my-signal!</code>检查新的信号值是否实际改变了线路上的信号，如果是，就用<code>call-each</code>运行每个动作过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">call-each</span> procedures)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? procedures)</div><div class="line">      'done</div><div class="line">      (<span class="name">begin</span> ((<span class="name">car</span> procedures))</div><div class="line">             (<span class="name">call-each</span> (<span class="name">cdr</span> procedures)))))</div></pre></td></tr></table></figure>
<p>一旦设置好dispatch过程，就可以提供以下访问线路中局部操作的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">get-signal</span> wire)</div><div class="line">  (<span class="name">wire</span> 'get-signal))</div><div class="line">(<span class="name">define</span> (<span class="name">set-signal!</span> wire new-value)</div><div class="line">  ((<span class="name">wire</span> 'set-signal!) new-value))</div><div class="line">(<span class="name">define</span> (<span class="name">add-action!</span> wire action-procedure)</div><div class="line">  ((<span class="name">wire</span> 'add-action!) action-procedure))</div></pre></td></tr></table></figure>
<h4 id="待处理表agenda"><a href="#待处理表agenda" class="headerlink" title="待处理表agenda"></a><strong>待处理表agenda</strong></h4><p>最后是after-delay的实现。要维护一个称为待处理表的数据结构，包含需要完成的事项清单。定义如下操作：</p>
<ul>
<li><code>(make-agenda)</code> 返回一个新的空agenda.</li>
<li><code>(empty-agenda? ⟨agenda⟩)</code> .</li>
<li><code>(first-agenda-item ⟨agenda⟩)</code> 返回agenda第一个item.</li>
<li><code>(remove-first-agenda-item! ⟨agenda⟩)</code> .</li>
<li><code>(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)</code> </li>
<li><code>(current-time ⟨agenda⟩)</code> 返回当时的模拟时间。</li>
</ul>
<p>用<code>the-agenda</code>表示特定的待处理表。以下过程向<code>the-agenda</code>中插入一个新item</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">after-delay</span> delay action)</div><div class="line">  (<span class="name">add-to-agenda!</span> </div><div class="line">   (<span class="name">+</span> delay (<span class="name">current-time</span> the-agenda))</div><div class="line">   action</div><div class="line">   the-agenda))</div></pre></td></tr></table></figure>
<p>agenda中的模拟过程用propagate实现，它操作<code>the-agenda</code>，顺序执行agenda的每个过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">propagate</span>)</div><div class="line">  (<span class="name">if</span> (<span class="name">empty-agenda</span>? the-agenda)</div><div class="line">      'done</div><div class="line">      (<span class="name">let</span> ((<span class="name">first-item</span> </div><div class="line">             (<span class="name">first-agenda-item</span> the-agenda)))</div><div class="line">        (<span class="name">first-item</span>)</div><div class="line">        (<span class="name">remove-first-agenda-item!</span> the-agenda)</div><div class="line">        (<span class="name">propagate</span>))))</div></pre></td></tr></table></figure>
<h4 id="一个简单的实例模拟"><a href="#一个简单的实例模拟" class="headerlink" title="一个简单的实例模拟"></a>一个简单的实例模拟</h4><p>下面过程将一个<strong>监测器</strong>放到一个线路上，用于显示模拟器的活动。这一过程会告诉相应线路，只要它的值改变了，就打印出新的值，同时打印当前时间和线路名称。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">probe</span> name wire)</div><div class="line">  (<span class="name">add-action!</span> </div><div class="line">   wire</div><div class="line">   (<span class="name">lambda</span> ()</div><div class="line">     (<span class="name">newline</span>)</div><div class="line">     (<span class="name">display</span> name)</div><div class="line">     (<span class="name">display</span> <span class="string">" "</span>)</div><div class="line">     (<span class="name">display</span> (<span class="name">current-time</span> the-agenda))</div><div class="line">     (<span class="name">display</span> <span class="string">"  New-value = "</span>)</div><div class="line">     (<span class="name">display</span> (<span class="name">get-signal</span> wire)))))</div></pre></td></tr></table></figure>
<p>我们从初始化待处理表和描述各种功能块的延时开始</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> the-agenda (<span class="name">make-agenda</span>))</div><div class="line">(<span class="name">define</span> inverter-delay <span class="number">2</span>)</div><div class="line">(<span class="name">define</span> and-gate-delay <span class="number">3</span>)</div><div class="line">(<span class="name">define</span> or-gate-delay <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>现在定义4条线路，在其中两条线路上安装监测器</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> input-1 (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> input-2 (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> sum (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> carry (<span class="name">make-wire</span>))</div><div class="line"></div><div class="line">(<span class="name">probe</span> 'sum sum)</div><div class="line">sum <span class="number">0</span>  New-value = <span class="number">0</span></div><div class="line"></div><div class="line">(<span class="name">probe</span> 'carry carry)</div><div class="line">carry <span class="number">0</span>  New-value = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>然后将这些线路连接到一个半加器电路上</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">half-adder</span> input-1 input-2 sum carry)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">set-signal!</span> input-1 <span class="number">1</span>)</div><div class="line">done</div><div class="line"></div><div class="line">(<span class="name">propagate</span>)</div><div class="line">sum <span class="number">8</span>  New-value = <span class="number">1</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>在时间8, sum上的信号变为1。现在到了模拟开始之后的8个时间单位。在这一点上，我们可 以将input-2上的信号设置为1，并让有关的值向前传播：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">set-signal!</span> input-2 <span class="number">1</span>)</div><div class="line">done</div><div class="line"></div><div class="line">(<span class="name">propagate</span>)</div><div class="line">carry <span class="number">11</span>  New-value = <span class="number">1</span></div><div class="line">sum <span class="number">16</span>  New-value = <span class="number">0</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>在时间11处，carry变成1，16处sum变成0。</p>
<h4 id="agenda的实现"><a href="#agenda的实现" class="headerlink" title="agenda的实现"></a>agenda的实现</h4><p>这种待处理表由一些时间段组成，每个时间段是由一个数值（表示时间）和一个队列(见练习3.32)组成的序对，在这个队列里，保存着那些已经安排好的，应该在这一时间段运行的过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-time-segment</span> time queue)</div><div class="line">  (<span class="name">cons</span> time queue))</div><div class="line">(<span class="name">define</span> (<span class="name">segment-time</span> s) (<span class="name">car</span> s))</div><div class="line">(<span class="name">define</span> (<span class="name">segment-queue</span> s) (<span class="name">cdr</span> s))</div></pre></td></tr></table></figure>
<p>我们将用3.3.2节描述的队列操作完成在时间段队列上的操作。<br>待处理表本身就是时间段的一个一维表格。与3.3.3节所示的表格的不同之处，就在于这 些时间段应该按照时间递增的顺序排列。此外，我们还需在待处理表的头部保存一个当前时 间（即，此前最后被处理的那个动作的时间）。一个新构造出的待处理表里没有时间段，其当前时间是0。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-agenda</span>) (<span class="name">list</span> <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">current-time</span> agenda) (<span class="name">car</span> agenda))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-current-time!</span> agenda time)</div><div class="line">  (<span class="name">set-car!</span> agenda time))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">segments</span> agenda) (<span class="name">cdr</span> agenda))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-segments!</span> agenda segments)</div><div class="line">  (<span class="name">set-cdr!</span> agenda segments))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">first-segment</span> agenda) </div><div class="line">  (<span class="name">car</span> (<span class="name">segments</span> agenda)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rest-segments</span> agenda) </div><div class="line">  (<span class="name">cdr</span> (<span class="name">segments</span> agenda)))</div></pre></td></tr></table></figure>
<p>若一个agenda没有时间段，那它就是空的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">empty-agenda</span>? agenda)</div><div class="line">  (<span class="name">null</span>? (<span class="name">segments</span> agenda)))</div></pre></td></tr></table></figure>
<p>为了将一个动作加入待处理表，</p>
<p>1）我们首先要检査这个待处理表是否为空。如果真是这样，那么就<strong>创建一个新的时间段</strong>，并将这个时间段装入待处理表里。</p>
<p>2）否则我们就扫描整个的待处理表，检査其中各个时间段的时间。如果发现某个时间段具有合适的时间，那么就把这个动作加入与之关联的队列里。如果碰到了某个比需要预约的时间更晚的时间，那么就将一个新的时间段插入待处理表，插入这个位置之前。如果到达了待处理表的末尾，我们就必须在最后加上一个新的时间段。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-to-agenda!</span> time action agenda)</div><div class="line">  (<span class="name">define</span> (<span class="name">belongs-before</span>? segments)</div><div class="line">    (<span class="name">or</span> (<span class="name">null</span>? segments)</div><div class="line">        (<span class="name">&lt;</span> time </div><div class="line">           (<span class="name">segment-time</span> (<span class="name">car</span> segments)))))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">make-new-time-segment</span> time action)</div><div class="line">    (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">make-queue</span>)))</div><div class="line">      (<span class="name">insert-queue!</span> q action)</div><div class="line">      (<span class="name">make-time-segment</span> time q)))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">add-to-segments!</span> segments)</div><div class="line">    (<span class="name">if</span> (<span class="name">=</span> (<span class="name">segment-time</span> (<span class="name">car</span> segments)) time)</div><div class="line">        (<span class="name">insert-queue!</span> </div><div class="line">         (<span class="name">segment-queue</span> (<span class="name">car</span> segments))</div><div class="line">         action)</div><div class="line">        (<span class="name">let</span> ((<span class="name">rest</span> (<span class="name">cdr</span> segments)))</div><div class="line">          (<span class="name">if</span> (<span class="name">belongs-before</span>? rest)</div><div class="line">              (<span class="name">set-cdr!</span></div><div class="line">               segments</div><div class="line">               (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </div><div class="line">                      time </div><div class="line">                      action)</div><div class="line">                     (<span class="name">cdr</span> segments)))</div><div class="line">              (<span class="name">add-to-segments!</span> rest)))))</div><div class="line">  (<span class="name">let</span> ((<span class="name">segments</span> (<span class="name">segments</span> agenda)))</div><div class="line">    (<span class="name">if</span> (<span class="name">belongs-before</span>? segments)</div><div class="line">        (<span class="name">set-segments!</span></div><div class="line">         agenda</div><div class="line">         (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </div><div class="line">                time </div><div class="line">                action)</div><div class="line">               segments))</div><div class="line">        (<span class="name">add-to-segments!</span> segments))))</div></pre></td></tr></table></figure>
<p>从待处理表中<strong>删除第一项</strong>的过程，应该删去第一个时间段的队列前端的那一项。如果删 除使这个时间段变空了，我们就将这个时间段也从时间段的表里删去:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">remove-first-agenda-item!</span> agenda)</div><div class="line">  (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">segment-queue</span> </div><div class="line">            (<span class="name">first-segment</span> agenda))))</div><div class="line">    (<span class="name">delete-queue!</span> q)</div><div class="line">    (<span class="name">if</span> (<span class="name">empty-queue</span>? q)</div><div class="line">        (<span class="name">set-segments!</span> </div><div class="line">         agenda </div><div class="line">         (<span class="name">rest-segments</span> agenda)))))</div></pre></td></tr></table></figure>
<p>找出待处理表中里第一项，也就是找出其第一个时间段队列里的第一项。无论何时提取 这个项时，都需要更新待处理表的当前时间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(define (first-agenda-item agenda)</div><div class="line">  (if (empty-agenda? agenda)</div><div class="line">      (error "Agenda is empty: </div><div class="line">              FIRST-AGENDA-ITEM")</div><div class="line">      (let ((first-seg </div><div class="line">             (first-segment agenda)))</div><div class="line">        (set-current-time! </div><div class="line">         agenda </div><div class="line">         (segment-time first-seg))</div><div class="line">        (front-queue </div><div class="line">         (segment-queue first-seg)))))</div></pre></td></tr></table></figure>
<h3 id="3-3-5-约束的传播"><a href="#3-3-5-约束的传播" class="headerlink" title="3.3.5 约束的传播"></a>3.3.5 约束的传播</h3><p>在传统上，<strong>计算机程序总被组织成一种单向的计算，它们对一些事先给定的参数执行某些操作，产生出所需要的输出。</strong>但在另一方面，我们也经常需要模拟一些<strong>由各种量之间的关系描述的系统</strong>。例如，某个机械结构的数学模型里可能包含着这样的一些信息：在一个金属杆的偏转量d与作用于这个杆的力F、杆的长度L、截面面积A和弹性模数之间的关系可以由下面方程描述</p>
<script type="math/tex; mode=display">
dAE=FL</script><p>这种关系并不是单向的，<strong>给定了其中任意的4个量，我们就可以利用它计算出第5个量</strong>。然而，<strong>要将这种方程翻译到传统的程序设计语言，就会迫使我们选出一个量，要求基于另外的4个量去计算出它</strong>。这样，一个用于计算面积A的过程将不能用于计算偏转量。虽然对于A和d的计算都出自这同一个方程。</p>
<p>在这一节里，我们要描绘一种语言的设计，这种语言将使我们可以基于各种关系进行工作。这一语言里的基本元素就是基本约束，它们描述了在不同量之间的某种特定关系。例如，<code>(adder a b c)</code>描述的是量a、b和c之间必须有关系$a+b=c$，<code>(multiplier x y z)</code>描述的是约束关系$xy=z$，而<code>(constant 3.14 x)</code>表示x的值永远都是3.14。</p>
<p>我们的语言里还提供了一些方法，使它们可以用于组合各种基本约束，以便去描述更复杂的关系。在这里，我们将通过构造<strong>约束网络</strong>的方式组合起各种约束，在这种约束网络里，约束通过<strong>连接器</strong>连接起来。连接器是一种对象，它们可以“保存”一个值，使之能参与一个<br>或者多个约束。例如，我们知道在华氏温度和摄氏温度之间的关系是：</p>
<script type="math/tex; mode=display">
9C=5(F-32)</script><p>这样的约束就可以看做是一个网络。通过基本<strong>加法约束</strong>、<strong>乘法约束</strong>和<strong>常量约束</strong>组成。在这个图里，我们看到左边的乘法块有三个引线，分别标记为 m1 、 m2 和p。该乘法约束的这些引线以如下方式连接到网络的其他部分：引线 m1连到连接器 C ，这个连接器将保存摄氏温度。引线 m2 接在连接器 w ，该连接器还连接着一个保存常量 9 的约束块。引线 p 被这一乘法块约束到 m1和 m2 的乘积，它还连接到另一个乘法块的引线p。另一乘法块的 m2连接到常量 5 ，它的 m1 连接到另一加法块的一条引线上。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618163207055.png" alt="image-20190618163207055"></p>
<h4 id="约束系统的使用"><a href="#约束系统的使用" class="headerlink" title="约束系统的使用"></a>约束系统的使用</h4><p>首先调用构造函数make-connector，创建起两个连接器C和F</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> C (<span class="name">make-connector</span>))</div><div class="line">(<span class="name">define</span> F (<span class="name">make-connector</span>))</div><div class="line">(<span class="name">celsius-fahrenheit-converter</span> C F)</div><div class="line">ok</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">celsius-fahrenheit-converter</span> c f)</div><div class="line">  (<span class="name">let</span> ((<span class="name">u</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">v</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">w</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">x</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">y</span> (<span class="name">make-connector</span>)))</div><div class="line">    (<span class="name">multiplier</span> c w u)</div><div class="line">    (<span class="name">multiplier</span> v x u)</div><div class="line">    (<span class="name">adder</span> v y f)</div><div class="line">    (<span class="name">constant</span> <span class="number">9</span> w)</div><div class="line">    (<span class="name">constant</span> <span class="number">5</span> x)</div><div class="line">    (<span class="name">constant</span> <span class="number">32</span> y)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<h4 id="约束系统的实现"><a href="#约束系统的实现" class="headerlink" title="约束系统的实现"></a>约束系统的实现</h4><p>类似于数字电路模拟器。虽然约束系统里的基本对象在某些方面更复杂一些,但整个系统却更为简单,因为这里完全不需要关心待处理表和时间延迟等等问题。</p>
<p>连接器的基本操作包括</p>
<ul>
<li><code>(has-value? ⟨connector⟩)</code> .</li>
<li><code>(get-value ⟨connector⟩)</code> .</li>
<li><code>(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)</code> </li>
<li><code>(forget-value! ⟨connector⟩ ⟨retractor⟩)</code> 要求连接器忘记改值。</li>
<li><code>(connect ⟨connector⟩ ⟨new-constraint⟩)</code> 通过连接器参与一个新约束。</li>
</ul>
<p>通过<code>inform-about-value</code>与各个相关约束通信，这一过程告知给定的约束，该连接器有了新值。而<code>inform-about-no-value</code>告知该连接器丧失了原有的值。</p>
<p><code>adder</code>在被求和连接器a1和a2和连接器sum之间构造出一个加法约束。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">; adder将一个新的加法约束连接到指定连接器。me就代表那个加法约束。</div><div class="line">(define (adder a1 a2 sum)</div><div class="line">  ; 当加法约束得到了通知，知道自己的一个连接器有了新值后，process-new-value就会被调用。</div><div class="line">  (define (process-new-value)</div><div class="line">    (cond ((and (has-value? a1) </div><div class="line">                (has-value? a2))</div><div class="line">           (set-value! sum</div><div class="line">                       (+ (get-value a1) </div><div class="line">                          (get-value a2))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? a1) </div><div class="line">                (has-value? sum))</div><div class="line">           (set-value! a2</div><div class="line">                       (- (get-value sum) </div><div class="line">                          (get-value a1))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? a2) </div><div class="line">                (has-value? sum))</div><div class="line">           (set-value! a1</div><div class="line">                       (- (get-value sum) </div><div class="line">                          (get-value a2))</div><div class="line">                       me))))</div><div class="line">  ; 如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行process-new-value。</div><div class="line">  (define (process-forget-value)</div><div class="line">    (forget-value! sum me)</div><div class="line">    (forget-value! a1 me)</div><div class="line">    (forget-value! a2 me)</div><div class="line">    (process-new-value))</div><div class="line">  </div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else (error "Unknown request: </div><div class="line">                        ADDER" request))))</div><div class="line">  (connect a1 me)</div><div class="line">  (connect a2 me)</div><div class="line">  (connect sum me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<p><code>adder</code>将一个新的加法约束连接到指定连接器。<code>me</code>就代表那个加法约束。</p>
<p>当加法约束得到了通知，知道自己的一个连接器有了新值后，<code>process-new-value</code>就会被调用。</p>
<p>如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行<code>process-new-value</code>。</p>
<p>乘法对象类似于加法对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">(define (multiplier m1 m2 product)</div><div class="line">  </div><div class="line">  (define (process-new-value)</div><div class="line">    (cond ((or (and (has-value? m1) </div><div class="line">                    (= (get-value m1) 0))</div><div class="line">               (and (has-value? m2) </div><div class="line">                    (= (get-value m2) 0)))</div><div class="line">           (set-value! product 0 me))</div><div class="line">          ((and (has-value? m1) </div><div class="line">                (has-value? m2))</div><div class="line">           (set-value! product</div><div class="line">                       (* (get-value m1) </div><div class="line">                          (get-value m2))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? product) </div><div class="line">                (has-value? m1))</div><div class="line">           (set-value! m2</div><div class="line">                       (/ (get-value product) </div><div class="line">                          (get-value m1))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? product) </div><div class="line">                (has-value? m2))</div><div class="line">           (set-value! m1</div><div class="line">                       (/ (get-value product) </div><div class="line">                          (get-value m2))</div><div class="line">                       me))))</div><div class="line">  </div><div class="line">  (define (process-forget-value)</div><div class="line">    (forget-value! product me)</div><div class="line">    (forget-value! m1 me)</div><div class="line">    (forget-value! m2 me)</div><div class="line">    (process-new-value))</div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else</div><div class="line">           (error "Unknown request: </div><div class="line">                   MULTIPLIER" </div><div class="line">                  request))))</div><div class="line">  (connect m1 me)</div><div class="line">  (connect m2 me)</div><div class="line">  (connect product me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<p>最后，<strong>监视器</strong>在指定连接器被设置或取消值的时候打印出一个消息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(define (probe name connector)</div><div class="line">  (define (print-probe value)</div><div class="line">    (newline) (display "Probe: ")</div><div class="line">    (display name) (display " = ")</div><div class="line">    (display value))</div><div class="line">  (define (process-new-value)</div><div class="line">    (print-probe (get-value connector)))</div><div class="line">  (define (process-forget-value)</div><div class="line">    (print-probe "?"))</div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else (error "Unknown request: </div><div class="line">                        PROBE" request))))</div><div class="line">  (connect connector me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<h4 id="连接器的表示"><a href="#连接器的表示" class="headerlink" title="连接器的表示"></a>连接器的表示</h4><p>连接器用带有局部状态变量value，informant和constraint的过程对象表示，value中保存这个连接器的当前值，informant是设置连接器值的对象，constraint是这一连接器所涉及的所有约束的表。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">(define (make-connector)</div><div class="line">  (let ((value false) </div><div class="line">        (informant false) </div><div class="line">        (constraints '()))</div><div class="line">    ; 当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。</div><div class="line">    (define (set-my-value newval setter)</div><div class="line">      ; 如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束</div><div class="line">      (cond ((not (has-value? me))</div><div class="line">             (set! value newval)</div><div class="line">             (set! informant setter)</div><div class="line">             ; 而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的那个约束之外</div><div class="line">             (for-each-except </div><div class="line">              setter</div><div class="line">              inform-about-value</div><div class="line">              constraints))</div><div class="line">            ((not (= value newval))</div><div class="line">             (error "Contradiction" </div><div class="line">                    (list value newval)))</div><div class="line">            (else 'ignored)))</div><div class="line">       </div><div class="line">    ; 当连接器被要求忘记自己的值时，它就会去运行局部过程forget-my-value。</div><div class="line">    (define (forget-my-value retractor)</div><div class="line">      ; 首先检査这一要求是否来自原先设置值的同一个对象</div><div class="line">      (if (eq? retractor informant)</div><div class="line">          (begin (set! informant false)</div><div class="line">                 ; 如果情况确实如此，连接器就通知它所参与的所有约束，告知它们自己的值已经没有了。</div><div class="line">                 (for-each-except </div><div class="line">                  retractor</div><div class="line">                  inform-about-no-value</div><div class="line">                  constraints))</div><div class="line">          'ignored))</div><div class="line">       </div><div class="line">    ; connect向约束表里加入一个新约束（如果它以前不在表里)。如果这个连接器已经有值，它就会将这一事实通知这个新约束。</div><div class="line">    (define (connect new-constraint)</div><div class="line">      (if (not (memq new-constraint </div><div class="line">                     constraints))</div><div class="line">          (set! constraints</div><div class="line">                (cons new-constraint </div><div class="line">                      constraints)))</div><div class="line">      (if (has-value? me)</div><div class="line">          (inform-about-value new-constraint))</div><div class="line">      'done)</div><div class="line">       </div><div class="line">    ; 连接器过程me完成对于内部过程服务的分派工作，它同时也作为这个连接器对象的代表</div><div class="line">    (define (me request)</div><div class="line">      (cond ((eq? request 'has-value?)</div><div class="line">             (if informant true false))</div><div class="line">            ((eq? request 'value) value)</div><div class="line">            ((eq? request 'set-value!) </div><div class="line">             set-my-value)</div><div class="line">            ((eq? request 'forget) </div><div class="line">             forget-my-value)</div><div class="line">            ((eq? request 'connect) connect)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          CONNECTOR"</div><div class="line">                         request))))</div><div class="line">    me))</div></pre></td></tr></table></figure>
<p>当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束。而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的<br>那个约束之外。这一工作通过下面的迭代过程完成，它将一个指定过程应用于一个表中的所有对象，除了一个给定的例外：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; 将一个指定过程应用于一个表中的所有对象</span></div><div class="line">(<span class="name">define</span> (<span class="name">for-each-except</span> exception </div><div class="line">                         procedure </div><div class="line">                         list)</div><div class="line">  (<span class="name">define</span> (<span class="name">loop</span> items)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">null</span>? items) 'done)</div><div class="line">          ((<span class="name">eq</span>? (<span class="name">car</span> items) exception) </div><div class="line">           (<span class="name">loop</span> (<span class="name">cdr</span> items)))</div><div class="line">          (<span class="name">else</span> (<span class="name">procedure</span> (<span class="name">car</span> items))</div><div class="line">                (<span class="name">loop</span> (<span class="name">cdr</span> items)))))</div><div class="line">  (<span class="name">loop</span> list))</div></pre></td></tr></table></figure>
<p>下面几个过程为分派提供了一个语法界面：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">has-value</span>? connector)</div><div class="line">  (<span class="name">connector</span> 'has-value?))</div><div class="line">(<span class="name">define</span> (<span class="name">get-value</span> connector)</div><div class="line">  (<span class="name">connector</span> 'value))</div><div class="line">(<span class="name">define</span> (<span class="name">set-value!</span> connector </div><div class="line">                    new-value </div><div class="line">                    informant)</div><div class="line">  ((<span class="name">connector</span> 'set-value!) </div><div class="line">   new-value </div><div class="line">   informant))</div><div class="line">(<span class="name">define</span> (<span class="name">forget-value!</span> connector retractor)</div><div class="line">  ((<span class="name">connector</span> 'forget) retractor))</div><div class="line">(<span class="name">define</span> (<span class="name">connect</span> connector new-constraint)</div><div class="line">  ((<span class="name">connector</span> 'connect) new-constraint))</div></pre></td></tr></table></figure>
<h2 id="3-4-并发：时间是一个本质问题"><a href="#3-4-并发：时间是一个本质问题" class="headerlink" title="3.4 并发：时间是一个本质问题"></a>3.4 并发：时间是一个本质问题</h2><p>在并发的情况下，由赋值引入的复杂性问题将变得更加严重。</p>
<h3 id="3-4-1-并发系统中时间的性质"><a href="#3-4-1-并发系统中时间的性质" class="headerlink" title="3.4.1 并发系统中时间的性质"></a>3.4.1 并发系统中时间的性质</h3><p>假设由Peter和Paul进行的取款被实现为两个独立的进程，共享同一个变量balance</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/TB2lzajiVXXXXcHXXXXXXXXXXXX_!!581166664.png" alt="Peterä¸Paulåæ¶ååä¸ä¸ªè´¦æ·çä¸ç§åºæ¯"></p>
<p><strong>并发程序的正确行为</strong></p>
<ul>
<li>1）对并发地一种可能限制方式是：规定能修改共享状态变量的两个操作都不允许同时发生。（<strong>低效</strong>）</li>
<li>2）另一种不严厉的方式是：保证并发系统产生的结果与各个进程<strong>按照某种方式顺序运行产生出的结果</strong>完全一样。<ul>
<li>2.1）它并没有要求各个进程实际上顺序地运行，而只是要求它们<strong>产生的结果与 <em>假设</em> 它们顺序运行所产生的结果相同</strong>。</li>
<li>2.2）一个并发程序完全可能产生多于一个 “正确的” 结果，因为我们只要求其结果与按照 <em>某种</em> 方式顺序化的结果相同。</li>
</ul>
</li>
</ul>
<p>对于2.2），比如Peter和Paul的共享账户有100，Peter存入40，同时Paul取出账户中钱的一半。则可能产生两种余额，70或90。</p>
<h3 id="3-4-2-控制并发的机制"><a href="#3-4-2-控制并发的机制" class="headerlink" title="3.4.2 控制并发的机制"></a>3.4.2 控制并发的机制</h3><p>在设计并发系统时，设法做出一些一般性的机制，使我们可能<strong>限制并行进程之间的交错情况</strong>，以保证程序具有正确的行为方式。<br>人们已经为此目的而开发了许多不同的机制，我们讨论其中的一种：<strong>串行化组</strong>（serializer）</p>
<p><strong>对共享变量的串行访问</strong></p>
<p><strong>串行化</strong>：使进程可以并发地执行，但是其中也有一些过程不能并发地执行。</p>
<p>Scheme的串行化</p>
<p>通过<strong>串行化组</strong>实现这种限制。构造的方式是调用make-serializer，这一过程的实现将在后面给出。对一个给定串行化组的所有调用返回的串行化过程都属于同一个集合。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line"></div><div class="line">  <span class="comment">; 关键改动</span></div><div class="line">  (<span class="name">let</span> ((<span class="name">protected</span> (<span class="name">make-serializer</span>)))</div><div class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) (<span class="name">protected</span> withdraw))</div><div class="line">            ((<span class="name">eq</span>? m 'deposit) (<span class="name">protected</span> deposit))</div><div class="line">            ((<span class="name">eq</span>? m 'balance) deposit)</div><div class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></div><div class="line">                         m))))</div></pre></td></tr></table></figure>
<p><strong>使用多重共享资源的复杂性</strong></p>
<p>如果只存在一个共享资源（如银行账户），串行化的使用问题相对简单。如果存在多项共享资源，并发程序的设计就可能变得非常难以把握了。</p>
<p>比如现在可以交换两个账户的余额。假设Peter和Paul都能访问账户a1, a2, a3。Peter要交换a1和a3，同时Paul要交换a1和a2，虽然对单个账户做了串行化，但交换操作还是可能产生不正确的结果。</p>
<p><strong>串行化的实现</strong></p>
<p>使用<strong>互斥元（mutex）</strong>的同步机制来实现串行化。mutex是一种对象，提供两种操作</p>
<p>1）获取（acquired）</p>
<p>2）释放（released）</p>
<p>一旦一个mutex被获取，对它的任何操作都必须等released之后。</p>
<p>在make-serializer的实现中，关联一个mutex。<strong>给定一个过程p，串行化组先返回一个mutex，再运行p，然后释放mutex，这样就能保证这个串行化组产生的所有过程中，一次只能运行一个p</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-serializer</span>)</div><div class="line">   (<span class="name">let</span> ((<span class="name">mutex</span> (<span class="name">make-mutex</span>))</div><div class="line">         (<span class="name">lambda</span> (<span class="name">p</span>)</div><div class="line">           (<span class="name">define</span> (<span class="name">serialized-p</span> . args)</div><div class="line">             (<span class="name">mutex</span> 'acquired)</div><div class="line">             (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">apply</span> p args)))</div><div class="line">               (<span class="name">mutex</span> 'release)</div><div class="line">               val))</div><div class="line">           serialized-p))))</div></pre></td></tr></table></figure>
<p>mutex是一个Boolean，在mutex的构造函数中，初始化为false。</p>
<p>在acquired时，先判断是否为false，若是，设置为true然后使用；否则在循环中等待，直到检测为false。</p>
<p>在acquired操作时，有一个<code>test-and-set!</code>方法，用于检查mutex并返回结果，其中若检查结果为false，在返回false之前还要设置为true。</p>
<p>这里的关键是，<code>test-and-set!</code>必须以原子操作的方式执行。比如说，一旦某进程检查了一个mutex发现是false，就必须在其他进程检查这个mutex之前完成为true的设置，否则mutex的机制就失效了。目前多CPU的电脑中提供了专门指令，直接在硬件中支持原子操作。</p>
<p><strong>死锁</strong></p>
<p>比如Peter要交换a2和a1，则进入了保护a2的串行化进程；Paul同时要交换a1和a2，则进入了保护a1的串行化进程。于是双方都无法继续了。</p>
<p>避免死锁的一种方式，就是首先给每个账户确定一个<strong>唯一的标识编号</strong>，再重写serialized-exchange，使每个进程总是首先去<strong>保护较低编号</strong>的账户。</p>
<p><strong>并发性、时间和通信</strong></p>
<p>我们已经看到，在并发系统的程序设计中，为什么需要去控制不同进程访问共享变量的事件发生的顺序，也看到了如何通过审慎地使用串行化去完成这方面的控制。但是并发性的基本问题比这些更深刻，因为，从一种更基本的观点看，“共享状态”究竟意味着什么，这件事常常并不清楚。</p>
<p>像<code>test-and-set!</code>这样的机制，都要求进程能在任意时刻去检查一个全局性的共享标志。在实现新型高速处理器时，由于在那里需要采用各种优化技术，例如流水线和缓存，因此就不可能在每个时刻都保持存储器内容的一致性，此时完成上述的检查将很有问题，也必然非常低效。正因为这样，在当前的多处理器系统里，串行化方式正在被并发控制的各种新技术取代，比如<strong>屏障同步</strong></p>
<h2 id="3-5-流"><a href="#3-5-流" class="headerlink" title="3.5 流"></a>3.5 流</h2><p>流是另一种模拟现实物理世界的设计策略，其核心思想就是<strong>用数学概念上的函数来表示一现实物体的改变</strong>，比如对象X，可以用<code>X(t)</code>来表示，如果我们想集中关心的是一个个时刻的x，那么就可以将它看作一个变化的量。如果关注的是这些值的整个时间史，那么就不需要强调其中的变化——这一函数本身是没有改变的。</p>
<p>在第二章我们学习了<strong>序列</strong>和<strong>表</strong>的概念（P84）。从抽象的观点看，流也是一个序列，但如果把流表示为表，必能完全揭示流处理的威力。这里要引入一种叫“<strong>延时求值</strong>”的技术。</p>
<h3 id="3-5-1-流作为延时的表"><a href="#3-5-1-流作为延时的表" class="headerlink" title="3.5.1 流作为延时的表"></a>3.5.1 流作为延时的表</h3><p>我们之前建立了一些对序列操作的抽象机制，比如map、filter、accumulate等。但如果我们将序列表示为表，表达可以更优雅，但效率很低。</p>
<p>例如，要计算一个区间内的素数之和。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? sequence)</div><div class="line">    initial</div><div class="line">    (<span class="name">op</span> (<span class="name">car</span> sequence)</div><div class="line">        (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">prime</span>? n)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> n next)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> n next) #t)</div><div class="line">          ((<span class="name">=</span> <span class="number">0</span> (<span class="name">remainder</span> n next)) #f)</div><div class="line">          (<span class="name">else</span> (<span class="name">iter</span> n (<span class="name">+</span> next <span class="number">1</span>)))))</div><div class="line">  (<span class="name">iter</span> n <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">    '()</div><div class="line">    (<span class="name">cons</span> low (<span class="name">enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>) high))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">filter</span> predicate sequence)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? sequence) '())</div><div class="line">        ((<span class="name">predicate</span> (<span class="name">car</span> sequence))</div><div class="line">         (<span class="name">cons</span> (<span class="name">car</span> sequence)</div><div class="line">               (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence))))</div><div class="line">        (<span class="name">else</span> (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> count accum)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">&gt;</span> count b) accum)</div><div class="line">          ((<span class="name">prime</span>? count) (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) (<span class="name">+</span> count accum))</div><div class="line">          (<span class="name">else</span> (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) accum))))</div><div class="line">    (<span class="name">iter</span> a <span class="number">0</span>)))</div></pre></td></tr></table></figure>
<p>如果用序列操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</div><div class="line">  (<span class="name">accumulate</span> + </div><div class="line">              <span class="number">0</span></div><div class="line">              (<span class="name">filter</span> prime? (<span class="name">enumerate-interval</span> a b))))</div></pre></td></tr></table></figure>
<p>在执行计算时，第一个程序只需要<strong>维护正在累积的和</strong>。第二个程序只有<strong>等enumate-interval构造完成这一区间所有整数的表之后</strong>，过滤器才能开始工作。这就需要大量的中间存储，增加计算开销。</p>
<p>流是一种非常巧妙的想法，使我们<strong>既可以利用各种序列操作，又不会带来将序列作为表操作的性能代价</strong>。</p>
<p>从表面上看，流也是表，但对他们进行操作的过程的名字不同。有构造函数cons-stream，以及两个选择函数stream-car和stream-cdr，满足如下约束</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">stream-car</span> (<span class="name">cons-stream</span> x y))=x</div><div class="line">(<span class="name">stream-cdr</span> (<span class="name">cons-stream</span> x y))=y</div></pre></td></tr></table></figure>
<p>我们用和第二章各种表操作（如list-ref，map和for-each等）类似的方式来操作流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">stream-car</span> s)</div><div class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc s)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span> </div><div class="line">       (<span class="name">proc</span> (<span class="name">stream-car</span> s))</div><div class="line">       (<span class="name">stream-map</span> proc (<span class="name">stream-cdr</span> s)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-for-each</span> proc s)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</div><div class="line">      'done</div><div class="line">      (<span class="name">begin</span> </div><div class="line">        (<span class="name">proc</span> (<span class="name">stream-car</span> s))</div><div class="line">        (<span class="name">stream-for-each</span> proc </div><div class="line">                         (<span class="name">stream-cdr</span> s)))))</div></pre></td></tr></table></figure>
<p>核心的诉求是，<strong>对于流的cdr的求值要等到真正通过过程stream-cdr去访问它的时候再做，而不是在构造stream-cdr的时候做</strong>。</p>
<p>流的实现将基于一种称为<strong>delay</strong>的特殊形式，对于<code>(delay &lt;exp&gt;)</code>的求值不是对表达式求值，而是返回一个称为 <strong>延时对象</strong> 的对象。这个对象可以看做是对未来某个时间要对表达式求值的一个允诺。</p>
<p>和delay一起的还有一个<strong>force</strong>的过程，它以一个延时对象为参数，执行相应的求值工作，也就是说，force就用来迫使delay完成所允诺的求值。下面用这两个概念来构造流。</p>
<p>cons-stream的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cons-stream ⟨a⟩ ⟨b⟩)</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cons ⟨a⟩ (delay ⟨b⟩))</div></pre></td></tr></table></figure>
<p>可见，定义的时候，b还没有放到cons的cdr中。再看对cons的取值，</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) </div><div class="line">  (<span class="name">car</span> stream))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) </div><div class="line">  (<span class="name">force</span> (<span class="name">cdr</span> stream)))</div></pre></td></tr></table></figure>
<p><strong>流实现的行为方式</strong></p>
<p>我们再来看之前的过滤出素数的例子</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">stream-car</span> </div><div class="line"> (<span class="name">stream-cdr</span></div><div class="line">  (<span class="name">stream-filter</span> </div><div class="line">   prime? (<span class="name">stream-enumerate-interval</span> </div><div class="line">           <span class="number">10000</span> <span class="number">1000000</span>))))</div></pre></td></tr></table></figure>
<p>计算开始于对参数10000 1000000调用stream-enumerate-interval。它的实现是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span></div><div class="line">       low</div><div class="line">       (<span class="name">stream-enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>)</div><div class="line">                                  high))))</div></pre></td></tr></table></figure>
<p>这样，由stream-enumerate-interval返回的结果就是通过cons-stream形成的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10000</span></div><div class="line">      (<span class="name">delay</span> </div><div class="line">        (<span class="name">stream-enumerate-interval</span> </div><div class="line">         <span class="number">10001</span> </div><div class="line">         <span class="number">1000000</span>)))</div></pre></td></tr></table></figure>
<p>也就是说，当stream-enumerate-interval返回一个流的时候，car是10000，而cdr是一个<strong>允诺</strong>，表示当需要的时候，才在这个区间中枚举更多的内容。</p>
<p>再来看这个流程构建后的过滤</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) </div><div class="line">         the-empty-stream)</div><div class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</div><div class="line">         (<span class="name">cons-stream</span> </div><div class="line">          (<span class="name">stream-car</span> stream)</div><div class="line">          (<span class="name">stream-filter</span> </div><div class="line">           pred</div><div class="line">           (<span class="name">stream-cdr</span> stream))))</div><div class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> </div><div class="line">               pred </div><div class="line">               (<span class="name">stream-cdr</span> stream)))))</div></pre></td></tr></table></figure>
<p>首先检查stream-car，因为这个数不是素数（10000），再进一步检查stream-cdr，这个时候对stream-cdr的调用会迫使系统对延时的stream-enumerate-interval求值，这一次就返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10001</span></div><div class="line">      (<span class="name">delay</span> </div><div class="line">        (<span class="name">stream-enumerate-interval</span> </div><div class="line">         <span class="number">10002</span> </div><div class="line">         <span class="number">1000000</span>)))</div></pre></td></tr></table></figure>
<p>如此进行，直到找到第一个素数10007，此时stream-filter根据其定义返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons-stream</span> </div><div class="line"> (<span class="name">stream-car</span> stream)</div><div class="line"> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))</div></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10007</span></div><div class="line">      (<span class="name">delay</span></div><div class="line">        (<span class="name">stream-filter</span></div><div class="line">         prime?</div><div class="line">         (<span class="name">cons</span> <span class="number">10008</span></div><div class="line">               (<span class="name">delay</span></div><div class="line">                 (<span class="name">stream-enumerate-interval</span> </div><div class="line">                  <span class="number">10009</span> <span class="number">1000000</span>))))))</div></pre></td></tr></table></figure>
<p>这样在stream-cdr中，又迫使延时的stream-filter求值，转而再去迫使stream-enumerate-interval求值，直到再找到下一个素数……</p>
<p>一般而言，可以将延时求值看做是一种“由需要驱动”的设计，其中流处理的每个阶段都仅仅活动到足够满足下一阶段的需要。</p>
<p><strong>delay和force的实现</strong></p>
<p>delay必须包装起一个表达式，使其可以在以后根据需要求值。delay实际上也是一个lambda表达式的语法糖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(delay ⟨exp⟩)</div><div class="line">=</div><div class="line">(lambda () ⟨exp⟩)</div></pre></td></tr></table></figure>
<p>而force就是简单调用由delay产生的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(define (force delayed-object)</div><div class="line">  (delayed-object))</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/congyihao/article/details/60747909" target="_blank" rel="noopener">Java 8 - 通过lambda表达式进行惰性计算</a></p>
<p>lambda表达式的出现使得JDK8内部发生了很多有趣的变化, 其中就包括惰性计算的特性.<br>这里以JDK标准库中的Logger为例, 1.8以前的log方法有如下签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String msg)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</div><div class="line">&gt;             <span class="keyword">return</span>;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msg);</div><div class="line">&gt;         doLog(lr);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>也就是说客户端程序调用log方法的时候, 无论最终是否触发log行为, <code>msg</code>始终是要被计算的. 若计算<code>msg</code>是非常耗时的行为, 那么无疑会造成不必要的开销. 下面是一个调用的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; log(Level.WARNING, <span class="string">"Log msg: "</span> + someExpensiveOperation());</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在java 1.8版本出现之后, 该方法多了如下重载:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, Supplier&lt;String&gt; msgSupplier)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</div><div class="line">&gt;             <span class="keyword">return</span>;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msgSupplier.get());</div><div class="line">&gt;         doLog(lr);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><code>Supplier</code>是一个<code>FunctionalInterface</code>, 也就是说现在的<code>log</code>方法可以接受一个无参的lambda表达式作为参数, 而计算的过程也被延迟到了<code>supplier.get()</code>的调用时. 改进后的调用例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// 注意: 传入的lambda表达式并不会立即执行, 而是在log中判断isLoggable(level)成功后才会执行</span></div><div class="line">&gt; log(Level.WARNING, () -&gt; <span class="string">"Log msg: "</span> + someExpensiveOperation());</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>这里还存在一个优化。有时需要多次对同一个delay求值，这就需要delay能保存上一次求出的值。于是可以将delay实现为一种特殊的记忆过程，它以一个无参过程为参数，返回该过程的记忆性版本。这种记忆性过程在第一次执行时将结果保存，下一次求值时再返回之前保存的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">memo-proc</span> proc)</div><div class="line">  (<span class="name">let</span> ((<span class="name">already-run</span>? false) (<span class="name">result</span> false))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">if</span> (<span class="name">not</span> already-run?)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> result (<span class="name">proc</span>))</div><div class="line">                 (<span class="name">set!</span> already-run? true)</div><div class="line">                 result)</div><div class="line">          result))))</div></pre></td></tr></table></figure>
<p>此后再定义delay，使得<code>(delay ⟨exp⟩)</code>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(memo-proc (lambda () ⟨exp⟩))</div></pre></td></tr></table></figure>
<h3 id="3-5-2-无穷流"><a href="#3-5-2-无穷流" class="headerlink" title="3.5.2 无穷流"></a>3.5.2 无穷流</h3><p>用流表示无穷长的序列。</p>
<p>比如以下的流可以表示所有正整数序列。这是一个无穷长的流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</div><div class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">100</span>)</div><div class="line"><span class="number">101</span></div></pre></td></tr></table></figure>
<p>用这个就可以表示，例如不能被7整除的整数的流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">divisible</span>? x y) (<span class="name">=</span> (<span class="name">remainder</span> x y) <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> no-sevens</div><div class="line">  (<span class="name">stream-filter</span> (<span class="name">lambda</span> (<span class="name">x</span>) </div><div class="line">                   (<span class="name">not</span> (<span class="name">divisible</span>? x <span class="number">7</span>)))</div><div class="line">                 integers))</div></pre></td></tr></table></figure>
<p>之后在用访问这个流元素的方式找出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; (stream-ref no-sevens 100)</div><div class="line">117</div></pre></td></tr></table></figure>
<p>也可以定义斐波那契数列的无穷流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">fibgen</span> a b)</div><div class="line">  (<span class="name">cons-stream</span> a (<span class="name">fibgen</span> b (<span class="name">+</span> a b))))</div><div class="line">(<span class="name">define</span> fibs (<span class="name">fibgen</span> <span class="number">0</span> <span class="number">1</span>))</div><div class="line"></div><div class="line">------------------</div><div class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">6</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<p>这样定义出的<code>fibs</code>是一个序对，其car是0，cdr是一个求值<code>(fibgen 1 1)</code>的允诺。求该表达式时，又将产生一个序对，car是，cdr是<code>(fibgen 1 2)</code>。</p>
<p><strong>隐式的定义流</strong></p>
<p>上面的integers和fibs是通过描述“生成”过程的方式定义的，这种过程是一个个的计算出流的元素。另一种就是<strong>隐式的求值</strong>。</p>
<p>例如，下面表达式将ones定义为1的一个无穷流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(define ones (cons-stream 1 ones))</div></pre></td></tr></table></figure>
<p>这种方式就像在定义一个递归过程：这里的ones是一个序对，car是1，cdr是求值ones的一个允诺。而对cdr的求值又得到了一个1和cdr的允诺。</p>
<p>add-streams操作产生出两个给定流的逐对元素之和</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-streams</span> s1 s2) </div><div class="line">  (<span class="name">stream-map</span> + s1 s2))</div></pre></td></tr></table></figure>
<p>现在可以用另一种方式定义整数流integers</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> integers </div><div class="line">  (<span class="name">cons-stream</span> <span class="number">1</span> (<span class="name">add-streams</span> ones integers)))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">10</span>)</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>首元素是1，其余是ones和integers之和。这样，integers的第二个元素就是1加上integers的第一个元素，也就是2。第三个元素就是1加上integers的第二个元素，也就是3。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; 原版integers定义</span></div><div class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</div><div class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>同样的风格也可以定义出斐波那契数列</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> fibs </div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   <span class="number">0</span> (<span class="name">cons-stream</span></div><div class="line">      <span class="number">1</span> (<span class="name">add-streams</span> </div><div class="line">         (<span class="name">stream-cdr</span> fibs) fibs))))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">11</span>)</div><div class="line"><span class="number">89</span></div></pre></td></tr></table></figure>
<p>这个定义是fib是一个从0和1开始的流，而这个流的其余部分都可以通过加起流fibs和移动了一个位置的fibs而得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    1 1 2 3 5  8 13 21 … = (stream-cdr fibs)</div><div class="line">    0 1 1 2 3  5  8 13 … = fibs</div><div class="line">0 1 1 2 3 5 8 13 21 34 … = fibs</div></pre></td></tr></table></figure>
<h3 id="3-5-5-函数式程序的模块化和对象的模块化"><a href="#3-5-5-函数式程序的模块化和对象的模块化" class="headerlink" title="3.5.5 函数式程序的模块化和对象的模块化"></a>3.5.5 函数式程序的模块化和对象的模块化</h3><p>正如在3.1.2中看到的，引进赋值的主要收益就是使我们可以<strong>增强系统的模块化</strong>，把一个大系统的状态中的某些部分封装，或者说<strong>“隐藏”到局部变量里</strong>。</p>
<p>流模型可以<strong>提供等价的模块化，同时又不必使用赋值</strong>。为了展示这方面的情况，我们可以重新实现前面在 3.1.2 节看过的π的蒙特卡罗估计，这次从流的观点出发来做。</p>
<p>这里的一个关键性的模块化问题，就是我们希望<strong>将一个随机数生成器的内部状态隐蔽起来，隔离在使用随机数的程序之外</strong>。从过程 <code>rand-update</code> 开始，它所提供的一系列值就是我们所需的随机数，用它作为一个随机数生成器：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> rand</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</div><div class="line">      x)))</div></pre></td></tr></table></figure>
<p>在这个流的描述中，看不到什么随机数生成器。在这里只有一个随机数的流，通过对rand-update的一系列顺序调用产生：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> random-numbers</div><div class="line">  (<span class="name">cons-stream</span> random-init</div><div class="line">               (<span class="name">stream-map</span> rand-update </div><div class="line">                           random-numbers)))</div></pre></td></tr></table></figure>
<p>用它构造出在<code>random-numbers</code>流中顺序的数对上的的Cesaro实验的输出流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">map-successive-pairs</span> f s)</div><div class="line">  (<span class="name">cons-stream</span></div><div class="line">   (<span class="name">f</span> (<span class="name">stream-car</span> s) </div><div class="line">      (<span class="name">stream-car</span> (<span class="name">stream-cdr</span> s)))</div><div class="line">   (<span class="name">map-successive-pairs</span> </div><div class="line">    f (<span class="name">stream-cdr</span> (<span class="name">stream-cdr</span> s)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> cesaro-stream</div><div class="line">  (<span class="name">map-successive-pairs</span></div><div class="line">   (<span class="name">lambda</span> (<span class="name">r1</span> r2) (<span class="name">=</span> (<span class="name">gcd</span> r1 r2) <span class="number">1</span>))</div><div class="line">   random-numbers))</div></pre></td></tr></table></figure>
<p>现在将<code>cesaro-stream</code>扔进<code>monte-carlo</code>过程，该过程生成一个可能性估计的流。得到的结果就变换到一个估计π值的流。这一版本的程序<strong>不需要用参数去告诉它试多少次</strong>，只要查看更后面的值，就可以得到更好的π的估计。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> experiment-stream </div><div class="line">                     passed </div><div class="line">                     failed)</div><div class="line">  (<span class="name">define</span> (<span class="name">next</span> passed failed)</div><div class="line">    (<span class="name">cons-stream</span></div><div class="line">     (<span class="name">/</span> passed (<span class="name">+</span> passed failed))</div><div class="line">     (<span class="name">monte-carlo</span></div><div class="line">      (<span class="name">stream-cdr</span> experiment-stream) </div><div class="line">      passed </div><div class="line">      failed)))</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-car</span> experiment-stream)</div><div class="line">      (<span class="name">next</span> (<span class="name">+</span> passed <span class="number">1</span>) failed)</div><div class="line">      (<span class="name">next</span> passed (<span class="name">+</span> failed <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> pi</div><div class="line">  (<span class="name">stream-map</span></div><div class="line">   (<span class="name">lambda</span> (<span class="name">p</span>) (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> p)))</div><div class="line">   (<span class="name">monte-carlo</span> cesaro-stream <span class="number">0</span> <span class="number">0</span>)))</div><div class="line"></div><div class="line">------------------------</div><div class="line">&gt; (<span class="name">stream-ref</span> pi <span class="number">1000</span>)</div><div class="line"><span class="number">3.24037034920393</span></div></pre></td></tr></table></figure>
<p>而且，这一方法也非常模块化，这里<strong>构造了一个一般性的monte-carlo过程，它可以处理任何试验，而且这里没有赋值，也没有局部状态</strong>。</p>
<p>附：流执行的预先定义函数</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; stream-&gt;list</span></div><div class="line"></div><div class="line">(<span class="name">define</span> stream-&gt;list</div><div class="line">  (<span class="name">lambda</span> (<span class="name">strm</span> n)</div><div class="line">    (<span class="name">if</span> (<span class="name">or</span> (<span class="name">stream-null</span>? strm) (<span class="name">zero</span>? n))</div><div class="line">        '()</div><div class="line">        (<span class="name">cons</span> (<span class="name">stream-car</span> strm)</div><div class="line">              (<span class="name">stream-&gt;list</span> (<span class="name">stream-cdr</span> strm) (<span class="name">sub1</span> n))))))</div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define-syntax</span> delay</div><div class="line">  (<span class="name">syntax-rules</span> ()</div><div class="line">    ((<span class="name">_</span> exp) (<span class="name">lambda</span> () exp))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">force</span> delayed-object)</div><div class="line">  (<span class="name">delayed-object</span>))</div><div class="line"></div><div class="line">(<span class="name">define-syntax</span> cons-stream</div><div class="line">  (<span class="name">syntax-rules</span> ()</div><div class="line">    ((<span class="name">_</span> a b) (<span class="name">cons</span> a (<span class="name">delay</span> b)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) (<span class="name">car</span> stream))</div><div class="line"> </div><div class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) (<span class="name">force</span> (<span class="name">cdr</span> stream)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-null</span>? stream)</div><div class="line">  (<span class="name">null</span>? stream))</div><div class="line"></div><div class="line">(<span class="name">define</span> the-empty-stream '())</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">stream-car</span> s)</div><div class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc . argstreams)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? (<span class="name">car</span> argstreams))</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span></div><div class="line">       (<span class="name">apply</span> proc (<span class="name">map</span> stream-car argstreams))</div><div class="line">       (<span class="name">apply</span> stream-map</div><div class="line">              (<span class="name">cons</span> proc</div><div class="line">                    (<span class="name">map</span> stream-cdr</div><div class="line">                         argstreams))))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) the-empty-stream)</div><div class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</div><div class="line">         (<span class="name">cons-stream</span> (<span class="name">stream-car</span> stream)</div><div class="line">                      (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream))))</div><div class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))))</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liujiacai.net/blog/2015/12/26/sicp-chapter3-summary/" target="_blank" rel="noopener">SICP 第三章总结</a></p>
<p><a href="https://github.com/rsy56640/daily_learning/tree/master/SICP#3" target="_blank" rel="noopener">SICP note</a></p>
<p><a href="https://sicp.liujiacai.net/chap3/exercise.html" target="_blank" rel="noopener">第三章习题索引</a></p>
<p><a href="https://sarabander.github.io/sicp/html/3_002e5.xhtml" target="_blank" rel="noopener">第三章英文版</a></p>
<p><a href="https://wizardforcel.gitbooks.io/sicp-py/content/" target="_blank" rel="noopener">SICP Python 描述 中文版</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/模型评估与选择/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/模型评估与选择/" class="post-title-link" itemprop="url">模型评估与选择</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-29 21:43:42" itemprop="dateModified" datetime="2018-01-29T21:43:42+08:00">2018-01-29</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/模型评估与选择/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/模型评估与选择/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、模型评估方法"><a href="#1、模型评估方法" class="headerlink" title="1、模型评估方法"></a>1、模型评估方法</h1><blockquote>
<p>可重复采样：<strong>在训练集小</strong>，难以划分训练/测试集是有用。此外，能产生多个不同训练集，对<strong>集成学习</strong>等方法有很大的好处。但是会改变初始数据集分布。</p>
<p>在<strong>初始数据量足够</strong>时，用留出法或者交叉验证法。</p>
</blockquote>
<h2 id="1-1-留出法Hold-out"><a href="#1-1-留出法Hold-out" class="headerlink" title="1.1 留出法Hold-out"></a>1.1 留出法Hold-out</h2><p>将数据集D分成两个互斥的集合。</p>
<p>训练/测试集尽量保证数据一致性，用分层采样，正负样本同比例。</p>
<p>由于单次估计结果往往不可靠，使用留出法时，一般要采用若干次随机划分，重复进行实验后取平均值作为评估值。      ‘</p>
<h2 id="1-2-交叉验证法"><a href="#1-2-交叉验证法" class="headerlink" title="1.2 交叉验证法"></a>1.2 交叉验证法</h2><p>将D分成k个大小相似的互斥子集，每个子集用分层采样得到。</p>
<p>每次用k-1个子集的并集作为训练集，余下的子集作为测试集。这样获得k组训练/测试集。最终返回是k个测试结果的均值。</p>
<p>常用10折交叉验证。</p>
<h2 id="1-3-可重复采样"><a href="#1-3-可重复采样" class="headerlink" title="1.3 可重复采样"></a>1.3 可重复采样</h2><p>bootstrapping sampling：给定包含m个样本的数据集D，我们进行采样产生数据集$D’$，每次随机从D中挑选一个样本，将其拷贝放入$D’$，再将样本放回D。重复m次，得到包含m个样本的$D’$。</p>
<p>样本在m次采样中始终不被采到的概率是$(1-\frac 1 m)^m$，取极限得到</p>
<script type="math/tex; mode=display">
{\lim_{m \mapsto \infty  }}(1-\frac 1 m)^m  \mapsto \frac 1 e\approx0.368</script><p>即通过bootstrapping，D中有36.8%的样本未出现在$D’$中，于是可以将$D’$作为训练集，$D-D’$作为测试集，这样可以有1/3个未出现在训练集的样本用于测试。测试结果称为“包外估计”（out-of-bag estimate）。</p>
<h2 id="1-4-调参"><a href="#1-4-调参" class="headerlink" title="1.4 调参"></a>1.4 调参</h2><blockquote>
<p>我们在模型评估时往往用来确定算法和参数。当这些确定后，要用所有的D再训练一次，才是最终的模型。</p>
</blockquote>
<h1 id="2、性能度量"><a href="#2、性能度量" class="headerlink" title="2、性能度量"></a>2、性能度量</h1><p>回归最常用的是“均方误差”（mean squared error）</p>
<script type="math/tex; mode=display">
E(f;D) = \frac 1 m \sum_{i=1}^m(f(x_i)-y_i )^2</script><p>更一般的，对于数据分布D和概率密度函数$p(\cdot )$，均方误差可描述为</p>
<script type="math/tex; mode=display">
E(f;D) = \int_{x \in D}(f(x)-y)^2p(x)dx</script><p>分类的性能度量更复杂</p>
<h2 id="2-1-错误率和精度"><a href="#2-1-错误率和精度" class="headerlink" title="2.1 错误率和精度"></a>2.1 错误率和精度</h2><p>错误率：分类错误的样本占总样本的比例</p>
<p>精度：分类正确的样本占总样本的比例</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/模型集成/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/模型集成/" class="post-title-link" itemprop="url">模型集成</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-11 09:26:22" itemprop="dateModified" datetime="2018-02-11T09:26:22+08:00">2018-02-11</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/模型集成/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/模型集成/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jiqizhixin.com/articles/2018-01-14-8" target="_blank" rel="noopener">每个Kaggle冠军的获胜法门：揭秘Python中的模型集成</a></p>
<p><img src="https://image.jiqizhixin.com/uploads/wangeditor/c897487a-bf02-4023-9355-24c747d7ef62/43133image%20(1" alt="">.png)</p>
<p>Example Schematics of an ensemble.  An input array X is fed through two proprocessing pipelines and then to a set of base learners f(i). The ensemble combines all base learner predictions into a final prediction array P. </p>
<p>By the end of the post, you will:</p>
<ul>
<li>understand the fundamentals of ensembles</li>
<li>know how to code them</li>
<li>understand the main pitfalls and drawbacks of ensembles</li>
</ul>
<h2 id="Predicting-Republican-and-Democratic-donations"><a href="#Predicting-Republican-and-Democratic-donations" class="headerlink" title="Predicting Republican and Democratic donations"></a>Predicting Republican and Democratic donations</h2><p>we’ll use a data set on U.S. political contributions. The <a href="https://github.com/fivethirtyeight/data/tree/master/science-giving" target="_blank" rel="noopener">original data set</a> was prepared by <a href="https://fivethirtyeight.com/contributors/ben-wieder/" target="_blank" rel="noopener">Ben Wieder</a> at <a href="https://fivethirtyeight.com/" target="_blank" rel="noopener">FiveThirtyEight</a>, who dug around the U.S. government’s political contribution registry and found that when <a href="https://fivethirtyeight.com/features/when-scientists-donate-to-politicians-its-usually-to-democrats/" target="_blank" rel="noopener">scientists donate to politician, it’s usually to Democrats</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line"><span class="comment">### Import data</span></div><div class="line"><span class="comment"># Always good to set a seed for reproducibility</span></div><div class="line">SEED = <span class="number">222</span></div><div class="line">np.random.seed(SEED)</div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">'input.csv'</span>)</div><div class="line"></div><div class="line"><span class="comment">### Training and test set</span></div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_test</span><span class="params">(test_size=<span class="number">0.95</span>)</span>:</span></div><div class="line">    <span class="string">"""Split Data into train and test sets."""</span></div><div class="line">    y = <span class="number">1</span> * (df.cand_pty_affiliation == <span class="string">"REP"</span>)</div><div class="line">    X = df.drop([<span class="string">"cand_pty_affiliation"</span>], axis=<span class="number">1</span>)</div><div class="line">    X = pd.get_dummies(X, sparse=<span class="keyword">True</span>)</div><div class="line">    X.drop(X.columns[X.std() == <span class="number">0</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> train_test_split(X, y, test_size=test_size, random_state=SEED)</div><div class="line"></div><div class="line">xtrain, xtest, ytrain, ytest = get_train_test()</div><div class="line"></div><div class="line"><span class="comment"># A look at the data</span></div><div class="line">print(<span class="string">"\nExample data:"</span>)</div><div class="line">df.head()</div><div class="line"></div><div class="line">df.cand_pty_affiliation.value_counts(normalize=<span class="keyword">True</span>).plot(</div><div class="line">    kind=<span class="string">"bar"</span>, title=<span class="string">"Share of No. donations"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>This claim is based on the observation on the share of donations being made to Republicans and Democrats. However, there’s plenty more that can be said: for instance, which scientific discipline is most likely to make a Republican donation, and which state is most likely to make Democratic donations? We will go one step further and <em>predict</em> whether a donation is most likely to be a to a Republican or Democrat.</p>
<h2 id="What-is-an-ensemble"><a href="#What-is-an-ensemble" class="headerlink" title="What is an ensemble?"></a>What is an ensemble?</h2><p>Combining predictions from several models averages out idiosyncratic errors and yield better overall predictions.</p>
<p>How to combine predictions?</p>
<p>Machine learning is remarkably similar in classification problems: <strong>taking the most common class label prediction is equivalent to a majority voting rule</strong>. But there are many other ways to combine predictions, and more generally we can use a <strong>model to <em>learn</em></strong> how to best combine predictions.</p>
<h3 id="Understanding-ensembles-by-combining-decision-trees"><a href="#Understanding-ensembles-by-combining-decision-trees" class="headerlink" title="Understanding ensembles by combining decision trees"></a>Understanding ensembles by combining decision trees</h3><p>The deeper the tree, the more complex the patterns it can capture, but the <strong>more prone</strong> to overfitting it will be. Because of this, we will need an alternative way of building complex models of decision trees, and an ensemble of different decision trees is one such way.</p>
<p>We’ll use the below helper function to visualize our decision rules:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pydotplus  <span class="comment"># you can install pydotplus with: pip install pydotplus </span></div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_graph</span><span class="params">(clf, feature_names)</span>:</span></div><div class="line">    <span class="string">"""Print decision tree."""</span></div><div class="line">    graph = export_graphviz(</div><div class="line">        clf,</div><div class="line">        label=<span class="string">"root"</span>,</div><div class="line">        proportion=<span class="keyword">True</span>,</div><div class="line">        impurity=<span class="keyword">False</span>, </div><div class="line">        out_file=<span class="keyword">None</span>, </div><div class="line">        feature_names=feature_names,</div><div class="line">        class_names=&#123;<span class="number">0</span>: <span class="string">"D"</span>, <span class="number">1</span>: <span class="string">"R"</span>&#125;,</div><div class="line">        filled=<span class="keyword">True</span>,</div><div class="line">        rounded=<span class="keyword">True</span></div><div class="line">    )</div><div class="line">    graph = pydotplus.graph_from_dot_data(graph)  </div><div class="line">    <span class="keyword">return</span> Image(graph.create_png())</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/" class="post-title-link" itemprop="url">浅谈在线最优化求解算法-以CTR预测模型为例</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="1、最优化求解问题"><a href="#1、最优化求解问题" class="headerlink" title="1、最优化求解问题"></a>1、最优化求解问题</h1><p>通常，我们需要求解的最优化问题有如下三类：</p>
<p><strong>（1）无约束优化问题</strong>：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)</script><p>含义是求解X，令目标函数$f(X)$最小。</p>
<p>对于这类问题，在$f(X)$ 是凸函数的前提下，通常做法就是对$f(X)$ 求导，并令$\frac {\partial} {\partial X} f(X) =0$ ，求解可以得到最优值。</p>
<blockquote>
<p> <strong>凸函数</strong></p>
<p> 如果$f(x)$是定义在N维向量空间上的实变量函数，对于在$f(x)$的定义域C上的任意两个点$x_1$和$x_2$，以及任意[0,1]之间的值t都有：</p>
<script type="math/tex; mode=display">
 f(tX_1 + (1-t)X_2) \leq tf(X_1)+(1-t)f(X_2)\\
 \forall X_1,X_2 \in C,\ \ 0 \leq t \leq 1</script><p> 则称$f(x)$是凸函数。一个函数是凸函数是其存在最优解的充要条件。</p>
<p> 此外，如果$f(x)$满足</p>
<script type="math/tex; mode=display">
 f(tX_1 + (1-t)X_2)< tf(X_1)+(1-t)f(X_2)\\
 \forall X_1,X_2 \in C,\ \ 0 \leq t \leq 1</script><p> 则$f(x)$为严格凸函数。如下图所示，左边是严格凸函数，右边是凸函数</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/凸函数.png" alt="凸函数"></p>
</blockquote>
<p><strong>（2）有等式约束的最优化问题</strong>：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)\\
s.t. h_k(X)=0;k=1,2,...,n</script><p>含义是在n个等式约束$h_k(X)$ 的条件下求解X，另目标函数$f(X)$最小。</p>
<p>针对有等式的最优化问题，采用<strong>拉格朗日乘数法</strong>进行求解，通过拉格朗日系数$A=[a_1,a_2,…,a_n]^T$ 把等式约束和目标函数组合成一个式子</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}[f(X)+ A^TH(X)]</script><p>相当于转化成无约束最优化求解问题，解决方法是分别对X，A求偏导并令其等于0。</p>
<p><strong>（3）不等式约束的优化问题求解</strong> ：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)\\
s.t. h_k(X)=0;k=1,2,...,n\\
g_l(X)\leq 0;l=1,2,...,m</script><p>对于不等式约束，通过KKT条件求解。将所有的约束和目标函数写为一个式子</p>
<script type="math/tex; mode=display">
L(X,A,B)=f(X)+A^TH(X)+B^TG(X)</script><p>KKT条件是说最优值必须满足以下条件：</p>
<script type="math/tex; mode=display">
\frac \partial {\partial X} L(X,A,B)=0\\
H(X)=0\\
B^TG(X)=0</script><p>KKT条件是求解最优值的必要条件，要使其成为充要条件，还需要f(x)为凸函数。</p>
<h1 id="2、批量最优化求解算法"><a href="#2、批量最优化求解算法" class="headerlink" title="2、批量最优化求解算法"></a>2、批量最优化求解算法</h1><p>一些定义：</p>
<p>$i=1,2,…,N$表示向量维度</p>
<p>$j=1,2,…,M$表示样本个数</p>
<p>$t=1,2,…$表示迭代次数</p>
<h2 id="2-1-批量和随机求解"><a href="#2-1-批量和随机求解" class="headerlink" title="2.1 批量和随机求解"></a>2.1 批量和随机求解</h2><p>我们面对的最优化问题都是无约束的最优化问题（有约束的也可以转成无约束的），因此通常可以将其描述为</p>
<script type="math/tex; mode=display">
W=\arg \underset{W}{min}\   l(W,Z)\\
Z=\{ (X_j,y_j) | j=1,2,...,M  \}\\
y_j=h(W,X_j)
\tag {2-1-1}</script><p>就是<strong>在已知训练集的情况下，求使得目标函数最小的权重矩阵</strong>。其中，$Z$是训练集，$\mathbf{X}$是特征向量，$X_j$是其中一个样本，$Y$是预测值，$y_j$是其中一个样本对应的预测值。一共有M个样本。$h(W,X_j)$ 是特征向量到预测值的<strong>映射函数</strong>，$ l(W,Z)$ 最优化求解的目标函数，也称为<strong>损失函数</strong>，$W$ 为特征权重，也就是在损失函数中需要求解的参数。</p>
<blockquote>
<p> 损失函数一般包括损失项和正则项</p>
</blockquote>
<p>常用的损失函数有：</p>
<p>（1）<strong>平方损失函数</strong>（线性回归）</p>
<p>最小二乘法（Ordinary Least Squares）是常用的一种平方损失函数，最小二乘的基本原理是：最优拟合直线应该是使各点到回归直线的距离和最小的直线，即平方和最小。</p>
<p>线性回归的映射函数为：</p>
<script type="math/tex; mode=display">
h(W,X_j)=W^TX_j</script><p>损失函数可以表示为</p>
<script type="math/tex; mode=display">
l(W,Z)=\sum_{j=1}^M (y_j-W^TX_j)^2</script><p>（2）<strong>Logistics损失函数</strong>（逻辑回归）</p>
<p>逻辑回归的映射函数为：</p>
<script type="math/tex; mode=display">
h(W,X_j)=\frac 1 {1+e^{-W^TX_j}}</script><blockquote>
<p>logistic函数的优点是：</p>
<p>1、他的输入范围是$-\infty \rightarrow  + \infty $ ，<strong>输出范围是(0,1)，正好满足概率分布为（0，1）的要求</strong>。我们用概率去描述分类器，自然比单纯的某个阈值要方便很多； </p>
<p>2、是一个单调上升的函数，具有良好的连续性，<strong>不存在不连续点</strong>。</p>
</blockquote>
<p>由于该函数服从伯努利分布（0-1分布），通过最大似然估计，对于每一维的权重W，损失函数可以表示为</p>
<script type="math/tex; mode=display">
l(W,Z)=(Y-h_W(\mathbf X))X</script><blockquote>
<p><strong>推导过程</strong></p>
<p>令</p>
<script type="math/tex; mode=display">
h_W(X) = \frac 1 {1+e^{-W^T\mathbf X}}</script><p>该函数服从伯努利分布（一次点击要么成功，要么失败，通过训练集可以知道不同特征组合下成功和失败的概率）</p>
<script type="math/tex; mode=display">
P(Y=1 | \mathbf X;W) = h_W(\mathbf X)\\
P(Y=0 | \mathbf X;W) = 1-h_W(\mathbf X)</script><p>则概率分布函数为</p>
<script type="math/tex; mode=display">
P(Y|\mathbf X;W) = (h_W(\mathbf X))^Y*(1-h_W(\mathbf X))^{1-Y}</script><p>（<strong>也就是说，我们有样本，通过样本能知道概率分布，那么我们需要知道得到这个概率分布的最有可能的参数W。即我们通过样本知道一些特征组合下的点击率，现在需要求概率函数中的系数。</strong>）</p>
<p>我们假设样本数据相互独立，所以它们的联合分布可以表示为各边际分布的乘积，用似然函数表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
L(W)=P(Y|\mathbf X;W) &= (h_W(\mathbf X))^Y(1-h_W(\mathbf X))^{1-Y}\\
&=\prod_{j=1}^M(h_W(X_j))^{y_j}(1-h_W(X_j))^{1-y_j}
\end{aligned}
\tag {2-1-2}</script><p>从而，损失函数的求解，可以转化为求最有可能导致这样概率分布的W，也就是求L(W)的最大值。最简单的方法就是对W求偏导，并令导数为零。</p>
<p>在多数情况下，直接对变量进行求导反而会使得计算式子更加的复杂，此时可以借用对数函数。由于对数函数是单调增函数，因此与（2-1-2）具有相同的最大值，上式变为</p>
<script type="math/tex; mode=display">
\begin{aligned} 
l(W) &= Log\ L(W)\\
&=\sum_{j=1}^M(y_jln\ h(X_j)+(1-y_j)ln\ (1-h(X_j)))
\end{aligned}</script><p>对其求关于W的偏导</p>
<p>首先求logistic函数的导数，得（最后一个X是对$W^TX$的求导）</p>
<script type="math/tex; mode=display">
h_W^{'}(\mathbf X) = h_W(\mathbf X)(1-h_W(\mathbf X))</script><blockquote>
<p><strong>推导过程如下</strong></p>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/求导的推导.jpg" alt="求导的推导"></p>
</blockquote>
<p>为了求解方便，将l(W)转为（其实1/M没用，完全可以去掉，不懂为何要加上）</p>
<script type="math/tex; mode=display">
J(W) = -\frac {1}{M} l(W)</script><p>则就变成求J(W)的最小值。求偏导的过程如下：</p>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/最大似然估计求偏导.png" alt="最大似然估计求偏导"></p>
<p>最后得到目标函数（损失函数）为：</p>
<script type="math/tex; mode=display">
\frac {\partial }{\partial W}J(W) =-\frac{1}{M} (Y-h_W(\mathbf X))X</script></blockquote>
<p>对于损失函数的求解，一个典型的方法就是梯度下降法，由于损失函数是凸函数，因此沿着梯度下降的方向找到最小点。</p>
<p>假设样本总数为m，<strong>批量梯度下降</strong>是：</p>
<script type="math/tex; mode=display">
Repeat\ until\ convergence \{ \\
W^{(t+1)} := W^t - \eta^t\triangledown  _{W}l(W^{t},Z) \\
\}\\
 \tag{1-2}</script><p>而<strong>随机梯度下降（SGD）</strong>是：</p>
<script type="math/tex; mode=display">
Repeat\ until\ convergence \{ \\
      for\ j=1\ to\ M, \{ \\
          W^{(t+1)} := W^t - \eta^t\triangledown  _{W}l(W^{t},Z_j) \\
\}</script><p>两者的区别是：</p>
<p>前者每次更新$W$都需要遍历一次整个样本集合；而后者在遍历样本集合的时候，每个样本都能改变$W$ ，有更快的收敛速度 。由于SGD针对观测到的随机一条数据进行权重的更新，很适合进行增量计算，实现梯度下降的online模式。</p>
<h2 id="2-2-正则化"><a href="#2-2-正则化" class="headerlink" title="2.2 正则化"></a>2.2 正则化</h2><p>正则化的主要目的是防止过拟合。对于损失函数构成的模型，可能会出现有些权重很大，有些权重很小的情况，导致过拟合，使得模型的复杂度提高，泛化能力较差（对未知数据的预测能力）。</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/过拟合1.png" alt="过拟合1"></p>
<p>而正则化就是对损失函数中权重的限制，限制其模不要太大：</p>
<script type="math/tex; mode=display">
W=\arg \underset{W}{min}\   l(W,Z)\\
s.t. \Psi(W)<\delta</script><p>其中，$\Psi(W)$称为正则化因子，是一个关于W求模的函数，常用的正则化因子有L1和L2正则化。</p>
<script type="math/tex; mode=display">
L1\ Regularization \ \ \ \ \ \ \ \ \Psi(W)=||W||_1=\sum_{i=1}^N|w_i|\\
L2 \ Regularization\ \ \ \ \ \ \ \Psi(W)=||W||_2^2=\sum_{i=1}^N(w_i)^2=W^TW</script><p>L1和L2的主要区别有两个：</p>
<p>（1）L1在0处不可导，而L2可导。</p>
<p>（2）L1通常能产生更稀疏的模型，也就是W的更多维度是0。这些为0的权重就代表了不是很重要的维度，所以能起到特征选择的目的。</p>
<p>（3）L2能限制特征权重各个维度的模不要太大，解决过拟合。</p>
<blockquote>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/正则化解空间.png" alt="正则化解空间"><br> 其中，左图的圆形区域是L2正则化的单位圆，右图的方形区域是L1正则化的单位圆。<br><strong>单位圆</strong></p>
<p>使$||X||_p=1$的图形，当p=1和2时，单位圆分别为$|x|+|y|=1$和$x^2+y^2=1$。</p>
</blockquote>
<p>但是在SGD中，由于每次W的更新并不是沿着全局梯度进行下降，而是沿着某个样本产生的梯度方向进行下降，这样即使采用L1的方式也很难产生稀疏解。因此在接下来的在线最优化求解算法中，稀疏性是一个主要的追求目标。</p>
<p>参考：</p>
<p><a href="http://www.mamicode.com/info-detail-517504.html【正则化方法：L1和L2" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-517504.html【正则化方法：L1和L2</a> regularization、数据集扩增、dropout】</p>
<p><a href="http://blog.csdn.net/zouxy09/article/details/24971995/【机器学习中的范数规则化之（一）L0、L1与L2范数】" target="_blank" rel="noopener">http://blog.csdn.net/zouxy09/article/details/24971995/【机器学习中的范数规则化之（一）L0、L1与L2范数】</a></p>
<h1 id="3、在线最优化求解算法"><a href="#3、在线最优化求解算法" class="headerlink" title="3、在线最优化求解算法"></a>3、在线最优化求解算法</h1><h2 id="3-1-截断梯度法TG"><a href="#3-1-截断梯度法TG" class="headerlink" title="3.1 截断梯度法TG"></a>3.1 截断梯度法TG</h2><p>为了使特征权重W有更多的0，最简单的方法就是设一个阈值，当W的某个维度值小于这个阈值的时候置为0，这个称为<strong>简单截断法</strong>。但实际中W的某个系数比较小可能是由于该维度训练不足引起，所以这么做会导致这部分特征的丢失。于是又改进为<strong>截断梯度法Truncated Gradient</strong>。</p>
<h3 id="3-1-1-简单截断法"><a href="#3-1-1-简单截断法" class="headerlink" title="3.1.1 简单截断法"></a>3.1.1 简单截断法</h3><p>以$k$为窗口，当$t/k$不为整数时，采用标准的SGD；否则，采用如下的权重更新方式：</p>
<script type="math/tex; mode=display">
W^{t+1}=T_0(W^t - \eta^tG^t,\theta) \\
T_0(v_i,\theta) = \begin{Bmatrix}
0\ if\ |v_i|\leqslant \theta\\ 
v_i\ otherwise
\end{Bmatrix}</script><p>其中，$G^t=\triangledown  _{W}l(W^{t},Z^{t})$ 代表第t次迭代中损失函数的梯度，$\eta^{t}$ 是学习率，通常将其设置为 $1/\sqrt{t}$ 的函数。可以看出，简单截断法的思路是，如果某个维度的权重变化小于设定的$\theta$ ，则直接置为0。</p>
<h3 id="3-1-2-截断梯度法"><a href="#3-1-2-截断梯度法" class="headerlink" title="3.1.2 截断梯度法"></a>3.1.2 截断梯度法</h3><p>在前一种方法上的改进。加入了L1正则化项$\eta^{t}\lambda sgn(W^{t})$ 。</p>
<script type="math/tex; mode=display">
W^{t+1}=W^t-\eta ^tG^t-\eta^t\lambda sgn(W^t)</script><p>其中$sgn(v)$是符号函数。由于每次仅根据一个样本进行更新，因此也不再使用区分样本的下表$j$。</p>
<p>采用类似的方式表示为：</p>
<script type="math/tex; mode=display">
W^{t+1}=T_1(W^t - \eta^tG^t,\eta^t\lambda^t,\theta) \\
T_1(v_i,\alpha,\theta) = \begin{Bmatrix}
\begin{aligned}
& max(0,v_i-\alpha)\ if\ v_i\in [0,\theta]\\ 
& min(0,v_i+\alpha)\ if\ v_i\in [-\theta,0]\\
& v_i\ otherwise
\end{aligned}
\end{Bmatrix}</script><p>其中，$\lambda^{t} \in \mathbb{R}$且$\lambda^{t}\geqslant0 $ 。同样以k为窗口，每k步进行一次截断。当t/k不为整数时，$\lambda^{t}=0$， 否则，$\lambda^{t}=k\lambda$。可以看出，$\lambda$和$\theta$决定了权重的稀疏程度，这两个值越大越稀疏。</p>
<h2 id="3-2-前向后向切分FOBOS"><a href="#3-2-前向后向切分FOBOS" class="headerlink" title="3.2 前向后向切分FOBOS"></a>3.2 前向后向切分FOBOS</h2><h3 id="3-2-1-FOBOS算法原理"><a href="#3-2-1-FOBOS算法原理" class="headerlink" title="3.2.1 FOBOS算法原理"></a>3.2.1 FOBOS算法原理</h3><p>在FOBOS（Forward-backward Splitting）中，将权重的更新分为两个步骤：</p>
<script type="math/tex; mode=display">
W^{t+\frac{1}{2}} = W^t-\eta^tG^{t}\\
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t+\frac{1}{2}}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}
\tag {3-2-1}</script><p>前一个步骤还是标准的梯度下降，后一个步骤可以理解为对梯度下降的结果进行微调，其中第一项是L2正则化，表示不能离损失迭代结果太远，第二项$\Psi (W)$是正则化项。</p>
<p>将上面两个式子合并，有</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t}-\eta^{t}G^{t}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}</script><p>令</p>
<script type="math/tex; mode=display">
F(W)=\frac {1} {2} ||W- W^{t}-\eta^{t}G^{t}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)</script><p>如果$W^{t+1}$存在一个最优解，<strong><em>那么可以推断0向量一定属于$F(W)$的一维次梯度集合</em>。</strong></p>
<script type="math/tex; mode=display">
0 \in \partial F(W)=W-W^{t}+\eta^{t}G^{t}+\eta^{t+\frac 1 2}\partial \Psi(W)</script><blockquote>
<p><strong>次导数和次梯度</strong></p>
<p>参考SubGradient.pdf</p>
<p>次导数是一个区间，一维次梯度就是次导数</p>
</blockquote>
<p>由于$W^{t+1}=\arg \underset{x}{min} F(W)$，则有：</p>
<script type="math/tex; mode=display">
0=\left \{ W-W^{t} - \eta^{t}G^{t}+\eta^{t+\frac {1}{2}}\partial\Psi(W) \right \}|_{W=W^{t+1}}</script><p>便可以得到另一种更新权重的方式</p>
<script type="math/tex; mode=display">
W^{t+1}=W^{t}+ \eta^{t}G^{t}-\eta^{t+\frac {1}{2}}\partial\Psi(W^{t+1})</script><p>从上式可以看到权重的更新不仅与迭代前的状态有关，也与迭代后的$W^{t+1}$有关。</p>
<h3 id="3-2-2-L1-FOBOS"><a href="#3-2-2-L1-FOBOS" class="headerlink" title="3.2.2 L1-FOBOS"></a>3.2.2 L1-FOBOS</h3><p>在L1正则化下，有$\Psi (W)=\lambda||w||_1$ 。对于（2-3-1），</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t+\frac{1}{2}}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}</script><p>用向量V来表示$W^{t+\frac 1 2}$ ，用标量$\tilde{\lambda} \in \mathbb{R}$来表示$\eta^{t+\frac 1 2}\lambda$ ，将公式展开，并改写为</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min}\sum_{i=1}^N (\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)
\tag {3-2-2}</script><p>可以看到，在求和公式中的每一项都是大于0的，所以公式（3-2-2）可以拆解成对特征权重W的每一维度单独求解</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\arg \underset{w_i}{min}(\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)
\tag {3-2-3}</script><p>假设$w_i^<em>$是一个维度上的最优解，通过反证法证明$w_i^</em>v_i\geq0$（证明略）。再分$v_i\geq0$和$v_i&lt;0$来讨论。</p>
<p><strong>（1）当$v_i\geq0$时</strong>，</p>
<p>由于$w_i^<em>v_i\geq0$，所以$w_i^</em> \geq0$ 。相当于给（2-3-3）增加了一个不等式约束条件：</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\arg \underset{w_i}{min}(\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)\\
s.t. -w_i\leq 0</script><p>通过拉格朗日乘子求解这个含不等式的约束问题。</p>
<p>引入拉格朗日系数$\beta \geq 0$ ，由KKT条件，有</p>
<script type="math/tex; mode=display">
\frac \partial {\partial w_i}\left ( \frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|-\beta w_i \right )|_{w_i=w_i^*}=0 \\
\beta w_i^*=0</script><p>根据上面的求导可得</p>
<script type="math/tex; mode=display">
w_i^*=v_i-\tilde{\lambda}+\beta</script><p>再分为两种情况</p>
<p>① 当$w_i^<em> &gt; 0$ 时，由于$\beta w_i^</em>=0$ 所以$\beta=0$，此时有$w_i^*=v_i-\tilde{\lambda}$ ，从而$v_i-\tilde{\lambda} &gt; 0$ 。</p>
<p>② 当$w_i^* = 0$ 时，有$v_i-\tilde{\lambda}+\beta=0$ 。由于$\beta \geq 0$ ，所以$v_i-\tilde{\lambda} \leq 0$  。</p>
<p>可以得出，当$v_i\geq0$ 时，</p>
<script type="math/tex; mode=display">
w_i^* = max(0, v_i-\tilde{\lambda})</script><p><strong>（2）当$v_i&lt;0$时</strong>，</p>
<p>采用同样的分析方法，得到</p>
<script type="math/tex; mode=display">
w_i^* =- max(0, -v_i-\tilde{\lambda})</script><p>综上，可得FOBOS在L1正则化条件下，特征权重各个维度的更新方式为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
w_i^{t+1} &= sgn(v_i)max(0,|v_i|-\tilde{\lambda})\\
& = sgn(w_i^{t}-\eta^{t}g_i^{t})max \left \{ 0, |w_i^{t}-\eta^{t}g_i^{t}|-\eta^{t+ \frac {1} {2}} \lambda \right \}
 \end{aligned}
 \tag{3-2-4}</script><p>其中，$g_i^{t}$就是梯度在维度i上的取值。</p>
<p><strong>从公式（3-2-4）可以看出，L1-FOBOS每次更新W的时候，对W的每个维度都会进行判定，当$|w_i^{t}-\eta^{t}g_i^{t}|-\eta^{t+ \frac {1} {2}} \lambda&lt;0$的时候对齐进行截断，即权重置为0。</strong></p>
<p>换一种写法，</p>
<script type="math/tex; mode=display">
|w_i^{t}-\eta^{t}g_i^{t}|<\eta^{t+ \frac {1} {2}} \lambda
\tag {3-2-5}</script><p>可以看出截断的意义是，<strong>当一条样本产生的梯度不足以令对应维度上的权重值发生足够大的变大（$\eta^{t+ \frac {1} {2}} \lambda$ ），则认为在本次更新过程中该维度不重要，令其权重为0</strong>。</p>
<p>若对L1-FOBOS进行适当的变换，可以发现，L1-FOBOS就是TG在特定条件下的特殊形式。</p>
<h2 id="3-3-RDA"><a href="#3-3-RDA" class="headerlink" title="3.3 RDA"></a>3.3 RDA</h2><h3 id="3-3-1-RDA算法原理"><a href="#3-3-1-RDA算法原理" class="headerlink" title="3.3.1 RDA算法原理"></a>3.3.1 RDA算法原理</h3><p>TG和FOBOS都是建立在SGD的基础之上，属于梯度下降类型的方法，这类型方法的优点就是精度比较高，并且 TG、 FOBOS 也都能在稀疏性上得到提升。 但是有些其它类型的算法，例如 RDA，是从另一个方面来求解 Online Optimization 并且更有效地提升了特征权重的稀疏性。 </p>
<p>正则对偶平均（ RDA, Regularized Dual Averaging） 是微软十年的研究成果， RDA 是 Simple Dual Averaging Scheme 的一个扩展， 由 Lin Xiao 发表于 2010 年 。</p>
<p>在 RDA 中， 特征权重的更新策略为： </p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\Psi(W)+\frac {\beta^{t}}{t}h(W) \right \}
\tag {3-3-1}</script><p>本质上，公式（3-3-1）包括了3个部分：</p>
<p>（1）线性函数$\frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle$ 包含了之前所有梯度（或次梯度）的平均值（dual average），$G^r$ 是梯度；</p>
<p>（2）$\Psi(W)$ 为正则项；</p>
<p>（3）额外正则项$\frac {\beta^{t}}{t}h(W)$。其中$h(W)$是一个辅助的严格凸函数。${\beta^{t}|t\geq 1}$ 是一个非负且非自减序列。</p>
<h3 id="3-3-2-L1-RDA"><a href="#3-3-2-L1-RDA" class="headerlink" title="3.3.2 L1-RDA"></a>3.3.2 L1-RDA</h3><p>在L1正则化下，有$\Psi (W)=\lambda||w||_1$，并且由于$h(W)$是一个关于W的严格凸函数，就令$h(W)=\frac {1} {2} ||W||_2^2 $ 。此外，将${\beta^{t}|t\geq 1}$定义为$\beta^{t}=\gamma \sqrt t $ 。再代入（2-4-1），有</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\lambda||w||_1+\frac {\gamma} {2\sqrt t}||W||_2^2 \right \}
\tag {3-3-2}</script><p>分解到每一个权重的维度上</p>
<script type="math/tex; mode=display">
w_i^{t+1} = \arg \underset{w_i}{min} \left \{ \bar{g_i}^{t}w_i +\lambda|w_i|+\frac {\gamma} {2\sqrt t}w_i^2 \right \}
\tag {3-3-3}</script><p>这里$\lambda &gt;0,\ \frac {\gamma} {\sqrt t}&gt;0,\  \bar{g<em>i}^{t} = \frac 1 t \sum</em>{r=1}^t g_i^{(r)}$ 。公式（2-4-3）就是一个无约束的非平滑最优化问题（因为第二项$\lambda|w_i|$ 在0处不可导）。所以用次导数求解。</p>
<p>假设$w_i^<em>$ 是其最优解，并且定义$\xi \in \partial  |w_i|$为$|w_i|$ 在$w_i^</em>$ 的次导数，则有</p>
<script type="math/tex; mode=display">
\partial |w_i^*| =  \left\{\begin{matrix}
-1<\xi<1  & if w_i^*=0\\ 
1 & if w_i^*>0\\ 
-1 & if w_i^*<0
\end{matrix}\right.</script><p>对公式（3-3-3）求次导数，并令其为0，则有</p>
<script type="math/tex; mode=display">
\bar{g_i}^{t} + \lambda\xi + \frac {\gamma} {\sqrt t} w_i = 0</script><p>由于$\lambda &gt;0$，再分情况讨论（略），可以得到L1-RDA特征权重的各个维度更新的方式为：</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\begin{Bmatrix}
0 & if |\bar{g_i}^{t}|<\lambda\\ 
-\frac {\sqrt t}{\gamma}\left (\bar{g_i}^{t}-\lambda sgn(\bar{g_i}^{t})  \right ) & otherwise
\end{Bmatrix}
\tag {3-3-4}</script><p><strong>这里可以看出，当某个维度上累积梯度平均值的绝对值小于阈值$\lambda$ 时，产生截断</strong>。</p>
<h3 id="3-3-3-L1-RDA和L1-FOBOS的比较"><a href="#3-3-3-L1-RDA和L1-FOBOS的比较" class="headerlink" title="3.3.3 L1-RDA和L1-FOBOS的比较"></a>3.3.3 L1-RDA和L1-FOBOS的比较</h3><p>在L1-FOBOS中，进行截断的条件是</p>
<script type="math/tex; mode=display">
|w_i^{t}-\eta^{t}g_i^{t}|<\eta^{t+ \frac {1} {2}} \lambda</script><p>通常会定义$\eta$为与$\frac 1 {\sqrt t}$ 正相关的函数$\eta=\Theta \left ( \frac {1} {\sqrt t} \right )$ 。因此L1-FOBOS的<strong>截断阈值为$\Theta \left ( \frac {1} {\sqrt t} \right )\lambda$  ，</strong>随着**t的增加，这个阈值会逐渐降低。</p>
<p>相比较而言，L1-RDA的<strong>截断阈值是$\lambda$ </strong>。是一个常数，并不随着t变化，因此相对于L1-FOBOS更简单粗暴。这种性质使得L1-RDA更容易产生稀疏性。此外， RDA 中判定截断的对象是梯度的累加平均值$\bar{g_i}^{t} $ ， 不同于 TG或L1-FOBOS 中针对单次梯度计算的结果进行判定，避免了由于某些维度由于训练不足导致截断的问题。 并且通过调节一个参数$\lambda$，很容易在精度和稀疏性上进行权衡 。</p>
<h2 id="3-4-FTRL"><a href="#3-4-FTRL" class="headerlink" title="3.4 FTRL"></a>3.4 FTRL</h2><p>有实验证明， <strong>L1-FOBOS 这一类基于梯度下降的方法有比较高的精度，但是 L1-RDA 却能在损失一定精度的情况下产生更好的稀疏性。 FTRL则是结合了两者的优点</strong>。</p>
<h3 id="3-4-1-L1-FOBOS和L1-RDA在形式上的统一"><a href="#3-4-1-L1-FOBOS和L1-RDA在形式上的统一" class="headerlink" title="3.4.1 L1-FOBOS和L1-RDA在形式上的统一"></a>3.4.1 L1-FOBOS和L1-RDA在形式上的统一</h3><p>之前提到，L1-FOBOS可以表示为（这里令$\eta^{t+\frac 1 2}=\eta^t=\Theta(\frac 1 {\sqrt t})$  是一个随t变化的非增正序列） </p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^t-\eta^tG^t||^2+\eta^{t}\lambda||w||_1\}</script><p>将其按W的维度分解为N个独立的最优化步骤</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize} \left \{  \frac 1 2 (w_i-w_i^t+\eta^tg_i^t)^2+\eta^t\lambda|w_i| \right \}\\
=\underset{w_i}{minimize}\left \{  \frac 1 2 (w_i-w_i^t)^2 + \frac 1 2(\eta^tg_i^t)^2+w_i\eta^tg_i^t- w_i^t\eta^tg_i^t+    \eta^t\lambda|w_i| \right \}\\</script><p>同时除以$\eta^t$ ，得到</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize}\left \{ w_ig_i^t+\lambda|w_i|+\frac 1 {2\eta^t}(w_i-w_i^t)^2 + [\frac {\eta^t}{2}(g_i^t)2+w_i^tg_i^t] \right \}</script><p>由于$\frac {\eta^t}{2}(g_i^t)2+w_i^tg_i^t$ 与变量$w_i$ 无关，因此上式可以等价于</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize}\left \{ w_ig_i^t+\lambda|w_i|+\frac 1 {2\eta^t}(w_i-w_i^t)^2 +  \right \}</script><p>再将这N个独立的合并，则L1-FOBOS可以写成</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ G^t\cdot W+\lambda||W||_1+\frac 1 {2\eta^t}||W-W^t||_2^2 \right \}</script><p>而对于L1-RDA的公式（3-3-2）</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\lambda||w||_1+\frac {\gamma} {2\sqrt t}||W||_2^2 \right \} \\</script><p>同时乘以t，得到</p>
<script type="math/tex; mode=display">
\begin{aligned} 
W^{t+1} & = \arg \underset{W}{min} \left \{ \sum_{r=1}^t  G^r \cdot W  +t\lambda||w||_1+\frac {1} {2\eta^t}||W-0||_2^2 \right \}\\
& =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +t\lambda||w||_1+\frac {1} {2\eta^t}||W-0||_2^2 \right \}
\end{aligned}</script><p>如果令$\sigma ^s = \frac 1 {\eta^s}-\frac 1 {\eta^{s-1}}$  ，则$\sigma^{1:t} = \frac 1 {\eta^t}$ 。L1-FOBOS和L1-RDA的公式可以写成</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ G^t\cdot W+\lambda||W||_1+\frac 1 2\sigma^{1:t}||W-W^t||_2^2 \right \}\\
W^{t+1} =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +t\lambda||W||_1+\frac 1 2\sigma^{1:t}||W-0||_2^2 \right \}
\tag {3-4-1}</script><p>比较这两个公式，可以看出L1-FOBOS和L1-RDA的区别在于：</p>
<p>（1）前者对梯度只考虑当前的状态，而后者的梯度是累加的形式；</p>
<p>（2）前者的第三项限制了W的变化不能离已经迭代过的解太远，后者限制W不能离0太远。</p>
<h3 id="3-4-2-FTRL算法原理"><a href="#3-4-2-FTRL算法原理" class="headerlink" title="3.4.2 FTRL算法原理"></a>3.4.2 FTRL算法原理</h3><p>FTRL综合考虑了L1-FOBOS和L1-RDA中对正则项和W限制的区别，其特征权重的更新公式为</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +\lambda_1||W||_1+\lambda_2||W||_2^2+\frac 1 2\sum_{s=1}^t \sigma^s ||W-W^s||_2^2 \right \}
\tag {3-4-2}</script><p>其中L2的正则项在论文中并没有出现，但是2013年的FTRL工程化实现的论文却使用。事实上该项的引入并不影响FRTL<br>的稀疏性， 后面的推导过程会显示这一点。 L2正则项的引入仅仅相当于对最优化过程多了一个约束，使得结果求解结果更加“平滑”。 </p>
<p>对（3-4-2）进行变换，将其的最后一项展开</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  (G^{1:t}-\sum_{s=1}^t\sigma^sW^s) \cdot W  +\lambda_1||W||_1+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)||W||_2^2+\frac 1 2\sum_{s=1}^t \sigma^s ||W^s||_2^2 \right \}</script><p>其中，由于$\frac 1 2\sum_{s=1}^t \sigma^s ||W^s||_2^2$ 相对于W是常数项，再令</p>
<script type="math/tex; mode=display">
Z^{t} =G^{1:t}-\sum_{s=1}^t\sigma^sW^s
\tag {3-4-3}</script><p>上式等价于</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  Z^t \cdot W  +\lambda_1||W||_1+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)||W||_2^2 \right \}</script><p>再针对每个维度将其拆解成N个独立的标量最小化问题</p>
<script type="math/tex; mode=display">
 \underset{w_i}{minimize} \left \{  z_i^tw_i  +\lambda_1|w_i|+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)w_i^2 \right \}</script><p>到这里，遇到了与L1-RDA的（3-3-3）类似的优化问题，用相同的分析方法可以得到</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\left\{\begin{matrix}
0 & if\ |z_i^t|<\lambda_1\\ 
-\left ( \lambda_2+\sum_{s=1}^t\sigma^s \right )^{-1}\ \left ( z_i^t-\lambda_1 sgn(z_i^t) \right ) & otherwise
\end{matrix} \right.
\tag {3-4-4}</script><p>可以看出，引入L2并没有对FTRL结果的稀疏性产生影响。</p>
<h3 id="3-4-3-学习率"><a href="#3-4-3-学习率" class="headerlink" title="3.4.3 学习率"></a>3.4.3 学习率</h3><p>前面的推导中，学习率的选择和计算没有被提及。事实上在FTRL中，每个维度的学习率都是单独考虑的。</p>
<p>考虑特征维度的变化率：如果特征 1 比特征 2 的变化更快，那么在维度 1 上的学习率应该下降得更快。我们很容易就可以想到可以用某个维度上梯度分量来反映这种变化率。在FTRL 中，维度 i上的学习率是这样计算的<strong>（原作者没有推导过程）</strong>：</p>
<script type="math/tex; mode=display">
\eta_i^t=\frac {\alpha}{\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}</script><p>由于$\sum_{s=1}^t\sigma^s=\frac 1 {\eta^t}$ ，因此（3-4-4）就变成</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\left\{\begin{matrix}
0 & if\ |z_i^t|<\lambda_1\\ 
-\left ( \lambda_2 + \frac {\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}{\alpha}  \right )^{-1}\ \left ( z_i^t-\lambda_1 sgn(z_i^t) \right ) & otherwise
\end{matrix} \right.
\tag {3-4-5}</script><p>这里的$\alpha, \beta$ 都是要输入的参数。</p>
<h3 id="2-5-4-伪代码解读"><a href="#2-5-4-伪代码解读" class="headerlink" title="2.5.4 伪代码解读"></a>2.5.4 伪代码解读</h3><p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/FTRL伪代码.png" alt="FTRL伪代码"></p>
<p>首先设置各个参数的初始值，包括</p>
<ul>
<li>更新学习率的$\alpha,\beta$。</li>
<li>L1和L2正则化的参数$\lambda_1,\ \lambda_2$ </li>
<li>更新权重时用到的$z_i$ 一维数组（数组的长度是特征项个数），初始值是0</li>
<li>存放梯度累加的$n_i$ 一维数组（数组的长度是特征项个数），初始值是0</li>
</ul>
<p>算法步骤中：</p>
<p>（1）第一阶段，计算第t次迭代的预测值</p>
<p><strong>S1</strong>：用给定的初始值计算权重$w_{t,i}$，并计算出预测值$p_t$ 。见①</p>
<p>（2）第二阶段，更新第t+1次的权重，对当前样本不为0的每个特征项都要进行一次更新。在第i个特征项中，</p>
<p><strong>S1</strong>：采用logloss计算损失函数的梯度$g_{t+1}$，见②</p>
<p><strong>S2</strong>：可以看出①里面还需要计算$n_i$  和$z_i$ 在第t+1次的值。</p>
<p>对于$z_i$，根据公式（2-5-3）</p>
<script type="math/tex; mode=display">
Z^{t} =G^{1:t}-\sum_{s=1}^t\sigma^sW^s</script><p>可以看出z的更新可以通过下式计算</p>
<script type="math/tex; mode=display">
\begin {aligned}
Z^{t+1}& =G^{1:t+1}-\sum_{s=1}^{t+1}\sigma^sW^s\\
&=G^{1:t}-\sum_{s=1}^t\sigma^sW^s + G^{t+1} - \sigma^{t+1}W^{t+1}\\
&=Z^t + G^{t+1} - \sigma^{t+1}W^{t+1}
 \end{aligned}
 \tag {3-4-6}</script><p>则需要计算$\sigma^{t+1}$ 的值。而根据上文的推导</p>
<script type="math/tex; mode=display">
\sigma ^s = \frac 1 {\eta^s}-\frac 1 {\eta^{s-1}}</script><p>又</p>
<script type="math/tex; mode=display">
\eta_i^t=\frac {\alpha}{\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}</script><p>则</p>
<script type="math/tex; mode=display">
\begin {aligned}
\sigma ^{t+1}& = \frac 1 {\eta^{t+1}}-\frac 1 {\eta^t}\\
&=\frac {\beta + \sqrt {\sum_{s=1}^{t+1} (g_i^s)^2}}{\alpha}-\frac {\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}{\alpha}\\
&=\frac 1 \alpha \left ( \sqrt {\sum_{s=1}^{t+1} (g_i^s)^2}- \sqrt {\sum_{s=1}^t (g_i^s)^2}\right )
 \end{aligned}</script><p>由于用$n_i$ 记录$g_i$ 的累加和，上式可以变成</p>
<script type="math/tex; mode=display">
\sigma ^{t+1} = \sqrt {n^t+(g^{t+1})^2}-\sqrt {n^t}
\tag {3-4-7}</script><p>见③。再根据公式（3-4-6），计算$z_i$ 的值，见④。</p>
<p><strong>S3</strong>：对于$n_i$ ，根据公式（3-4-7），</p>
<script type="math/tex; mode=display">
n^{t+1} = n^t +(g^{t+1})^2</script><p>见⑤。</p>
<h3 id="2-5-5-实现代码"><a href="#2-5-5-实现代码" class="headerlink" title="2.5.5 实现代码"></a>2.5.5 实现代码</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span></span>(x: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</div><div class="line">  <span class="keyword">var</span> wTx = <span class="number">0.0</span></div><div class="line"></div><div class="line">  x foreach &#123; x =&gt;</div><div class="line">    <span class="keyword">val</span> sign = <span class="keyword">if</span> (z(x) &lt; <span class="number">0</span>) <span class="number">-1.0</span> <span class="keyword">else</span> <span class="number">1.0</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sign * z(x) &lt;= <span class="type">L1</span>)</div><div class="line">      w(x) = <span class="number">0.0</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      w(x) = (sign * <span class="type">L1</span> - z(x)) / ((beta + math.sqrt(n(x))) / alpha + <span class="type">L2</span>)</div><div class="line"></div><div class="line">    wTx = wTx + w(x)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + math.exp(-math.max(math.min(wTx, <span class="number">35.0</span>), <span class="number">-35.0</span>)))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(x: <span class="type">Array</span>[<span class="type">Int</span>], p: <span class="type">Double</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> g = p - y</div><div class="line"></div><div class="line">  x foreach &#123; x =&gt;</div><div class="line">    <span class="keyword">val</span> sigma = (math.sqrt(n(x) + g * g) - math.sqrt(n(x))) / alpha</div><div class="line">    z(x) = z(x) + g - sigma * w(x)</div><div class="line">    n(x) = n(x) + g * g</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，在更新权重时，SGD和FTRL的区别在于：</p>
<p><del>SGD在遍历每个样本的时候，都会更新所有维度的权重，而FTRL在遍历每个样本的时候只会更新样本对应维度的权重。从而可以节省训练的时间</del></p>
<p>并不是节省时间。SGD也可以用于在线学习，过拟合的限制上没有FTRL好。参数太多，会导致模型复杂度上升，容易过拟合。</p>
<h3 id="3-4-6-实验及结论"><a href="#3-4-6-实验及结论" class="headerlink" title="3.4.6 实验及结论"></a>3.4.6 实验及结论</h3><p>1、</p>
<p>训练：16-10-22的前7天数据</p>
<p>预测：16-10-22当天数据</p>
<p>维度：1048576</p>
<p>参数：默认</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc3.png" alt="roc3"></p>
<p>logloss：</p>
<p>线上方法：0.274321867859</p>
<p>FRTL：0.0326626593411</p>
<p>2、</p>
<p>训练：16-10-22的前7天数据</p>
<p>预测：16-10-22当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：1048576</p>
<p>参数：默认</p>
<p>训练时间：11:54-12:18</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc1.png" alt="roc1"></p>
<p>logloss：</p>
<p>线上方法：0.275704770725</p>
<p>FRTL：0.032281346379</p>
<p>3、</p>
<p>训练集：16-10-18的前10天数据</p>
<p>预测：16-10-18当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：4194304</p>
<p>参数：默认</p>
<p>训练时间：13:50-14:19</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc2.png" alt="roc2"></p>
<p>logloss</p>
<p>线上方法：0.073087783303</p>
<p>FTRL：0.022967801811</p>
<p>4、</p>
<p>训练集：16-10-18的前10天数据</p>
<p>预测：16-10-18当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：4194304</p>
<p>参数：训练的特征项改为1-10</p>
<p>训练时间：17:07-17:45</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc4.png" alt="roc4"></p>
<p>logloss</p>
<p>线上方法：0.073087783303</p>
<p>FTRL：0.0221369813697</p>
<p>特征权重不为0的维度有11301个</p>
<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p>FTRL在线训练时间长了效果往往会下降，因为学习率会逐渐降低，必须要offline结合online。</p>
<h1 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h1><p>【在线最优化求解(Online Optimization)-冯扬】</p>
<p>【逻辑回归从入门到精通-腾讯柳超】</p>
<p>【FTRL的理论论文】Factorization machines with follow-the-regularized-leader for CTR prediction in display advertising  <a href="http://www0.cs.ucl.ac.uk/staff/w.zhang/rtb-papers/fm-ftrl.pdf" target="_blank" rel="noopener">http://www0.cs.ucl.ac.uk/staff/w.zhang/rtb-papers/fm-ftrl.pdf</a></p>
<p>【FTRL的工程实现论文】<a href="https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf" target="_blank" rel="noopener">https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf</a> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/hadoop-spark/spark/spark笔记-local开发/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/hadoop-spark/spark/spark笔记-local开发/" class="post-title-link" itemprop="url">spark笔记-local开发</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-13 10:00:42" itemprop="dateModified" datetime="2018-11-13T10:00:42+08:00">2018-11-13</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hadoop-spark/" itemprop="url" rel="index"><span itemprop="name">hadoop-spark</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/hadoop-spark/spark/spark笔记-local开发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/hadoop-spark/spark/spark笔记-local开发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mac安装spark环境"><a href="#mac安装spark环境" class="headerlink" title="mac安装spark环境"></a>mac安装spark环境</h1><p><a href="https://blog.csdn.net/python_tty/article/details/72820469" target="_blank" rel="noopener">https://blog.csdn.net/python_tty/article/details/72820469</a></p>
<h2 id="安装scala"><a href="#安装scala" class="headerlink" title="安装scala"></a>安装scala</h2><p><a href="https://downloads.lightbend.com/scala/2.10.7/scala-2.10.7.tgz" target="_blank" rel="noopener">2.10.7</a></p>
<p>下载后放到<code>david/david/opt/scala</code></p>
<p>修改<code>.bash_profile</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export SCALA_HOME=&quot;/Users/david/david/opt/scala-2.10.7&quot;</div><div class="line">export PATH=&quot;$SCALA_HOME/bin:$PATH&quot;</div></pre></td></tr></table></figure>
<h2 id="下载spark"><a href="#下载spark" class="headerlink" title="下载spark"></a>下载spark</h2><p><a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">http://spark.apache.org/downloads.html</a></p>
<p>下载的是1.6.3的版本</p>
<p>加到环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export SPARK_HOME=&quot;/Users/david/david/opt/spark-1.6.3-bin-hadoop2.6&quot;</div><div class="line">export PATH=&quot;$SPARK_HOME/bin:$PATH&quot;</div></pre></td></tr></table></figure>
<h2 id="允许ssh"><a href="#允许ssh" class="headerlink" title="允许ssh"></a>允许ssh</h2><h2 id="启动spark-shell"><a href="#启动spark-shell" class="headerlink" title="启动spark-shell"></a>启动spark-shell</h2><p>进入到spark安装目录的sbin/目录下，执行 ./start-all 启动spark </p>
<p>进入到spark安装目录的bin/目录下，执行 ./spark-shell，看spark 是否安装成功</p>
<h1 id="spark开发环境"><a href="#spark开发环境" class="headerlink" title="spark开发环境"></a>spark开发环境</h1><p>一、环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">			&lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">			&lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;</div><div class="line">			&lt;version&gt;1.6.1&lt;/version&gt;</div><div class="line">		&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>二、编写local的spark程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import org.apache.log4j.&#123; Level, Logger &#125;</div><div class="line">import org.apache.spark.&#123; SparkConf, SparkContext &#125;</div><div class="line"></div><div class="line">def main(args: Array[String]): Unit = &#123;</div><div class="line">    //关闭一些不必要的日志</div><div class="line">    Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.WARN)</div><div class="line">    Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF)</div><div class="line">    </div><div class="line">    val conf = new SparkConf().setAppName(&quot;wordSegname&quot;).setMaster(&quot;local[4]&quot;).</div><div class="line">    set(&quot;spark.sql.shuffle.partitions&quot;,&quot;10&quot;).set(&quot;spark.network.timeout&quot;,&quot;30s&quot;)</div><div class="line">    .set(&quot;spark.shuffle.compress&quot;,&quot;true&quot;).set(&quot;spark.shuffle.spill.compress&quot;,&quot;true&quot;)</div><div class="line">    .set(&quot;spark.shuffle.manager&quot;,&quot;sort&quot;)</div><div class="line">    val sc = new SparkContext(conf)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>程序示例<code>[WordTest.scala](../../../../code/spark/spark-buzzads/src/main/scala/com/iclick/word_segmentation/WordTest.scala)</code></p>
<h1 id="spark数据操作"><a href="#spark数据操作" class="headerlink" title="spark数据操作"></a>spark数据操作</h1><h2 id="sparkRDD"><a href="#sparkRDD" class="headerlink" title="sparkRDD"></a>sparkRDD</h2><h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><p>1、数据集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">    var data = Array(1,2,3,4,5,6,7,8,9)</div><div class="line">    var disData = sc.parallelize(data,3)</div></pre></td></tr></table></figure>
<p>创建一个RDD，包括1-9，分在3个分区</p>
<p>2、外部数据源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textFile(path:String, minPartitions:Int) //第一个指定路径，第二个指定分区</div></pre></td></tr></table></figure>
<h3 id="RDD转换"><a href="#RDD转换" class="headerlink" title="RDD转换"></a>RDD转换</h3><p>1、map，对每个元素执行一个指定函数产生新的RDD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val rdd1 = sc.parallelize(1 to 9, 3)</div><div class="line">val rdd2 = rdd1.map(x =&gt; x*2)</div></pre></td></tr></table></figure></p>
<h1 id="spark-hive-local"><a href="#spark-hive-local" class="headerlink" title="spark hive local"></a>spark hive local</h1><p>local的spark连接测试服务器的hive</p>
<p>1、复制hive环境上的<code>hdfs-site.xml</code>和<code>hive-site.xml</code>到项目的resource，如果有不识别的hostname则修改</p>
<p>2、写法类似于</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mljr.spark.gps.sample</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.hive.<span class="type">HiveContext</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">HiveTest</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"test"</span>).setMaster(<span class="string">"local[2]"</span>)</div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</div><div class="line">    <span class="keyword">val</span> sqlContext = <span class="keyword">new</span> <span class="type">HiveContext</span>(sc)</div><div class="line">    sqlContext.sql(<span class="string">"SELECT * FROM bdwh_tbl.tbl_s057_car_gps_position limit 1"</span>).collect.foreach(println)</div><div class="line">	sc.stop()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.Session</div></pre></td></tr></table></figure>
<p>这是因为在创建<code>SQLContext</code>实例的时候，要求spark编译的Hive版本和HiveMetaStore里面记录的Hive版本一致，我们可以通过配置<code>hive.metastore.schema.verification</code>参数来取消这种验证，这个参数的默认值是true，我们可以取消验证，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;property&gt;  </div><div class="line">   &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;  </div><div class="line">   &lt;value&gt;false&lt;/value&gt;  </div><div class="line">    &lt;description&gt;  </div><div class="line">    Enforce metastore schema version consistency.  </div><div class="line">    True: Verify that version information stored in metastore matches with one from Hive jars.  Also disable automatic  </div><div class="line">          schema migration attempt. Users are required to manully migrate schema after Hive upgrade which ensures  </div><div class="line">          proper metastore schema migration. (Default)  </div><div class="line">    False: Warn if the version information stored in metastore doesn&apos;t match with one from in Hive jars.  </div><div class="line">    &lt;/description&gt;  </div><div class="line"> &lt;/property&gt;</div></pre></td></tr></table></figure>
<p>再报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Could not connect to meta store using any of the URIs provided. Most recent failure: org.apache.thrift.transport.TTransportException: java.net.UnknownHostException: slave1</div></pre></td></tr></table></figure>
<h1 id="控制日志输出级别"><a href="#控制日志输出级别" class="headerlink" title="控制日志输出级别"></a>控制日志输出级别</h1><p>修改log4j.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">log4j.rootCategory=WARN, console</div></pre></td></tr></table></figure>
<p>默认是<code>INFO, console</code>，</p>
<p>更丰富的可以是<code>STDOUT, DEBUG, INFO, console</code></p>
<p>精简的是<code>WARN, console</code></p>
<h1 id="no-snappyjava-in-java-library-path"><a href="#no-snappyjava-in-java-library-path" class="headerlink" title="no snappyjava in java.library.path"></a>no snappyjava in java.library.path</h1><p><a href="https://stackoverflow.com/questions/30039976/unsatisfiedlinkerror-no-snappyjava-in-java-library-path-when-running-spark-mlli" target="_blank" rel="noopener">https://stackoverflow.com/questions/30039976/unsatisfiedlinkerror-no-snappyjava-in-java-library-path-when-running-spark-mlli</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;$&#123;spark.version&#125;&lt;/version&gt;</div><div class="line">    &lt;exclusions&gt;</div><div class="line">        &lt;exclusion&gt;</div><div class="line">           &lt;groupId&gt;org.xerial.snappy&lt;/groupId&gt;</div><div class="line">           &lt;artifactId&gt;snappy-java&lt;/artifactId&gt;</div><div class="line">        &lt;/exclusion&gt;</div><div class="line">    &lt;/exclusions&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>and then adding</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.xerial.snappy&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;snappy-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.0.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/机器学习笔记-最大熵/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/机器学习笔记-最大熵/" class="post-title-link" itemprop="url">机器学习笔记-最大熵</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/机器学习笔记-最大熵/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/机器学习笔记-最大熵/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、最大熵原理"><a href="#1、最大熵原理" class="headerlink" title="1、最大熵原理"></a>1、最大熵原理</h1><p>日常生活中，很多事情的发生表现出一定的随机性，试验的结果往往是不确定的，也不知道这个随机现象所服从的概率分布。<strong>最大熵的实质</strong>就是，在已知部分知识的前提下，关于未知分布最合理的推断就是符合已知知识最不确定或者最随机的推断。任何其他的选择都意味着我们增加了其他的约束和假设。</p>
<p>将最大熵应用到分类，就是最大熵模型。给定一个训练集：</p>
<script type="math/tex; mode=display">
T = \{  (x_1,y_1),  (x_2,y_2),..., (x_N,y_N)\}</script><p>其中$x_i \in X$是输入，$y_i \in Y$是输出，X和Y表示输入和输出空间。N为样本数。<strong>目标是</strong>，利用最大熵原理选出一个最好的分类模型，即对于任意给定的输入$x \in X$，可以以概率$p(y|x)$输出$y \in Y$ 。</p>
<p>按照最大熵原理，应该<strong>优先保证模型满足已知的所有约束</strong>。思路是，从训练数据T中抽取若干有用的特征，要求这些特征在T上关于经验分布$\tilde{p}(x,y)$的数学期望与它们在模型中关于$p(x,y)$的数学期望相等。这样，一个特征就是一个约束了。</p>
<p>这里就涉及到，<strong>特征如何刻画？经验分布如何表示？</strong></p>
<h1 id="2、特征函数"><a href="#2、特征函数" class="headerlink" title="2、特征函数"></a>2、特征函数</h1><p>假设通过特征选择，抽取若干特征。特征通常由特征函数来表示。例如</p>
<script type="math/tex; mode=display">
f(x,y) =\left\{\begin{matrix}
\begin{aligned}
& 1，若x,y满足某个事实 \\ 
& 0，否则
\end{aligned}
\end{matrix}\right.</script><p>这里的特征不是指输入的某个特征，而是指输入和输出共同的特征。</p>
<blockquote>
<p>例如，假设我们需要判断“打”是动词还是量词，已知的训练数据有</p>
<p>(x1,y1)=(一打火柴，量词);</p>
<p>(x2,y2)=(三打啤酒，量词);</p>
<p>(x3,y3)=(打电话，动词);</p>
<p>(x4,y4)=(打篮球，动词);</p>
<p>通过观察，发现“打”前面是数字时，是量词，“打”后面是名词时，是动词。这就是从训练数据中提取的两个特征，可分别用特征函数表示为</p>
</blockquote>
<h1 id="3、经验分布"><a href="#3、经验分布" class="headerlink" title="3、经验分布"></a>3、经验分布</h1><p>经验（概率）分布就是通过对训练集T进行统计得到的分布，用$\tilde p$表示。这里列举两个经验分布</p>
<script type="math/tex; mode=display">
\tilde p(x,y) = \frac {count(x,y)} {N} , \tilde p(x)=\frac {count(x)} {N}</script><p>其中，count表示出现的次数。</p>
<h1 id="4、约束条件"><a href="#4、约束条件" class="headerlink" title="4、约束条件"></a>4、约束条件</h1><p>对于任意一个特征函数f，$E<em>{\tilde p}f$ 表示f在训练数据T上关于$\tilde p(x,y)$的数学期望， $E</em>{p}f$ 表示f在训练数据T上关于$p(x,y)$的数学期望。按照期望的定义，我们有</p>
<script type="math/tex; mode=display">
E_{\tilde p}f=\sum_{x,y}\tilde p(x,y)f(x,y)</script><script type="math/tex; mode=display">
E_{ p}f=\sum_{x,y} p(x,y)f(x,y)</script><p>其中，p(x,y)是未知的，而建模的目标是生成$p(y|x)$，因此，根据Bayes定理，$p(x,y)=p(x)p(y|x)$。在样本数量足够的条件下，$p(x)$可以用$\tilde p(x)$近似表示。这样</p>
<script type="math/tex; mode=display">
E_{ p}f=\sum_{x,y} \tilde p(x)p(y|x)f(x,y)</script><p>对于概率分布$p(y|x)$，我们希望特征f的期望值应该和从训练集中得到的特征期望值是一致的，因此，<strong>增加约束</strong></p>
<script type="math/tex; mode=display">
E_{ p}f=E_{\tilde p}f</script><p>假设我们从训练集中抽取了n个特征，相应的，便有n个特征函数$f_i(i=1,2,…,n)$以及n个约束条件</p>
<script type="math/tex; mode=display">
C_i:E_{ p}(f_i)=E_{\tilde p}(f_i) \tag {3-1}</script><blockquote>
<p>关于约束条件的几何解释</p>
<p><img src="/2017/07/12/机器学习/机器学习笔记-最大熵/最大熵1.png" alt="最大熵1"></p>
<p>（a）：P是所有可能的概率空间，此时没有约束条件，所有的概率模型$p(y|x)$都是允许的；</p>
<p>（b）：增加了一个线性约束条件$C_1$，此时，目标分布$p(y|x)$只能落在由$C_1$定义的线段上；</p>
<p>（c）：在（b）的基础上增加了另一个约束条件$C_2$ ，且$C_1 \cap C_2  \neq \varnothing$。此时，目标分布只能落在交点上，即被唯一确定；</p>
<p>（d）：在（b）基础上增加了另一个约束$C_3$，且$C_1 \cap C_2  = \varnothing$，此时不存在能够同时满足$C_1$和$C_3$的$p(y|x)$。</p>
</blockquote>
<p>利用（3-1）定义的约束条件，我们定义P的一个子空间</p>
<script type="math/tex; mode=display">
C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><h1 id="5、最大熵模型"><a href="#5、最大熵模型" class="headerlink" title="5、最大熵模型"></a>5、最大熵模型</h1><p>由于我们的目标是获得一个条件分布，因此这里也采用相应的条件熵</p>
<script type="math/tex; mode=display">
H(p(y|x))=-\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)</script><p>可以看出这里也是用$\tilde p(x)$来近似$p(x)$。以下将$H(p(y|x))$简记为$H(p)$。至此，可以给出最大熵模型的完整描述。</p>
<p>对于给定的训练集T，特征函数$f_i(x,y), i=1,2,…n$，最大熵模型就是求解</p>
<script type="math/tex; mode=display">
\underset {p \in C} {max} \ \  H(p) = \begin{pmatrix}
-\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)
\end{pmatrix}, \\
s.t. \sum_y p(y|x)=1 \tag {5-1} \\
s.t. \ C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><p>其中的s.t.是为了保证$p(y|x)$是一个（合法的）条件概率分布。</p>
<p>等价于一个求极小值问题</p>
<script type="math/tex; mode=display">
\underset {p \in C} {min} \ \  -H(p) = \begin{pmatrix}
\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)
\end{pmatrix}, \\
s.t. \sum_y p(y|x)=1 \tag {5-2} \\
s.t. \ C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><h1 id="6、模型求解"><a href="#6、模型求解" class="headerlink" title="6、模型求解"></a>6、模型求解</h1><p>对于5-1的求解，主要思路和步骤如下：</p>
<ol>
<li>利用Lagrange乘子将最大熵模型由一个带约束的最优化问题转为无约束的最优化问题，这是一个<strong>极小极大问题（min max）</strong>。</li>
<li>利用对偶问题等价性，转化为求解上一步得到的极大/极小问题的对偶问题，也是一个极大极小问题。</li>
</ol>
<h2 id="6-1-原始问题和对偶问题"><a href="#6-1-原始问题和对偶问题" class="headerlink" title="6.1 原始问题和对偶问题"></a>6.1 原始问题和对偶问题</h2><p>根据（5-2），引入拉格朗日乘子$\lambda=(\lambda_0,\lambda_1,…,\lambda_n)^T$，定义拉格朗日函数</p>
<script type="math/tex; mode=display">
L(p,\lambda) = -H(p) + \lambda_0(1-\sum_y p(y|x))+\sum_{i=1}^n\lambda_i(\tau_i-E_p(f_i))  \tag{6-1}</script><p>利用对偶性，求解（6-1）的<strong>原始问题</strong>表示为：</p>
<script type="math/tex; mode=display">
\underset {p \in C} {min}\  \underset {\lambda} {max}\ L(p,\lambda) \tag{6-2}</script><p><strong>对偶问题</strong>为：</p>
<script type="math/tex; mode=display">
\underset {\lambda} {max}\ \underset {p \in C} {min}\  L(p,\lambda) \tag{6-3}</script><p>由于$H(p)$是关于p的凸函数，因此要求解最大熵模型，只需求解对偶问题（6-3）即可。</p>
<h3 id="6-1-1-指数形式的解"><a href="#6-1-1-指数形式的解" class="headerlink" title="6.1.1 指数形式的解"></a>6.1.1 指数形式的解</h3><p>首先求解内部的极小问题。由于$\underset {p \in C} {min}\  L(p,\lambda)$是关于$\lambda$的函数，将其记做：</p>
<script type="math/tex; mode=display">
\Psi (\lambda) =\underset {p \in C} {min}\  L(p,\lambda) = L(p_{\lambda}, \lambda) \tag {6-4}</script><p>其中</p>
<script type="math/tex; mode=display">
p_{\lambda}=\underset {p \in C} {argmin}\ L(p,\lambda)=p_{\lambda}(y|x) \tag {6-5}</script><p>根据拉格朗日乘子法，求$L(p,\lambda)$对$p(y|x)$的偏导，得（求解过程略）：</p>
<script type="math/tex; mode=display">
p_{\lambda}=\frac {1} {Z_{\lambda}(x)} \ \exp(\sum_{i=1}^n \lambda_i f_i(x,y)) \tag{6-6}</script><p>其中，</p>
<script type="math/tex; mode=display">
Z_{\lambda}(x)=\sum_y \exp(\sum_{i=1}^n \lambda_i f_i(x,y)) \tag{6-7}</script><p>称为<strong>规范化因子</strong>（normalizing factor）。注意，此时已经没有$\lambda_0$了。</p>
<p>由（6-6）定义的$p_{\lambda}$就是最大熵模型的解，它具有<strong>指数形式</strong>。其中，$\lambda_i$就是特征$f_i$的权重，越大表示特征越重要。</p>
<h3 id="6-1-2-最大似然估计"><a href="#6-1-2-最大似然估计" class="headerlink" title="6.1.2 最大似然估计"></a>6.1.2 最大似然估计</h3><p>得到对偶问题的内层极小值问题的解之后，接着求解外层的极大值问题$\underset {\lambda} {max} \ \Psi(\lambda)$。</p>
<p>设其解为</p>
<script type="math/tex; mode=display">
\lambda^* = \underset {\lambda} {argmax} \ \Psi(\lambda) \tag{6-8}</script><p>则最大熵模型的解为</p>
<script type="math/tex; mode=display">
p^*=p_{\lambda^*} \tag{6-9}</script><p>根据推导，最大化$\Psi(\lambda)$与最大似然估计是等价的！</p>
<h1 id="7、最优化方法"><a href="#7、最优化方法" class="headerlink" title="7、最优化方法"></a>7、最优化方法</h1><p>通用的方法有梯度下降，拟牛顿法等，最大熵模型有两个量身定做的方法：通用迭代尺度法（Generalized Iterative Scaling，GIS）和改进的迭代尺度法（Impoved Iterative Scaling，IIS）。</p>
<h2 id="7-1-GIS算法"><a href="#7-1-GIS算法" class="headerlink" title="7.1 GIS算法"></a>7.1 GIS算法</h2><blockquote>
<p>算法1：</p>
<p>S1：初始化参数，令$\lambda=0$</p>
<p>S2：计算$E_{\tilde p}(f_i),\ i=1,2,…,n$</p>
<p>S3：执行一次迭代，对参数做一次刷新。</p>
<p>​    计算$E<em>{p</em>{\lambda}}(f_i)$</p>
<p>​    FOR i=1,2,…,n DO {</p>
<p>​        $\lambda<em>i\  += \ \eta \log\frac {E</em>{\tilde p}(f<em>i)} {E</em>{p_{\lambda}}(f_i)}$</p>
<p>​    }</p>
<p>S4：检查是否收敛，若未收敛则继续S3</p>
</blockquote>
<p>其中，$\eta$是学习率，在实际中取$\frac {1} {C}$，$$，表示训练数据中包含特征最多的那个样本所包含的特征个数。</p>
<script type="math/tex; mode=display">
\Delta\lambda_i=\eta \log\frac {E_{\tilde p}(f_i)} {E_{p_{\lambda}}(f_i)}</script><p>是校正量。</p>
<p>每次迭代，先用当前的权重估算每个特征$f<em>i$在训练数据中的概率分布的期望，然后逐个与相应的经验分布的期望比较，其偏差程度通过$\log\frac {E</em>{\tilde p}(f<em>i)} {E</em>{p_{\lambda}}(f_i)}$来进行刻画。</p>
<p>收敛条件就是当两次迭代的$\lambda$在一个较小的范围。</p>
<p>GIS每次迭代时间很长，不太稳定，容易溢出，一般不会使用。</p>
<h2 id="7-2-IIS算法"><a href="#7-2-IIS算法" class="headerlink" title="7.2 IIS算法"></a>7.2 IIS算法</h2><p>与GIS的不同主要在$\Delta\lambda_i$的计算上。IIS通过求解方程</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde p(x)p(y|x)f_i(x,y)\exp(\Delta\lambda_i\sum_{i=1}^nf_i(x,y))=\tilde p(f_i)</script><p>1）若$\sum<em>{i=1}^nf_i(x,y)$为常数，即对任意样本(x,y)，都有$\sum</em>{i=1}^nf_i(x,y)=C$，则</p>
<script type="math/tex; mode=display">
\Delta\lambda_i=\frac {1} {C} \log\frac {E_{\tilde p}(f_i)} {E_{p_{\lambda}}(f_i)}</script><p>此时，IIS可以看做是GIS的一种推广。</p>
<p>2）若$\sum_{i=1}^nf_i(x,y)$不是常数，则需要通过数值方式来求解$\Delta\lambda_i$，如牛顿法。</p>
<h1 id="8、优缺点"><a href="#8、优缺点" class="headerlink" title="8、优缺点"></a>8、优缺点</h1><p>优点是：在建模时，只需要集中精力选取特征，不需要花费精力考虑如何使用这些特征，可以灵活使用不同类型的特征。</p>
<p>缺点是计算量大。</p>
<p>参考</p>
<p>【1】 <a href="http://blog.csdn.net/itplus/article/details/26550273" target="_blank" rel="noopener">最大熵学习笔记</a></p>
<p>【2】统计学习方法</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/hadoop-spark/hive笔记/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/hadoop-spark/hive笔记/" class="post-title-link" itemprop="url">hive笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-19 13:06:22" itemprop="dateModified" datetime="2019-06-19T13:06:22+08:00">2019-06-19</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hadoop-spark/" itemprop="url" rel="index"><span itemprop="name">hadoop-spark</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/hadoop-spark/hive笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/hadoop-spark/hive笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="插入hive表控制part文件数量"><a href="#插入hive表控制part文件数量" class="headerlink" title="插入hive表控制part文件数量"></a>插入hive表控制part文件数量</h1><p><a href="http://blog.sina.com.cn/s/blog_604c7cdd0102wbsw.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_604c7cdd0102wbsw.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- 每个文件上限500M</div><div class="line">set hive.exec.reducers.bytes.per.reducer=512000000;</div><div class="line">insert overwrite table carthage.gps_address_info_weekly_bak PARTITION(DATA_DATE=&apos;2019-01-15&apos;)</div><div class="line">select * from carthage.gps_address_info DISTRIBUTE by RAND();</div><div class="line">-- DISTRIBUTE by RAND()主要靠这个控制reduce的文件数</div></pre></td></tr></table></figure>
<h1 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set hive.mapred.mode=strict</div></pre></td></tr></table></figure>
<p>有助于前置解决一些语法和可能的逻辑错误。</p>
<h1 id="限制小文件数量"><a href="#限制小文件数量" class="headerlink" title="限制小文件数量"></a>限制小文件数量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set mapred.max.split.size=256000000;        -- 决定每个map处理的最大的文件大小，单位为B</div><div class="line">set mapred.min.split.size.per.node=10000000;         -- 节点中可以处理的最小的文件大小</div><div class="line">set mapred.min.split.size.per.rack=10000000;          -- 机架中可以处理的最小的文件大小</div></pre></td></tr></table></figure>
<h1 id="查询时如何去掉重复数据"><a href="#查询时如何去掉重复数据" class="headerlink" title="查询时如何去掉重复数据"></a>查询时如何去掉重复数据</h1><p>假设数据为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name  adx        tran_id                  cost        ts</div><div class="line">ck        5         125.168.10.0           33.00   1407234660</div><div class="line">ck        5         187.18.99.00           33.32   1407234661</div><div class="line">ck        5         125.168.10.0           33.24   1407234661</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from (select *,row_number() over (partition by tran_id order by timestamp asc) num from table) t where t.num=1;</div></pre></td></tr></table></figure>
<blockquote>
<p>附上：<br><strong>ROW_NUMBER() OVER函数的基本用法 </strong></p>
<p>语法：ROW_NUMBER() OVER(PARTITION BY COLUMN ORDER BY COLUMN) </p>
<p>简单的说row_number()从1开始，为每一条分组记录返回一个数字，这里的ROW_NUMBER() OVER (ORDER BY xlh DESC) 是先把xlh列降序，再为降序以后的没条xlh记录返回一个序号。<br>示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; xlh           row_num </div><div class="line">&gt; 1700              1 </div><div class="line">&gt; 1500              2 </div><div class="line">&gt; 1085              3 </div><div class="line">&gt; 710                4 </div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>row_number() OVER (PARTITION BY COL1 ORDER BY COL2) 表示根据COL1分组，在分组内部根据 COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的) </p>
</blockquote>
<h1 id="split后的数组长度"><a href="#split后的数组长度" class="headerlink" title="split后的数组长度"></a>split后的数组长度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size(split(driving_districts,&apos;;&apos;))</div></pre></td></tr></table></figure>
<h1 id="切换队列"><a href="#切换队列" class="headerlink" title="切换队列"></a>切换队列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set mapred.job.queue.name=data;</div></pre></td></tr></table></figure>
<p>sqoop切换队列是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-D mapred.job.queue.name=data</div></pre></td></tr></table></figure>
<h1 id="加载hdfs的udf"><a href="#加载hdfs的udf" class="headerlink" title="加载hdfs的udf"></a>加载hdfs的udf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ADD JAR hdfs://iclick/zyz/udf/zyz_udf2.jar;</div><div class="line">CREATE TEMPORARY FUNCTION get_region as &apos;org.apache.hadoop.hive.ql.udf.Ip2GeoCodeUDF&apos;;</div></pre></td></tr></table></figure>
<h1 id="Hive-Trash"><a href="#Hive-Trash" class="headerlink" title="Hive Trash"></a>Hive Trash</h1><p>hive删除表时，会移除表的元数据和数据，而HDFS上的数据，如果配置了Trash，会移到.Trash/Current目录下。删除外部表时，表中的数据不会被删除。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>用groupby代替distinct，少用orderby</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">同事写了个hive的sql语句，执行效率特别慢，跑了一个多小时程序只是map完了，reduce进行到20%。</div><div class="line">该Hive语句如下：</div><div class="line">select count(distinct ip) </div><div class="line">from (select ip as ip from comprehensive.f_client_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot;  </div><div class="line">union all </div><div class="line">select pub_ip as ip from f_app_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot; </div><div class="line">union all select ip as ip from format_log.format_pv1 where year=&quot;2013&quot; and month=&quot;10&quot; and url_first_id=1 </div><div class="line">) d </div><div class="line"></div><div class="line">       分析：select ip as ip from comprehensive.f_client_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot;这个语句筛选出来的数据约有10亿条，select pub_ip as ip from f_app_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot;约有10亿条条，select ip as ip from format_log.format_pv1 where year=&quot;2013&quot; and month=&quot;10&quot; and url_first_id=1 筛选出来的数据约有10亿条，总的数据量大约30亿条。这么大的数据量，使用disticnt函数，所有的数据只会shuffle到一个reducer上，导致reducer数据倾斜严重。</div><div class="line">       解决办法：</div><div class="line">       首先，通过使用groupby，按照ip进行分组。改写后的sql语句如下：</div><div class="line">select count(*) </div><div class="line">from </div><div class="line">(select ip </div><div class="line">from</div><div class="line">(select ip as ip from comprehensive.f_client_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot; </div><div class="line">union all </div><div class="line">select pub_ip as ip from f_app_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot; </div><div class="line">union all select ip as ip from format_log.format_pv1 where year=&quot;2013&quot; and month=&quot;10&quot; and url_first_id=1</div><div class="line">) d </div><div class="line">group by ip ) b </div><div class="line">       然后，合理的设置reducer数量，将数据分散到多台机器上。set mapred.reduce.tasks=50; </div><div class="line">       经过优化后，速度提高非常明显。整个作业跑完大约只需要20多分钟的时间。</div></pre></td></tr></table></figure>
<p>提高order by的性能<a href="https://blog.csdn.net/djd1234567/article/details/51917603" target="_blank" rel="noopener">https://blog.csdn.net/djd1234567/article/details/51917603</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Hive中的order by跟传统的sql语言中的order by作用是一样的，会对查询的结果做一次全局排序，所以说，只有hive的sql中制定了order by所有的数据都会到同一个reducer进行处理（不管有多少map，也不管文件有多少的block只会启动一个reducer）。但是对于大量数据这 将会消耗很长的时间去执行。</div><div class="line"></div><div class="line">    这里跟传统的sql还有一点区别：如果指定了hive.mapred.mode=strict（默认值是nonstrict）,这时就必须指定limit 来限制输出条数，原因是：所有的数据都会在同一个reducer端进行，数据量大的情况下可能不能出结果，那么在这样的严格模式下，必须指定输出的条数。</div><div class="line"></div><div class="line">    所以数据量大的时候能不用order by就不用，可以使用sort by结合distribute by来进行实现。sort by是局部排序，而distribute by是控制map怎么划分reducer。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    Hive中指定了sort by，那么在每个reducer端都会做排序，也就是说保证了局部有序（每个reducer出来的数据是有序的，但是不能保证所有的数据是有序的，除非只有一个reducer），好处是：执行了局部排序之后可以为接下去的全局排序提高不少的效率（其实就是做一次归并排序就可以做到全局排序了）</div><div class="line"></div><div class="line"></div><div class="line">    ditribute by是控制map的输出在reducer是如何划分的，举个例子，我们有一张表，mid是指这个store所属的商户，money是这个商户的盈利，name是这个store的名字</div><div class="line"></div><div class="line">store:</div><div class="line"></div><div class="line"></div><div class="line">mid	money	name</div><div class="line">AA	15.0	商店1</div><div class="line">AA	20.0	商店2</div><div class="line">BB	22.0	商店3</div><div class="line">CC	44.0	商店4</div><div class="line">    执行hive语句：</div><div class="line"></div><div class="line">[sql] view plain copy</div><div class="line">select mid, money, name from store distribute by mid sort by mid asc, money asc  </div><div class="line">我 们所有的mid相同的数据会被送到同一个reducer去处理，这就是因为指定了distribute by mid，这样的话就可以统计出每个商户中各个商店盈利的排序了（这个肯定是全局有序的，因为相同的商户会放到同一个reducer去处理）。这里需要注意 的是distribute by必须要写在sort by之前。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">cluster by</div><div class="line">    cluster by的功能就是distribute by和sort by相结合，如下2个语句是等价的：</div><div class="line"></div><div class="line">[sql] view plain copy</div><div class="line">select mid, money, name from store cluster by mid  </div><div class="line">select mid, money, name from store distribute by mid sort by mid  </div><div class="line">    如果需要获得与上面的中语句一样的效果：</div><div class="line"></div><div class="line">[sql] view plain copy</div><div class="line">select mid, money, name from store cluster by mid sort by money  </div><div class="line">    注意被cluster by指定的列只能是降序，不能指定asc和desc。</div></pre></td></tr></table></figure>
<h1 id="问题集"><a href="#问题集" class="headerlink" title="问题集"></a>问题集</h1><h2 id="查询ES表报错"><a href="#查询ES表报错" class="headerlink" title="查询ES表报错"></a>查询ES表报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Failed with exception java.io.IOException:org.elasticsearch.hadoop.rest.EsHadoopInvalidRequest: The number of slices [1126] is too large. It must be less than [1024]. This limit can be set by changing the [index.max_slices_per_scroll] index level settin</div></pre></td></tr></table></figure>
<p>修改es的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /megacorp/_settings</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">  &quot;index&quot;: &#123;</div><div class="line"></div><div class="line">    &quot;max_slices_per_scroll&quot; : 1126</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="上传hive-UDF包后重启hive-server报错"><a href="#上传hive-UDF包后重启hive-server报错" class="headerlink" title="上传hive UDF包后重启hive server报错"></a>上传hive UDF包后重启hive server报错</h2><h2 id="hive-udf没有权限执行"><a href="#hive-udf没有权限执行" class="headerlink" title="hive udf没有权限执行"></a>hive udf没有权限执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error while compiling statement: FAILED: SemanticException No valid privileges User dmp does not have privileges for CREATEFUNCTION The required privileges: Server=server1-&gt;URI=file:///home/hive/aux_libs/carthage-common-udf-hive-test.jar-&gt;action=*;</div></pre></td></tr></table></figure>
<h2 id="没有找到jar包的报错"><a href="#没有找到jar包的报错" class="headerlink" title="没有找到jar包的报错"></a>没有找到jar包的报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error while compiling statement: FAILED: SemanticException [Error 10014]: Line 1:7 Wrong arguments &apos;70.0&apos;: org.apache.hadoop.hive.ql.metadata.HiveException: Unable to execute method public java.lang.String com.mljr.carthage.common.geo.udf.hive.UDFGeoLocation.evaluate(java.lang.Double,java.lang.Double) on object com.mljr.carthage.common.geo.udf.hive.UDFGeoLocation@54ee9573 of class com.mljr.carthage.common.geo.udf.hive.UDFGeoLocation with arguments &#123;50.0:java.lang.Double, 70.0:java.lang.Double&#125; of size 2</div></pre></td></tr></table></figure>
<p>其他都是可以的，就这个udf的第二个参数一直报错。经测试，还是UDF本身的问题，跟参数的设置没有关系。</p>
<p>最后发现问题是udf的jar包上传后，关联的一些jar包没有打进去，手动加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;1.6&lt;/version&gt;</div><div class="line">				&lt;executions&gt;</div><div class="line">					&lt;execution&gt;</div><div class="line">						&lt;phase&gt;package&lt;/phase&gt;</div><div class="line">						&lt;goals&gt;</div><div class="line">							&lt;goal&gt;shade&lt;/goal&gt;</div><div class="line">						&lt;/goals&gt;</div><div class="line">						&lt;configuration&gt;</div><div class="line">							&lt;artifactSet&gt;</div><div class="line">								&lt;includes&gt;</div><div class="line">									&lt;include&gt;com.mljr.carthage:carthage-common-geo&lt;/include&gt;</div><div class="line">									&lt;include&gt;com.alibaba:fastjson&lt;/include&gt;</div><div class="line">									&lt;include&gt;com.github.davidmoten:geo&lt;/include&gt;</div><div class="line">									&lt;include&gt;com.github.davidmoten:grumpy-core&lt;/include&gt;</div><div class="line">								&lt;/includes&gt;</div><div class="line">							&lt;/artifactSet&gt;</div><div class="line">						&lt;/configuration&gt;</div><div class="line">					&lt;/execution&gt;</div><div class="line">				&lt;/executions&gt;</div><div class="line">			&lt;/plugin&gt;</div></pre></td></tr></table></figure>
<h1 id="hive用高版本的UDF"><a href="#hive用高版本的UDF" class="headerlink" title="hive用高版本的UDF"></a>hive用高版本的UDF</h1><p>在hive2.0中有类似于months_between的函数，可以实现2个时间之间的月份差。但是低版本没有这个函数</p>
<p>解决：</p>
<p>下载hive-2.1源码包</p>
<p><a href="http://mirrors.hust.edu.cn/apache/hive/hive-2.2.0/" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/apache/hive/hive-2.2.0/</a></p>
<p>导入eclipse，查找months_between</p>
<p>在org.apache.hadoop.hive.ql.udf.generic包下找到GenericUDFMonthsBetween类，移植即可</p>
<p>/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFMonthsBetween.java</p>
<h1 id="String转date"><a href="#String转date" class="headerlink" title="String转date"></a>String转date</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cast(to_date(from_unixtime(unix_timestamp(&apos;12-05-2010&apos;, &apos;dd-MM-yyyy&apos;))) as date)</div></pre></td></tr></table></figure>
<h1 id="MapJoin异常问题处理总结"><a href="#MapJoin异常问题处理总结" class="headerlink" title="MapJoin异常问题处理总结"></a>MapJoin异常问题处理总结</h1><p><a href="https://yq.aliyun.com/articles/64306" target="_blank" rel="noopener">https://yq.aliyun.com/articles/64306</a></p>
<h1 id="替换hive分隔符"><a href="#替换hive分隔符" class="headerlink" title="替换hive分隔符"></a>替换hive分隔符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;.bak&apos; &apos;s/^A/,/g&apos; baseinfo05.csv</div></pre></td></tr></table></figure>
<p><code>^A</code>要用ctrl+V+A打出来</p>
<h1 id="LOAD-DATA"><a href="#LOAD-DATA" class="headerlink" title="LOAD DATA"></a>LOAD DATA</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOAD DATA [LOCAL] INPATH &apos;filepath&apos; [OVERWRITE] INTO TABLE tablename[PARTITION (partcol1=val1,partcol2=val2,…)]</div></pre></td></tr></table></figure>
<p>最好不要用LOCAL，要从hadoop加载数据。local读的是hive服务器的本地路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">from pyhive import hive</div><div class="line">from TCLIService.ttypes import TOperationState</div><div class="line"></div><div class="line"># 打开hive连接</div><div class="line">hiveConn = hive.connect(host=&apos;192.168.83.135&apos;,port=11111,username=&apos;hadoop&apos;)</div><div class="line">cursor = hiveConn.cursor()</div><div class="line"></div><div class="line"># 执行sql语句</div><div class="line">sql = &apos;&apos;&apos; LOAD DATA LOCAL INPATH &apos;/home/hadoop/HivePy/employee.txt&apos; OVERWRITE INTO TABLE userdbbypy.employee &apos;&apos;&apos;</div><div class="line">cursor.execute(sql, async=True)</div><div class="line"></div><div class="line"># 得到执行语句的状态</div><div class="line">status = cursor.poll().operationState</div><div class="line">print &quot;status:&quot;,status</div><div class="line"></div><div class="line"># 关闭hive连接</div><div class="line">cursor.close()</div><div class="line">hiveConn.close()</div></pre></td></tr></table></figure>
<h1 id="return-code-3"><a href="#return-code-3" class="headerlink" title="return code 3"></a>return code 3</h1><p>试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set hive.vectorized.execution.enabled=false;</div></pre></td></tr></table></figure>
<h1 id="hive锁表"><a href="#hive锁表" class="headerlink" title="hive锁表"></a>hive锁表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Completed compiling command</div></pre></td></tr></table></figure>
<p>若卡在上面的语句，说明锁表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">show locks carthage_dev.baseinfo_personal_info;</div><div class="line">-- 如果是</div><div class="line"></div><div class="line">unlock table dwh_dml_risk_dev.rec_car_operation;</div><div class="line">show locks carthage_dev.baseinfo_personal_info partition(data_date=&apos;20180517&apos;);</div><div class="line">unlock table dwh_dml_risk_dev.rec_car_operation partition(data_date=&apos;2018-09-30&apos;);</div></pre></td></tr></table></figure>
<p>hive解锁的脚本是<code>all_hive_unlock.sh</code></p>
<h1 id="hive新增列报错"><a href="#hive新增列报错" class="headerlink" title="hive新增列报错"></a>hive新增列报错</h1><p>在添加字段是可以通过CASCADE关键字来，避免出现这种问题。如alter table table_name add columns(age int) CASCADE</p>
<p><a href="https://qubole.zendesk.com/hc/en-us/articles/115002396646-Hive-Null-Pointer-Exception-in-select-query-after-modifying-table-definition" target="_blank" rel="noopener">https://qubole.zendesk.com/hc/en-us/articles/115002396646-Hive-Null-Pointer-Exception-in-select-query-after-modifying-table-definition</a></p>
<blockquote>
<p>This can happen in the scenario where table definition and specific partition definition is different, and the underlying data matches table definition but not partition definition.</p>
<p>When a table with partitions is altered to add a column using statement:</p>
<p><em>ALTER TABLE <tablename> ADD COLUMNS (c1 int);</tablename></em></p>
<p>The table definition for existing partitions don’t get modified as per the above statement. As a result of this there is a mismatch between partition and table definition. </p>
<p>This is ok if the partition data matches the definition of partition, but if the data matches definition of table itself, NPE is thrown as there is a mismatch in data vs definition.</p>
<p>To avoid this issue, this statement should be used in hadoop2</p>
<p><em>ALTER TABLE <tablename> ADD COLUMNS (c1 int) CASCADE;</tablename></em> </p>
<p>In case of hadoop1, CASCADE option is not available. Hence, as long as the table is external table, following can be done:</p>
<ol>
<li>Drop and recreate partitions for this table</li>
<li>Alter partition definition for specific partition having issues</li>
</ol>
</blockquote>
<p>用了cascade 无效。</p>
<p>找到原因：</p>
<p>hive表是ORC格式的，因此cascade无效，若改成text格式则成功。</p>
<p>解决方案：</p>
<p>若必须是ORC格式，建表是先预留若干字段，后期改名字</p>
<h1 id="hive分区解锁"><a href="#hive分区解锁" class="headerlink" title="hive分区解锁"></a>hive分区解锁</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show locks carthage_dev.baseinfo_personal_info;</div><div class="line">unlock table carthage_dev.baseinfo_personal_info;</div><div class="line">show locks carthage_dev.baseinfo_personal_info partition(data_date=&apos;20180517&apos;);</div><div class="line">unlock table carthage_dev.baseinfo_personal_info partition(data_date=&apos;20180517&apos;);</div></pre></td></tr></table></figure>
<p>解锁的技巧：</p>
<p>1、定位哪张表锁住，可以分批执行sql，定位关键表</p>
<p>2、show locks并下载，观察锁表的状态，通过</p>
<p><code>show locks table extends</code>可以看依赖的表</p>
<p>3、用脚本all_hive_unlock.sh解锁</p>
<h2 id="hive-column-rename"><a href="#hive-column-rename" class="headerlink" title="hive column rename"></a>hive column rename</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table carthage_dev.gps_wx_stop_status CHANGE stop_region_center_lon stop_status_center_lon string</div></pre></td></tr></table></figure>
<h1 id="hive配置"><a href="#hive配置" class="headerlink" title="hive配置"></a>hive配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- 输出为gzip</div><div class="line">set hive.exec.compress.output=true;    </div><div class="line">set mapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec;</div><div class="line">-- 输出为一个文件</div><div class="line">set mapred.reduce.tasks=1;</div></pre></td></tr></table></figure>
<h1 id="hive-timestamp转时间"><a href="#hive-timestamp转时间" class="headerlink" title="hive timestamp转时间"></a>hive timestamp转时间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from_unixtime(unix_timestamp(),‘yyyy/MM/dd HH:mm:ss’);</div><div class="line"></div><div class="line">from_unixtime(cast(cast(time as bigint)/1000 as bigint),&apos;yyyy/MM/dd HH:mm:ss&apos;)</div></pre></td></tr></table></figure>
<h1 id="常用日期函数"><a href="#常用日期函数" class="headerlink" title="常用日期函数"></a>常用日期函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">to_date：日期时间转日期函数    </div><div class="line">	select to_date(&apos;2018-04-02 13:34:12&apos;);   输出：2018-04-02   </div><div class="line">from_unixtime：转化unix时间戳到当前时区的时间格式    </div><div class="line">	select from_unixtime(1524573762,&apos;yyyy-MM-dd HH:mm:ss&apos;);    输出：2018-04-24 20:42:42</div><div class="line">unix_timestamp：获取当前unix时间戳    </div><div class="line">	select unix_timestamp();    输出：1524573762  </div><div class="line">	select unix_timestamp(&apos;2018-04-01 13:01:20&apos;);  输出：1522558880</div><div class="line">datediff：返回开始日期减去结束日期的天数    </div><div class="line">	select datediff(&apos;2018-04-09&apos;,&apos;2018-04-01&apos;);    输出：8    </div><div class="line">date_sub：返回日期前n天的日期    </div><div class="line">	select date_sub(&apos;2018-04-09&apos;,4);    输出：2018-04-05    </div><div class="line">date_add：返回日期后n天的日期    </div><div class="line">	select date_add(&apos;2018-04-09&apos;,4);    输出：2018-04-13  </div><div class="line">add_months：月份增加函数</div><div class="line">	select add_months(&apos;2018-02-10&apos;, 2 );    输出：2018-04-10 </div><div class="line">last_day：返回当月底日期</div><div class="line">	select last_day(&apos;2018-02-21&apos;);    输出：2018-02-28</div></pre></td></tr></table></figure>
<h1 id="hive-字符串函数"><a href="#hive-字符串函数" class="headerlink" title="hive 字符串函数"></a>hive 字符串函数</h1><p><strong>1. 字符串长度函数：length</strong></p>
<p>语法: length(string A)</p>
<p>返回值: int</p>
<p>说明：返回字符串A的长度</p>
<p>举例：</p>
<p>hive&gt; select length(‘abcedfg’) from lxw_dual;</p>
<p>7</p>
<p><strong>2. 字符串反转函数：reverse</strong></p>
<p>语法: reverse(string A)</p>
<p>返回值: string</p>
<p>说明：返回字符串A的反转结果</p>
<p>举例：</p>
<p>hive&gt; select reverse(abcedfg’) from lxw_dual;</p>
<p>gfdecba</p>
<p><strong>3. 字符串连接函数：concat</strong></p>
<p>语法: concat(string A, string B…)</p>
<p>返回值: string</p>
<p>说明：返回输入字符串连接后的结果，支持任意个输入字符串</p>
<p>举例：</p>
<p>hive&gt; select concat(‘abc’,’def’,’gh’) from lxw_dual;</p>
<p>abcdefgh</p>
<p><strong>4. 带分隔符字符串连接函数：concat_ws</strong></p>
<p>语法: concat_ws(string SEP, string A, string B…)</p>
<p>返回值: string</p>
<p>说明：返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符</p>
<p>举例：</p>
<p>hive&gt; select concat_ws(‘,’,’abc’,’def’,’gh’) from lxw_dual;</p>
<p>abc,def,gh</p>
<p><strong>5. 字符串截取函数：substr,substring</strong></p>
<p>语法: substr(string A, int start),substring(string A, int start)</p>
<p>返回值: string</p>
<p>说明：返回字符串A从start位置到结尾的字符串</p>
<p>举例：</p>
<p>hive&gt; select substr(‘abcde’,3) from lxw_dual;</p>
<p>cde</p>
<p>hive&gt; select substring(‘abcde’,3) from lxw_dual;</p>
<p>cde</p>
<p>hive&gt;  selectsubstr(‘abcde’,-1) from lxw_dual;  （和ORACLE相同）</p>
<p>e</p>
<p><strong>6. 字符串截取函数：substr,substring</strong></p>
<p>语法: substr(string A, int start, int len),substring(string A, intstart, int len)</p>
<p>返回值: string</p>
<p>说明：返回字符串A从start位置开始，长度为len的字符串</p>
<p>举例：</p>
<p>hive&gt; select substr(‘abcde’,3,2) from lxw_dual;</p>
<p>cd</p>
<p>hive&gt; select substring(‘abcde’,3,2) from lxw_dual;</p>
<p>cd</p>
<p>hive&gt;select substring(‘abcde’,-2,2) from lxw_dual;</p>
<p>de</p>
<p><strong>7. 字符串转大写函数：upper,ucase</strong></p>
<p>语法: upper(string A) ucase(string A)</p>
<p>返回值: string</p>
<p>说明：返回字符串A的大写格式</p>
<p>举例：</p>
<p>hive&gt; select upper(‘abSEd’) from lxw_dual;</p>
<p>ABSED</p>
<p>hive&gt; select ucase(‘abSEd’) from lxw_dual;</p>
<p>ABSED</p>
<p><strong>8. 字符串转小写函数：lower,lcase</strong></p>
<p>语法: lower(string A) lcase(string A)</p>
<p>返回值: string</p>
<p>说明：返回字符串A的小写格式</p>
<p>举例：</p>
<p>hive&gt; select lower(‘abSEd’) from lxw_dual;</p>
<p>absed</p>
<p>hive&gt; select lcase(‘abSEd’) from lxw_dual;</p>
<p>absed</p>
<p><strong>9. 去空格函数：trim</strong></p>
<p>语法: trim(string A)</p>
<p>返回值: string</p>
<p>说明：去除字符串两边的空格</p>
<p>举例：</p>
<p>hive&gt; select trim(‘ abc ‘) from lxw_dual;</p>
<p>abc</p>
<p><strong>10. 左边去空格函数：ltrim</strong></p>
<p>语法: ltrim(string A)</p>
<p>返回值: string</p>
<p>说明：去除字符串左边的空格</p>
<p>举例：</p>
<p>hive&gt; select ltrim(‘ abc ‘) from lxw_dual;</p>
<p>abc</p>
<p><strong>11. 右边去空格函数：rtrim</strong></p>
<p>语法: rtrim(string A)</p>
<p>返回值: string</p>
<p>说明：去除字符串右边的空格</p>
<p>举例：</p>
<p>hive&gt; select rtrim(‘ abc ‘) from lxw_dual;</p>
<p>abc</p>
<p><strong>12. 正则表达式替换函数：regexp_replace</strong></p>
<p>语法: regexp_replace(string A, string B, string C)</p>
<p>返回值: string</p>
<p>说明：将字符串A中的符合java正则表达式B的部分替换为C。注意，在有些情况下要使用转义字符,类似oracle中的regexp_replace函数。</p>
<p>举例：</p>
<p>hive&gt; select regexp_replace(‘foobar’, ‘oo|ar’, ‘’) from lxw_dual;</p>
<p>fb</p>
<p><strong>13. 正则表达式解析函数：regexp_extract</strong></p>
<p>语法: regexp_extract(string subject, string pattern, int index)</p>
<p>返回值: string</p>
<p>说明：将字符串subject按照pattern正则表达式的规则拆分，返回index指定的字符。</p>
<p>举例：</p>
<p>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 1) fromlxw_dual;</p>
<p>the</p>
<p>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2) fromlxw_dual;</p>
<p>bar</p>
<p>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 0) fromlxw_dual;</p>
<p>foothebar</p>
<p><strong>注意，在有些情况下要使用转义字符，下面的等号要用双竖线转义，这是java**</strong>正则表达式的规则。**</p>
<p>select data_field,</p>
<p>​     regexp_extract(data_field,’.*?bgStart\=(<sup><a href="#fn_&" id="reffn_&">&</a></sup>+)’,1) as aaa,</p>
<p>​     regexp_extract(data_field,’.*?contentLoaded_headStart\=(<sup><a href="#fn_&" id="reffn_&">&</a></sup>+)’,1) as bbb,</p>
<p>​     regexp_extract(data_field,’.*?AppLoad2Req\=(<sup><a href="#fn_&" id="reffn_&">&</a></sup>+)’,1) as ccc</p>
<p>​     from pt_nginx_loginlog_st</p>
<p>​     where pt = ‘2012-03-26’limit 2;</p>
<p><strong>14. URL解析函数：parse_url</strong></p>
<p>语法: parse_url(string urlString, string partToExtract [, stringkeyToExtract])</p>
<p>返回值: string</p>
<p>说明：返回URL中指定的部分。partToExtract的有效值为：HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.</p>
<p>举例：</p>
<p>hive&gt; selectparse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1" target="_blank" rel="noopener">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1</a>‘, ‘HOST’) fromlxw_dual;</p>
<p>facebook.com</p>
<p>hive&gt; selectparse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1" target="_blank" rel="noopener">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1</a>‘, ‘QUERY’,’k1’) from lxw_dual;</p>
<p>v1</p>
<p><strong>15. json解析函数：get_json_object</strong></p>
<p>语法: get_json_object(string json_string, string path)</p>
<p>返回值: string</p>
<p>说明：解析json的字符串json_string,返回path指定的内容。如果输入的json字符串无效，那么返回NULL。</p>
<p>举例：</p>
<p>hive&gt; select get_json_object(‘{“store”:</p>
<p>>  {“fruit”:[{“weight”:8,”type”:”apple”},{“weight”:9,”type”:”pear”}],</p>
<p>>   “bicycle”:{“price”:19.95,”color”:”red”}</p>
<p>>   },</p>
<p>> “email”:”amy@only_for_json_udf_test.net”,</p>
<p>>  “owner”:”amy”</p>
<p>> }</p>
<p>> ‘,’$.owner’) from lxw_dual;</p>
<p>amy</p>
<p><strong>16. 空格字符串函数：space</strong></p>
<p>语法: space(int n)</p>
<p>返回值: string</p>
<p>说明：返回长度为n的字符串</p>
<p>举例：</p>
<p>hive&gt; select space(10) from lxw_dual;</p>
<p>hive&gt; select length(space(10)) from lxw_dual;</p>
<p>10</p>
<p><strong>17. 重复字符串函数：repeat</strong></p>
<p>语法: repeat(string str, int n)</p>
<p>返回值: string</p>
<p>说明：返回重复n次后的str字符串</p>
<p>举例：</p>
<p>hive&gt; select repeat(‘abc’,5) from lxw_dual;</p>
<p>abcabcabcabcabc</p>
<p><strong>18. 首字符ascii函数：ascii</strong></p>
<p>语法: ascii(string str)</p>
<p>返回值: int</p>
<p>说明：返回字符串str第一个字符的ascii码</p>
<p>举例：</p>
<p>hive&gt; select ascii(‘abcde’) from lxw_dual;</p>
<p>97</p>
<p><strong>19. 左补足函数：lpad</strong></p>
<p>语法: lpad(string str, int len, string pad)</p>
<p>返回值: string</p>
<p>说明：将str进行用pad进行左补足到len位</p>
<p>举例：</p>
<p>hive&gt; select lpad(‘abc’,10,’td’) from lxw_dual;</p>
<p>tdtdtdtabc</p>
<p><strong>注意：与GP**</strong>，ORACLE<strong>**不同，pad</strong> <strong>不能默认</strong></p>
<p><strong>20. 右补足函数：rpad</strong></p>
<p>语法: rpad(string str, int len, string pad)</p>
<p>返回值: string</p>
<p>说明：将str进行用pad进行右补足到len位</p>
<p>举例：</p>
<p>hive&gt; select rpad(‘abc’,10,’td’) from lxw_dual;</p>
<p>abctdtdtdt</p>
<p><strong>21. 分割字符串函数: split</strong></p>
<p>语法:  split(string str, stringpat)</p>
<p>返回值:  array</p>
<p>说明: 按照pat字符串分割str，会返回分割后的字符串数组</p>
<p>举例：</p>
<p>hive&gt; select split(‘abtcdtef’,’t’) from lxw_dual;</p>
<p>[“ab”,”cd”,”ef”]</p>
<p><strong>22. 集合查找函数:find_in_set</strong></p>
<p>语法: find_in_set(string str, string strList)</p>
<p>返回值: int</p>
<p>说明: 返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。如果没有找该str字符，则返回0</p>
<p>举例：</p>
<p>hive&gt; select find_in_set(‘ab’,’ef,ab,de’) from lxw_dual;</p>
<p>2</p>
<p>hive&gt; select find_in_set(‘at’,’ef,ab,de’) from lxw_dual;</p>
<p>0</p>
<p>instr</p>
<h1 id="group后拼接"><a href="#group后拼接" class="headerlink" title="group后拼接"></a>group后拼接</h1><p>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select userid,bankid,group_concat(cast(creditlimit as string))</div><div class="line">from vdm_fin.cc_user_bill_0724</div><div class="line">group by userid,bankid</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/hadoop-spark/hive笔记/pic/70.png" alt="è¿éåå¾çæè¿°"></p>
<p><strong>hive实现相同的功能：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT id,</div><div class="line">concat_ws(&apos;|&apos;, collect_set(str)) </div><div class="line">FROM t  </div><div class="line">GROUP BY id;1234</div></pre></td></tr></table></figure>
<p>主意:collect_set 只能返回不重复的集合<br>若要返回带重复的要用collect_list</p>
<p>2、collect_list 展示子表排序后结果，collect_set 不受子表排序影响<br>select phone,collect_list(user_id) ,collect_set(user_id) from<br>(select * from a order by order_time asc)b<br>group by phone<br>结果：123456789    [1,1,3,2,2]    [1,3,2]</p>
<p>a表数据如下<br>phone    user_id order_time<br>123456789    1    2018/8/23<br>123456789    3    2018/8/24<br>123456789    2    2018/8/25<br>123456789    1    2018/8/22<br>123456789    2    2018/8/26</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/NLP/网页关键词提取/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/NLP/网页关键词提取/" class="post-title-link" itemprop="url">网页关键词提取</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-31 10:28:31" itemprop="dateModified" datetime="2018-03-31T10:28:31+08:00">2018-03-31</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/NLP/网页关键词提取/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/NLP/网页关键词提取/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>代码位于<code>nlp</code> 项目</p>
<h1 id="jsoup解析html的DOM"><a href="#jsoup解析html的DOM" class="headerlink" title="jsoup解析html的DOM"></a>jsoup解析html的DOM</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Document doc =Jsoup.connect(url).userAgent(&quot;Mozilla&quot;).get();</div></pre></td></tr></table></figure>
<h1 id="提取网页"><a href="#提取网页" class="headerlink" title="提取网页"></a>提取网页</h1><p><code>getPageDetail</code>获取网页提取的结果，返回<code>WebPageInfo</code>类，该类包括</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String domain;</div><div class="line"><span class="keyword">public</span> String url;</div><div class="line"><span class="keyword">public</span> String rawTitle;</div><div class="line"><span class="keyword">public</span> String title;</div><div class="line"><span class="keyword">public</span> String content;</div><div class="line"><span class="keyword">public</span> String summary;</div><div class="line"><span class="keyword">public</span> HashMap&lt;String, String&gt; meta;</div><div class="line"><span class="keyword">public</span> HashMap&lt;String, List&lt;String&gt;&gt; calculation;</div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> freq = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> String createTime;</div></pre></td></tr></table></figure>
<p><code>meta_desc</code>，来自网页meta的<code>description</code>元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta.put(&quot;description&quot;, meta_desc);</div></pre></td></tr></table></figure>
<p><code>meta_keywords</code>，来自网页meta的<code>keywords</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta.put(&quot;keywords&quot;, meta_keywords);</div></pre></td></tr></table></figure>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><code>rawTitle=doc.title()</code></p>
<p><code>title</code>，通过<code>ExtractUtil.extractTitle(doc.body(), rawTitle)</code>进一步抽取。目的是去掉标题中的无关信息，如网站信息等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractTitle</span></span>(root: <span class="type">Element</span>, rawTitle:<span class="type">String</span>): <span class="type">String</span> = &#123;</div><div class="line">    <span class="keyword">if</span>(<span class="type">StringUtils</span>.isBlank(rawTitle)) </div><div class="line">      <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">val</span> titleCnt = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>] <span class="keyword">with</span> <span class="type">HashMapUtil</span>.<span class="type">IntHashMap</span>[<span class="type">String</span>]</div><div class="line">    titleCnt.adjustOrPut(te.extract(rawTitle).trim, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">    titleCnt.adjustOrPut(te.extractFirst(rawTitle).trim, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">val</span> tq = <span class="keyword">new</span> <span class="type">PriorityQueue</span>[<span class="type">String</span>](<span class="number">2</span>)</div><div class="line">    extractTitle0(root, rawTitle, <span class="number">1</span>, tq)</div><div class="line">    <span class="keyword">for</span> (candidate &lt;- tq.values) titleCnt.adjustOrPut(candidate.trim, <span class="number">1</span>, <span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> maxCnt = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> title = rawTitle</div><div class="line">    titleCnt.foreach &#123; <span class="keyword">case</span> (candidate, cnt) =&gt;</div><div class="line">      <span class="keyword">if</span> (maxCnt &lt; cnt) &#123;</div><div class="line">        maxCnt = cnt</div><div class="line">        title = candidate</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (maxCnt == cnt &amp;&amp; candidate.length &gt; title.length) title = candidate</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    title</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>te.extract</code>，</p>
<p>首先要<code>split</code>。通过判断unicode字符的类别（<a href="http://blog.csdn.net/weixin_36082485/article/details/53154065" target="_blank" rel="noopener">Unicode字符类</a>）来分割标题 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; title.length(); i++) &#123;</div><div class="line">			<span class="keyword">char</span> ch = title.charAt(i);</div><div class="line">			<span class="keyword">int</span> type = Character.getType(ch);</div><div class="line">  			<span class="comment">// 标点，前引号</span></div><div class="line">			<span class="keyword">if</span> (type == Character.INITIAL_QUOTE_PUNCTUATION) quoteCnt++;</div><div class="line">  			<span class="comment">// 标点，开始</span></div><div class="line">			<span class="keyword">if</span> (type == Character.START_PUNCTUATION) quoteCnt++;</div><div class="line">			<span class="keyword">if</span> (quoteCnt == <span class="number">0</span> &amp;&amp; !lastLetter &amp;&amp; !lastDigit &amp;&amp; splitChars.contains(ch)) &#123;</div><div class="line">				parts.add(title.substring(last, i));</div><div class="line">				last = i + <span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">  			<span class="comment">// 标点，后引号</span></div><div class="line">			<span class="keyword">if</span> (type == Character.FINAL_QUOTE_PUNCTUATION) quoteCnt--;</div><div class="line">  			<span class="comment">// 标点，结束</span></div><div class="line">			<span class="keyword">if</span> (type == Character.END_PUNCTUATION) quoteCnt--;</div><div class="line">			<span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span> || ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) lastLetter = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">else</span> lastLetter = <span class="keyword">false</span>;</div><div class="line">			<span class="keyword">if</span> (Character.isDigit(ch)) lastDigit = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!splitChars.contains(ch)) lastDigit = <span class="keyword">false</span>;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p>然后提取最长的part。提取的原则是，</p>
<p>1、如果出现不重要的字符前缀后缀<code>ignoreSuffixes</code>、<code>ignorePrefixes</code>，降低part的长度</p>
<p>2、第一个part的长度翻倍，可能是考虑到真的标题往往出现在第一块，如</p>
<p><code>清润饮食“熄灭”冬季之火 - 素食 - 大渡网-佛教资讯，生活，人文，心灵感悟，佛艺时尚杂志，佛教音乐，佛教常识，佛教视频</code></p>
<p><code>从草根到精英——大陆网络民族主义流变-观点评论-时事评论-四月网-青年思想门户-M4.CN</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ignoreSuffixes = Arrays.asList(<span class="string">"频道"</span>, <span class="string">"站"</span>, <span class="string">"网"</span>, <span class="string">"报"</span>, <span class="string">"集"</span>, <span class="string">"公司"</span>, <span class="string">".com"</span>, <span class="string">".cn"</span>, <span class="string">"平台"</span>, <span class="string">"门户"</span>, <span class="string">"博客"</span>, <span class="string">"精选"</span>, <span class="string">"博客精选"</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ignorePrefixes = Arrays.asList(<span class="string">"Powered by"</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;Character&gt; splitChars = <span class="keyword">new</span> HashSet&lt;Character&gt;(Arrays.asList(<span class="string">'|'</span>, <span class="string">'_'</span>, <span class="string">'-'</span>, <span class="string">'—'</span>, <span class="string">'－'</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;'</span>, <span class="string">'«'</span>, <span class="string">'»'</span>));</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLongestPart</span><span class="params">(List&lt;String&gt; parts)</span> </span>&#123;</div><div class="line">		<span class="keyword">double</span> longestNumWords = <span class="number">0</span>;</div><div class="line">		String longestPart = <span class="string">""</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parts.size(); i++) &#123;</div><div class="line">			String p = parts.get(i).trim();</div><div class="line">			</div><div class="line">			<span class="keyword">int</span> ignoreCount = <span class="number">0</span>;</div><div class="line">			<span class="keyword">for</span> (String is: ignoreSuffixes) <span class="keyword">if</span> (p.toLowerCase().endsWith(is)) ignoreCount++;</div><div class="line">			<span class="keyword">for</span> (String ip: ignorePrefixes) <span class="keyword">if</span> (p.toLowerCase().startsWith(ip)) ignoreCount++;</div><div class="line">			<span class="keyword">int</span> colonCnt = StringUtils.countMatches(p, <span class="string">","</span>);</div><div class="line">			<span class="keyword">if</span> (colonCnt &gt; <span class="number">0</span>) ignoreCount += colonCnt - <span class="number">1</span>;</div><div class="line">			colonCnt = StringUtils.countMatches(p, <span class="string">"，"</span>);</div><div class="line">			<span class="keyword">if</span> (colonCnt &gt; <span class="number">0</span>) ignoreCount += colonCnt - <span class="number">1</span>;</div><div class="line">			<span class="keyword">double</span> numWords = TextUtil.countNumWords(p);</div><div class="line">			numWords = numWords / (<span class="number">1</span> + <span class="number">2</span> * ignoreCount);</div><div class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) numWords = numWords * <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span> (numWords &gt; longestNumWords) &#123;</div><div class="line">            	longestNumWords = numWords;</div><div class="line">            	longestPart = p;</div><div class="line">            &#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (longestPart.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">return</span> longestPart.trim();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><code>extractTitle0(root, rawTitle, 1, tq)</code> </p>
<p>传入root和刚才提取的rawTitle，递归遍历root的各个head元素，<code>h</code>，<code>title</code>，每种赋值不同权重。再寻找与rawTitle的最长公共子串。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTitle0</span></span>(node: <span class="type">Node</span>, title: <span class="type">String</span>, weight: <span class="type">Double</span>, tq: <span class="type">PriorityQueue</span>[<span class="type">String</span>], depth: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    node <span class="keyword">match</span> &#123;</div><div class="line">      <span class="keyword">case</span> textNode: <span class="type">TextNode</span> =&gt; &#123;</div><div class="line">        <span class="keyword">val</span> text = textNode.text.trim</div><div class="line">        <span class="keyword">if</span> (text.length &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">val</span> lcs = <span class="type">TextUtil</span>.findLcs(title, text)</div><div class="line">          <span class="keyword">val</span> nwords = <span class="type">TextUtil</span>.countNumWords(lcs)</div><div class="line">          <span class="keyword">val</span> pos = title.indexOf(lcs)</div><div class="line">          <span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; nwords &gt; <span class="number">0</span>) &#123;</div><div class="line">            tq.add(nwords * weight / (<span class="number">1</span> + math.log(<span class="number">2</span> + pos)), lcs)</div><div class="line">          &#125;</div><div class="line">        &#125; </div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> e: <span class="type">Element</span> =&gt; &#123;</div><div class="line">        <span class="keyword">var</span> w = weight</div><div class="line">        <span class="keyword">if</span> (e.tagName.startsWith(<span class="string">"h"</span>)) w = w * <span class="number">1.2</span></div><div class="line">        <span class="keyword">if</span> (e.tagName == <span class="string">"a"</span>) w = w / <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> (e.className.contains(<span class="string">"title"</span>)) w = w * <span class="number">1.5</span></div><div class="line">        <span class="keyword">if</span> (e.tagName != <span class="string">"title"</span> &amp;&amp; !isNegativeBlock(e.className + <span class="string">" "</span> + e.id) &amp;&amp; depth &lt; <span class="type">Extract_STOP_DEPTH</span>) &#123;</div><div class="line">          <span class="keyword">for</span> (n &lt;- e.childNodes.asScala) extractTitle0(n, title, w, tq, depth + <span class="number">1</span>)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">case</span> _ =&gt; &#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过以上方法提取出各种title后，选出出现频率最高的作为最终的title。</p>
<h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractContent</span></span>(url: <span class="type">String</span>, doc: <span class="type">Document</span>): <span class="type">List</span>[<span class="type">String</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> rawTitle = doc.title</div><div class="line">    <span class="keyword">if</span>(doc.body == <span class="literal">null</span>)</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">    <span class="type">ExtractUtil</span>.cleanup(doc.body)</div><div class="line">    <span class="keyword">val</span> title = <span class="type">ExtractUtil</span>.extractTitle(doc.body, rawTitle)</div><div class="line">    <span class="keyword">val</span> metaKeywords = <span class="type">ExtractUtil</span>.extractMeta(doc, <span class="string">"keywords"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> blocks = <span class="type">ExtractUtil</span>.extractBlocks(doc, title) map &#123; block =&gt;</div><div class="line">      <span class="type">SnippetBlock</span>(block.snippets map &#123; snippet =&gt; <span class="type">TextProcess</span>.normalize(urlReg.matcher(snippet).replaceAll(<span class="string">""</span>)) &#125;, block.score, block.isArticle, block.imgs)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> normalTitle = <span class="type">TextUtil</span>.fillText(title)</div><div class="line">    <span class="keyword">val</span> normalRawTitle = <span class="type">TextUtil</span>.fillText(doc.title)</div><div class="line"></div><div class="line">    <span class="keyword">val</span> allsnippets = blocks.filter(_.isArticle).flatMap &#123; b =&gt; b.snippets &#125;</div><div class="line">    <span class="keyword">return</span> allsnippets;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="清洗doc"><a href="#清洗doc" class="headerlink" title="清洗doc"></a>清洗doc</h3><p><code>ExtractUtil.cleanup(doc.body)</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cleanup</span></span>(root: <span class="type">Element</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> cleanNodes = <span class="keyword">for</span> &#123;</div><div class="line">      e &lt;- root.getAllElements.asScala</div><div class="line">      <span class="keyword">if</span> <span class="type">INVALID_TAGS</span>.contains(e.tagName) || e.attr(<span class="string">"style"</span>).contains(<span class="string">"display:none"</span>)</div><div class="line">    &#125; <span class="keyword">yield</span> e</div><div class="line">    <span class="keyword">for</span> (cn &lt;- cleanNodes) cn.remove</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="提取title、metakeywords"><a href="#提取title、metakeywords" class="headerlink" title="提取title、metakeywords"></a>提取title、metakeywords</h3><h3 id="提取blocks"><a href="#提取blocks" class="headerlink" title="提取blocks"></a>提取blocks</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractBlocks</span></span>(doc: <span class="type">Document</span>, title: <span class="type">String</span>): <span class="type">List</span>[<span class="type">SnippetBlock</span>] = &#123;</div><div class="line">    <span class="keyword">val</span> blocks = <span class="keyword">new</span> <span class="type">ListBuffer</span>[<span class="type">BlockDetail</span>]</div><div class="line">    <span class="keyword">val</span> bd = <span class="keyword">new</span> <span class="type">BlockDetailBuffer</span></div><div class="line">    extractBlocks(doc.body, blocks, bd)</div><div class="line">    <span class="keyword">if</span> (bd.isDefined) blocks += bd.result</div><div class="line">    calcScore(title, blocks.result filterNot(b =&gt; hasICP(b))) ++ <span class="type">List</span>(<span class="type">SnippetBlock</span>(<span class="type">List</span>(extractMeta(doc, <span class="string">"keywords"</span>)), <span class="number">1</span>d, <span class="literal">true</span>, <span class="type">List</span>()), <span class="type">SnippetBlock</span>(<span class="type">List</span>(extractMeta(doc, <span class="string">"description"</span>)), <span class="number">0</span>d, <span class="literal">false</span>, <span class="type">List</span>()))</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">extractBlocks</span></span>(root: <span class="type">Node</span>, blocks: <span class="type">ListBuffer</span>[<span class="type">BlockDetail</span>], bd: <span class="type">BlockDetailBuffer</span>, inLink: <span class="type">Boolean</span> = <span class="literal">false</span>, depth: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  root <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> tn: <span class="type">TextNode</span> =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> text = <span class="type">StringUtils</span>.replace(tn.text, <span class="string">"\u00a0"</span>, <span class="string">" "</span>).trim</div><div class="line">      <span class="keyword">if</span> (text.length &gt; <span class="number">0</span>) bd.add(text, inLink)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> e: <span class="type">Element</span> =&gt; &#123;</div><div class="line">      <span class="keyword">val</span> isLink = inLink || (e.tagName == <span class="string">"a"</span>) </div><div class="line">      <span class="keyword">if</span>(depth &lt; <span class="type">Extract_STOP_DEPTH</span>)&#123;</div><div class="line">      	e.childNodes.asScala foreach &#123; c =&gt; extractBlocks(c, blocks, bd, isLink, depth + <span class="number">1</span>) &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">if</span> (e.tagName == <span class="string">"img"</span> || e.tagName == <span class="string">"embed"</span>) &#123;</div><div class="line">        bd.addImg(e)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (e.isBlock) &#123;</div><div class="line">        <span class="keyword">if</span> (bd.isDefined) blocks += bd.result</div><div class="line">        bd.clear</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> _ =&gt; &#123;&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>提取每个TextNode的文本，放到<code>BlockDetailBuffer</code>中。将每个<code>BlockDetailBuffer</code>的内容放到<code>BlockDetail</code>的list <code>blocks</code>中。</p>
<p>过滤掉包含<code>icp备</code>或<code>icp证</code>的文本，再对所有的blocks计算打分<code>calcScore</code></p>
<p>最后提取所有是文本的snippet，作为content</p>
<h3 id="提取keywords"><a href="#提取keywords" class="headerlink" title="提取keywords"></a>提取keywords</h3><p>同样是先clean，提取title、metaKeyword，</p>
<p>再提取blocks</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> blocks:<span class="type">List</span>[<span class="type">SnippetBlock</span>] =  <span class="type">ExtractUtil</span>.extractBlocks(doc, title).map &#123; block =&gt;</div><div class="line">      &#123;</div><div class="line">              <span class="type">SnippetBlock</span>(block.snippets map &#123; snippet =&gt; <span class="type">TextProcess</span>.normalize(urlReg.matcher(snippet).replaceAll(<span class="string">""</span>)) &#125;, block.score, block.isArticle, block.imgs)</div><div class="line"></div><div class="line">	      <span class="keyword">val</span> temp  = block.snippets map &#123; snippet =&gt; <span class="type">TextProcess</span>.normalize(urlReg.matcher(snippet).replaceAll(<span class="string">""</span>)) &#125;</div><div class="line">	      maxLen += temp.map(<span class="type">AtomSplit</span>.count(_)).sum	</div><div class="line">	      <span class="keyword">val</span> retVal:<span class="type">SnippetBlock</span> = <span class="keyword">if</span>(maxLen &lt; <span class="type">MAX_CONTENT_LENGTH</span> || maxflag)&#123;<span class="type">SnippetBlock</span>(temp, block.score, block.isArticle, block.imgs)&#125; <span class="keyword">else</span> <span class="literal">null</span></div><div class="line">	      <span class="keyword">if</span>(maxLen &gt; <span class="type">MAX_CONTENT_LENGTH</span>)&#123;</div><div class="line">	        maxflag = <span class="literal">false</span></div><div class="line">	      &#125;</div><div class="line">	      retVal</div><div class="line">      &#125;</div><div class="line">    &#125;.filter( _ != <span class="literal">null</span>)</div></pre></td></tr></table></figure>
<h4 id="dlg"><a href="#dlg" class="headerlink" title="dlg"></a>dlg</h4><p>再提取dlg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val dlg = DlgExtractor.extract(normalTitle, TextUtil.fillText(doc.title), blocks, 6)/*.filter(_._2 &gt; 1.0)*/</div></pre></td></tr></table></figure>
<p>分词后，计算每个词的权重，</p>
<p>First of all, for any web page, we can use jsoup to  obtain the Document Object Model (DOM) , which can access all the HTML elements of it.</p>
<p>After that，we clean up  HTML elements by drop some invalid or useless tags, such as the tags with “display:none” property. </p>
<p>At last, We extract the Content and Keywords of HTML. </p>
<p>For extracting Content, we iterate through the DOM tree to find all TextNode elements, extract the text and take them as the Snippets. Then we calculate the scores of all Snippets, and get the available Snippets as Content.</p>
<p>For extracing Keywords, besides the Snippets from TextNode elements, we also collect the title, keywords and description from <meta> tag, store them as Blocks.   For every Block, we segment words to generate the corpus by ansj_seg, and calculate the weight of every word using TFIDF. Finally, we get the TOP 10 words as Keywords of web page.</p>
<p>我们解析了10万左右的网页，根据解析的网页content打上safe和unsafe的label，后期我们会对safe和unsafe进一步细分。</p>
<p>训练过程：我们载入所有含标签的训练样本，由于fasttext提供了适用于各种语言的Word2Vec预向量集，将网页内容转为词向量，通过fasttext训练出模型并保存到本地。</p>
<p>预测过程：载入模型到内存，当输入一个网页的content后，转为词向量，根据模型给出safe或unsafe的分类结果。</p>
<p>We have analyzed some 100 thousand web pages, classified text in categories, such as safe and unsafe by content of these web pages, and we will extent more categories in future.</p>
<p>In order to train the text classifier model, we load all samples containing a training sentence per line along with the labels, and transfer all words to vectors using  pre-trained word vectors model published by fastText.  Then we use the code from Github to run the training program. Once the model was trained, we save it on disk as a file.</p>
<p>When input a content of web page, we transfer it to word vectors and run the prediction program, as a result we get the category of this web page.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/算法与数据结构/路径规划算法/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/算法与数据结构/路径规划算法/" class="post-title-link" itemprop="url">路径规划算法</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-03 09:22:59" itemprop="dateModified" datetime="2019-06-03T09:22:59+08:00">2019-06-03</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法与数据结构/" itemprop="url" rel="index"><span itemprop="name">算法与数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/算法与数据结构/路径规划算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/算法与数据结构/路径规划算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TSP、VRP</p>
<h2 id="VRP"><a href="#VRP" class="headerlink" title="VRP"></a>VRP</h2><p>Vehicle Routing Problem</p>
<p>假设在一个供求关系系统中，车辆从货源取货，配送到对应的若干配送点。车辆存在最大载货量，且配送可能有时间限制。需要合理安排取货时间，组织适当的行车路线，使用户需求得到满足，同时使某个代价函数最小，比如总工作时间最少、路径最短等。</p>
<p>可以看出TSP问题是VRP问题的一种简单特殊形式。因此，VRP也是一种NP hard 问题。</p>
<p>目前解决此种问题的办法有多种，主要以启发式算法为主。包括退火算法、遗传算法、蚁群算法、禁忌算法等。</p>
<p><a href="https://blog.csdn.net/ldotn/article/details/53366882" target="_blank" rel="noopener">https://blog.csdn.net/ldotn/article/details/53366882</a></p>
<p>C-W节约算法和遗传算法</p>
<p>C-W节约算法：<br>基本思想是把各点单独与货源相连，构成若干条仅含一个配送点的线路，总费用为两倍从原点到各点的距离费用；然后计算将点 i 和点 j 连接在一条线路上费用节约值： </p>
<script type="math/tex; mode=display">
S(i,j) = C_{oi}+C_{io}+C_{oj}+C_{jo}-(C_{oi}+C_{ij}+C_{jo}) \\= C_{oi}+C_{oj}+C_{ij}</script><p>具体步骤：<br>（1）计算节约值S(i,j)，按从大到小排序<br>（2）考虑表格中最大元素Smax（i,j）Smax（i,j），对应点i和j，按条件进行操作： </p>
<ol>
<li>若i和j均不在构成线路上，则得到线路 o -&gt; i -&gt;j -&gt;o，转到（3） </li>
<li>若i或j在已构成线路上，但不是内点 0 -&gt; i -&gt;o，则可连接，转到（3） </li>
<li>若i和j位于已构成不同线路上，且均不是内点，则连接得到线路，转到（3） </li>
<li>若i和j位于已构成的同一线路，则不连接，转到（3）<br>（3）划去第i行和第j列，即i点不能再到其他点，j点也不能由其他店到达<br>（4）若所有元素均被划去，则得到完整线路，算法终止；否则，在没有划去的元素中选最大元素，转至（2）。</li>
</ol>
<hr>
<p>作者：LDOTN<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/ldotn/article/details/53366882?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/ldotn/article/details/53366882?utm_source=copy</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<h2 id="专栏-从架构到算法，详解美团外卖订单分配内部机制"><a href="#专栏-从架构到算法，详解美团外卖订单分配内部机制" class="headerlink" title="专栏 | 从架构到算法，详解美团外卖订单分配内部机制"></a>专栏 | 从架构到算法，详解美团外卖订单分配内部机制</h2><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1539566532&amp;ver=1183&amp;signature=9jq4HLmibsnw8OrowBhYA9CXJN79KssHyV0G4Kra2LrXD95V-RHwziumoBV1pwJEsK-4kEiHILRjucx7fM4kyp*s61FEF3tEYd40N3CFBEvakfY1Kj0-pWEjqIYTm4G-&amp;new=1" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1539566532&amp;ver=1183&amp;signature=9jq4HLmibsnw8OrowBhYA9CXJN79KssHyV0G4Kra2LrXD95V-RHwziumoBV1pwJEsK-4kEiHILRjucx7fM4kyp*s61FEF3tEYd40N3CFBEvakfY1Kj0-pWEjqIYTm4G-&amp;new=1</a></p>
<p>外卖订单的分配问题一般可建模为带有若干复杂约束的 DVRP（Dynamic Vehicle Routing Problem）问题。这类问题一般可表述为：有一定数量的骑手，每名骑手身上有若干订单正在配送过程中，在过去一段时间（如 1 分钟）内产生了一批新订单，已知骑手的行驶速度、任意两点间的行驶距离、每个订单的出餐时间和交付时间（骑手到达用户所在地之后将订单交付至用户所需的时间），那么如何将这批新订单在正确的时间分配至正确的骑手，使得用户体验得到保证的同时，骑手的配送效率最高。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/29/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Schwimmer</p>
              <div class="site-description motion-element" itemprop="description">Record and Think!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">314</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Schwimmer</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.5.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.2.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  
  
<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-schwimmer-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->







  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
