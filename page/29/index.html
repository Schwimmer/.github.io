<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222"/>






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"/>

<link rel="stylesheet" href="/css/main.css?v=7.2.0"/>


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Record and Think!">
<meta property="og:type" content="website">
<meta property="og:title" content="Schwimmer&#39;s Blog">
<meta property="og:url" content="https://schwimmer.github.io/page/29/index.html">
<meta property="og:site_name" content="Schwimmer&#39;s Blog">
<meta property="og:description" content="Record and Think!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Schwimmer&#39;s Blog">
<meta name="twitter:description" content="Record and Think!">





  
  
  <link rel="canonical" href="https://schwimmer.github.io/page/29/"/>



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Schwimmer's Blog</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143240576-1"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-143240576-1');
    }
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Schwimmer's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br/>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br/>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br/>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br/>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br/>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/编程语言学习/PYTHON/pandas/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/编程语言学习/PYTHON/pandas/" class="post-title-link" itemprop="url">Pandas笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-13 17:12:25" itemprop="dateModified" datetime="2019-02-13T17:12:25+08:00">2019-02-13</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PYTHON/" itemprop="url" rel="index"><span itemprop="name">PYTHON</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/编程语言学习/PYTHON/pandas/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/编程语言学习/PYTHON/pandas/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/xiaoxuebiye/p/7223774.html" target="_blank" rel="noopener">整理pandas操作</a></p>
<p><a href="https://blog.csdn.net/sherri_du/article/details/69397050" target="_blank" rel="noopener">用 Python 做数据处理必看：12 个使效率倍增的 Pandas 技巧</a></p>
<h1 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h1><h2 id="随机数据"><a href="#随机数据" class="headerlink" title="随机数据"></a>随机数据</h2><p>创建一个Series，pandas可以生成一个默认的索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = pd.Series([1,3,5,np.nan,6,8])</div></pre></td></tr></table></figure>
<p>通过numpy创建DataFrame，包含一个日期索引，以及标记的列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dates = pd.date_range(&apos;20170101&apos;, periods=6)</div><div class="line">df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list(&apos;ABCD&apos;))</div><div class="line"></div><div class="line">df</div><div class="line">Out[4]: </div><div class="line">                   A         B         C         D</div><div class="line">2016-10-10  0.630275  1.081899 -1.594402 -2.571683</div><div class="line">2016-10-11 -0.211379 -0.166089 -0.480015 -0.346706</div><div class="line">2016-10-12 -0.416171 -0.640860  0.944614 -0.756651</div><div class="line">2016-10-13  0.652248  0.186364  0.943509  0.053282</div><div class="line">2016-10-14 -0.430867 -0.494919 -0.280717 -1.327491</div><div class="line">2016-10-15  0.306519 -2.103769 -0.019832  0.035211</div></pre></td></tr></table></figure>
<p>其中，<code>np.random.randn</code>可以返回一个随机数组</p>
<h2 id="通过Dict创建"><a href="#通过Dict创建" class="headerlink" title="通过Dict创建"></a>通过Dict创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">df2 = pd.DataFrame(&#123; <span class="string">'A'</span> : <span class="number">1.</span>,</div><div class="line">                     <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</div><div class="line">                     <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</div><div class="line">                     <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</div><div class="line">                     <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</div><div class="line">                     <span class="string">'F'</span> : <span class="string">'foo'</span> &#125;)</div><div class="line">                     </div><div class="line">Out[<span class="number">20</span>]: </div><div class="line">     A          B    C  D      E    F</div><div class="line"><span class="number">0</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>   test  foo</div><div class="line"><span class="number">1</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>  train  foo</div><div class="line"><span class="number">2</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>   test  foo</div><div class="line"><span class="number">3</span>  <span class="number">1.0</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.0</span>  <span class="number">3</span>  train  foo</div></pre></td></tr></table></figure>
<h2 id="通过nparray创建"><a href="#通过nparray创建" class="headerlink" title="通过nparray创建"></a>通过nparray创建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">data = [[<span class="number">2000</span>,<span class="number">1</span>,<span class="number">2</span>],</div><div class="line">[<span class="number">2001</span>,<span class="number">1</span>,<span class="number">3</span>]</div><div class="line">]</div><div class="line"></div><div class="line">df = pd.DataFrame(data,</div><div class="line">		index=[<span class="string">'one'</span>,<span class="string">'two'</span>],</div><div class="line">		columns=[<span class="string">'year'</span>,<span class="string">'state'</span>,<span class="string">'pop'</span>])</div><div class="line">		</div><div class="line">		</div><div class="line"><span class="comment"># 也可以转置后创建</span></div><div class="line">out = array([data_real_np, ydz_np]).T</div><div class="line">df = pd.DataFrame(out)</div><div class="line">df.to_csv(<span class="string">'final.csv'</span>, encoding=<span class="string">'utf-8'</span>, index=<span class="number">0</span>, header=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<h2 id="创建TimeStamp"><a href="#创建TimeStamp" class="headerlink" title="创建TimeStamp"></a>创建TimeStamp</h2><p>有几个方法可以构造一个Timestamp对象</p>
<ul>
<li>pd.Timestamp</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import pandas as pd</div><div class="line">from datetime import datetime as dt</div><div class="line">p1=pd.Timestamp(2017,6,19)</div><div class="line">p2=pd.Timestamp(dt(2017,6,19,hour=9,minute=13,second=45))</div><div class="line">p3=pd.Timestamp(&quot;2017-6-19 9:13:45&quot;)</div><div class="line"></div><div class="line">print(&quot;type of p1:&quot;,type(p1))</div><div class="line">print(p1)</div><div class="line">print(&quot;type of p2:&quot;,type(p2))</div><div class="line">print(p2)</div><div class="line">print(&quot;type of p3:&quot;,type(p3))</div><div class="line">print(p3)</div><div class="line"></div><div class="line"></div><div class="line">(&apos;type of p1:&apos;, &lt;class &apos;pandas.tslib.Timestamp&apos;&gt;)</div><div class="line">2017-06-19 00:00:00</div><div class="line">(&apos;type of p2:&apos;, &lt;class &apos;pandas.tslib.Timestamp&apos;&gt;)</div><div class="line">2017-06-19 09:13:45</div><div class="line">(&apos;type of p3:&apos;, &lt;class &apos;pandas.tslib.Timestamp&apos;&gt;)</div><div class="line">2017-06-19 09:13:45</div></pre></td></tr></table></figure>
<ul>
<li>to_datetime()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import pandas as pd</div><div class="line">from datetime import datetime as dt</div><div class="line"></div><div class="line">p4=pd.to_datetime(&quot;2017-6-19 9:13:45&quot;)</div><div class="line">p5=pd.to_datetime(dt(2017,6,19,hour=9,minute=13,second=45))</div><div class="line"></div><div class="line">print(&quot;type of p4:&quot;,type(p4))</div><div class="line">print(p4)</div><div class="line">print(&quot;type of p5:&quot;,type(p5))</div><div class="line">print(p5)</div><div class="line"></div><div class="line">(&apos;type of p4:&apos;, &lt;class &apos;pandas.tslib.Timestamp&apos;&gt;)</div><div class="line">2017-06-19 09:13:45</div><div class="line">(&apos;type of p5:&apos;, &lt;class &apos;pandas.tslib.Timestamp&apos;&gt;)</div><div class="line">2017-06-19 09:13:45</div></pre></td></tr></table></figure>
<h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><h2 id="读取csv"><a href="#读取csv" class="headerlink" title="读取csv"></a>读取csv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df = pd.read_csv(&apos;x.csv&apos;)</div></pre></td></tr></table></figure>
<h2 id="读取压缩包"><a href="#读取压缩包" class="headerlink" title="读取压缩包"></a>读取压缩包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import zipfile</div><div class="line"></div><div class="line">with zipfile.ZipFile(&apos;x.csv.zip&apos;, &apos;r&apos;) as z:</div><div class="line">    f = z.open(&apos;x.csv&apos;)</div><div class="line">    df = pd.read_csv(f, header=0)</div></pre></td></tr></table></figure>
<h2 id="保存为csv"><a href="#保存为csv" class="headerlink" title="保存为csv"></a>保存为csv</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out_df.to_csv(&apos;predict_result.csv&apos;, encoding=&apos;utf-8&apos;, index=0, header=None)</div><div class="line"># index=0即不要序号的列，header=None即不要表头</div></pre></td></tr></table></figure>
<h1 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h1><p>参考<a href="http://pandas.pydata.org/pandas-docs/stable/basics.html#basics" target="_blank" rel="noopener">Basics section</a></p>
<h2 id="查看数据类型"><a href="#查看数据类型" class="headerlink" title="查看数据类型"></a>查看数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">df2.dtypes</div><div class="line"></div><div class="line">Out[30]: </div><div class="line">A           float64</div><div class="line">B    datetime64[ns]</div><div class="line">C           float32</div><div class="line">D             int32</div><div class="line">E          category</div><div class="line">F            object</div><div class="line">dtype: object</div></pre></td></tr></table></figure>
<h2 id="查看head和tail"><a href="#查看head和tail" class="headerlink" title="查看head和tail"></a>查看head和tail</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.head(1)</div><div class="line">df.tail(3)</div></pre></td></tr></table></figure>
<h2 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.empty</div></pre></td></tr></table></figure>
<h2 id="查看index、column和数据"><a href="#查看index、column和数据" class="headerlink" title="查看index、column和数据"></a>查看index、column和数据</h2><p>获取表头<code>df.columns</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df.index</div><div class="line">df.columns</div><div class="line">df.values      </div><div class="line">df.count</div></pre></td></tr></table></figure>
<h2 id="显示数据的快速统计"><a href="#显示数据的快速统计" class="headerlink" title="显示数据的快速统计"></a>显示数据的快速统计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">df.describe()</div><div class="line">Out[19]: </div><div class="line">              A         B         C         D</div><div class="line">count  6.000000  6.000000  6.000000  6.000000</div><div class="line">mean   0.073711 -0.431125 -0.687758 -0.233103</div><div class="line">std    0.843157  0.922818  0.779887  0.973118</div><div class="line">min   -0.861849 -2.104569 -1.509059 -1.135632</div><div class="line">25%   -0.611510 -0.600794 -1.368714 -1.076610</div><div class="line">50%    0.022070 -0.228039 -0.767252 -0.386188</div><div class="line">75%    0.658444  0.041933 -0.034326  0.461706</div><div class="line">max    1.212112  0.567020  0.276232  1.071804</div></pre></td></tr></table></figure>
<h2 id="找缺失值"><a href="#找缺失值" class="headerlink" title="找缺失值"></a>找缺失值</h2><p><a href="https://blog.csdn.net/u012387178/article/details/52571725" target="_blank" rel="noopener">https://blog.csdn.net/u012387178/article/details/52571725</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(df_base_dpd[df_base_dpd.isnull().values == True])</div></pre></td></tr></table></figure>
<h1 id="筛选数据"><a href="#筛选数据" class="headerlink" title="筛选数据"></a>筛选数据</h1><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.T</div></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><code>traj_plot.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df = df.set_index(&apos;gpstime&apos;)</div><div class="line">for index, row in df.iterrows():</div><div class="line">	locationF.write(&quot;p%s | %s | %s | %s | %s &quot; % (str(cnt), index, str(row[0]), str(row[1]), str(row[2])) + &apos;\n&apos; )</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_map</span><span class="params">(data, exp)</span>:</span>                  </div><div class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows():   <span class="comment"># 获取每行的index、row</span></div><div class="line">        <span class="keyword">for</span> col_name <span class="keyword">in</span> data.columns:</div><div class="line">            row[col_name] = exp(row[col_name]) <span class="comment"># 把结果返回给data</span></div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_1map</span><span class="params">(data, exp)</span>:</span></div><div class="line">    _data = [[exp(row[col_name])               <span class="comment"># 把结果转换成2级list</span></div><div class="line">             <span class="keyword">for</span> col_name <span class="keyword">in</span> data.columns]</div><div class="line">             <span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows()</div><div class="line">            ]</div><div class="line">    <span class="keyword">return</span> _data</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    inp = [&#123;<span class="string">'c1'</span>:<span class="number">10</span>, <span class="string">'c2'</span>:<span class="number">100</span>&#125;, &#123;<span class="string">'c1'</span>:<span class="number">11</span>,<span class="string">'c2'</span>:<span class="number">110</span>&#125;, &#123;<span class="string">'c1'</span>:<span class="number">12</span>,<span class="string">'c2'</span>:<span class="number">120</span>&#125;]</div><div class="line">    df = pd.DataFrame(inp)</div><div class="line">    temp = _map(df, <span class="keyword">lambda</span> ele: ele+<span class="number">1</span> )</div><div class="line">    <span class="keyword">print</span> temp</div><div class="line"></div><div class="line">    _temp = _1map(df, <span class="keyword">lambda</span> ele: ele+<span class="number">1</span>)</div><div class="line">    res_data = pd.DataFrame(_temp)         <span class="comment"># 对2级list转换成DataFrame</span></div><div class="line">    <span class="keyword">print</span> res_data</div></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="通过列名来排序"><a href="#通过列名来排序" class="headerlink" title="通过列名来排序"></a>通过列名来排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#对于矩阵，axis=0表示行，1表示列</div><div class="line">df.sort_index(axis=1, ascending=False)</div></pre></td></tr></table></figure>
<h3 id="通过某一列的数值排序"><a href="#通过某一列的数值排序" class="headerlink" title="通过某一列的数值排序"></a>通过某一列的数值排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.sort_values(by=&apos;B&apos;)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import pandas as pd</div><div class="line"></div><div class="line">df = pd.read_csv(&apos;./query_result.csv&apos;, sep=&apos;,&apos;)</div><div class="line"># 转为日期型</div><div class="line">df[&apos;gpstime&apos;] = pd.to_datetime(df[&apos;gpstime&apos;])</div><div class="line"># 按某一列排序</div><div class="line">df.sort_values([&apos;gpstime&apos;])</div></pre></td></tr></table></figure>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h2 id="series选择某行"><a href="#series选择某行" class="headerlink" title="series选择某行"></a>series选择某行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df_app_no[0] #不需要跟列名，因为只有一列</div></pre></td></tr></table></figure>
<h2 id="选择某个行列的值"><a href="#选择某个行列的值" class="headerlink" title="选择某个行列的值"></a>选择某个行列的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bad_predict_label.iloc[i, 0]</div></pre></td></tr></table></figure>
<p>表示选择第i行，第0列的值</p>
<h3 id="选择某一列"><a href="#选择某一列" class="headerlink" title="选择某一列"></a>选择某一列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df[&apos;A&apos;]</div></pre></td></tr></table></figure>
<p>某几列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">col_n = [&apos;名称&apos;,&apos;收盘价&apos;,&apos;日期&apos;]</div><div class="line"></div><div class="line">a = pd.DataFrame(df,columns = col_n)</div></pre></td></tr></table></figure>
<h3 id="选择某几行"><a href="#选择某几行" class="headerlink" title="选择某几行"></a>选择某几行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">df[0:3]</div><div class="line">#也可以通过行的索引来选择，但是不能单独写某一行</div><div class="line">df[&apos;20130102&apos;:&apos;20130104&apos;]</div></pre></td></tr></table></figure>
<h3 id="通过条件过滤行"><a href="#通过条件过滤行" class="headerlink" title="通过条件过滤行"></a>通过条件过滤行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df_pred.label[df_pred[&apos;label&apos;]&lt;1]</div></pre></td></tr></table></figure>
<h3 id="选择几列转为矩阵"><a href="#选择几列转为矩阵" class="headerlink" title="选择几列转为矩阵"></a>选择几列转为矩阵</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">coords=dftest.as_matrix(columns=[&apos;longitude&apos;,&apos;latitude&apos;])</div></pre></td></tr></table></figure>
<h3 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df_train_p = df_train_p.sample(frac=0.7)</div></pre></td></tr></table></figure>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><h3 id="找到为null的"><a href="#找到为null的" class="headerlink" title="找到为null的"></a>找到为null的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(dfall[dfall.isnull().values == True])</div></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_22238533/article/details/76127966" target="_blank" rel="noopener">pandas如何去掉、过滤数据集中的某些值或者某些行？</a></p>
<h3 id="删除某列"><a href="#删除某列" class="headerlink" title="删除某列"></a>删除某列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：直接del DF[&apos;column-name&apos;]</div><div class="line"></div><div class="line">方法二：采用drop方法，有下面三种等价的表达式：</div><div class="line"></div><div class="line">1. DF= DF.drop(&apos;column_name&apos;, 1)；</div><div class="line">2. DF.drop(&apos;column_name&apos;,axis=1, inplace=True)</div><div class="line"># inplace=true表示对原DF操作，否则将结果生成在一个新的DF中</div><div class="line">3. DF.drop(DF.columns[ : ], axis=1,inplace=True)   # Note: zero indexed</div><div class="line"></div><div class="line">x = [1,2]    #删除多列需给定列表，否则参数过多</div><div class="line">df.drop(df.columns[x],axis=1,inplace=True)</div></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_36523839/article/details/80061326" target="_blank" rel="noopener">pandas删除列</a></p>
<h3 id="根据时间范围过滤"><a href="#根据时间范围过滤" class="headerlink" title="根据时间范围过滤"></a>根据时间范围过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df = df.set_index(&apos;gpstime&apos;)</div><div class="line">df[&apos;2018-04-22 01:00:00&apos;: &apos;2018-04-22 05:00:00&apos;]</div></pre></td></tr></table></figure>
<h3 id="某一列按条件过滤"><a href="#某一列按条件过滤" class="headerlink" title="某一列按条件过滤"></a>某一列按条件过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">nightdf = nightdf[nightdf[&apos;speed&apos;]&lt;1]</div><div class="line"></div><div class="line">df06 = df04.loc[True - (float(df04.columns[-6]) &gt; 0.0)]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 验证有效的方法</div><div class="line">df_pred_raw.due_type3[(df_pred_raw[&apos;due_type3&apos;]&lt;12) &amp; (df_pred_raw[&apos;due_type3&apos;]&gt;5)]</div></pre></td></tr></table></figure>
<h3 id="行列同时过滤"><a href="#行列同时过滤" class="headerlink" title="行列同时过滤"></a>行列同时过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wrong_idx = result[(result[&apos;pred&apos;]&lt;0.95) &amp; (result[&apos;label&apos;]&gt;0.05)].index</div><div class="line">df_pred_wrong = df_pred_raw.loc[wrong_idx, [&apos;yq30_term_rate_3&apos;,&apos;due_type3&apos;,&apos;zd_term_rate&apos;]]</div></pre></td></tr></table></figure>
<h3 id="用正则过滤"><a href="#用正则过滤" class="headerlink" title="用正则过滤"></a>用正则过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.filter(regex=(&quot;d.*&quot;))</div><div class="line">&gt;&gt;</div><div class="line">   d1  d2</div><div class="line">0  2   3</div><div class="line">1  3   4</div><div class="line">2  4   5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.select(lambda col: col.startswith(&apos;d&apos;), axis=1)</div><div class="line">&gt;&gt;</div><div class="line">   d1  d2</div><div class="line">0  2   3</div><div class="line">1  3   4</div><div class="line">2  4   5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df_trains = df_trains.filter(regex=(&quot;.*3days|label|.*7days&quot;))</div></pre></td></tr></table></figure>
<h2 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h2><p><a href="https://blog.csdn.net/hewb14/article/details/50520524" target="_blank" rel="noopener">利用pandas进行数据分组及可视化</a></p>
<p><a href="http://www.cnblogs.com/huiyang865/p/5577772.html" target="_blank" rel="noopener">pandas聚合和分组运算——GroupBy技术(1)</a></p>
<p>例1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_blobs</div><div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</div><div class="line"><span class="comment"># generate 2d classification dataset</span></div><div class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">3</span>, n_features=<span class="number">2</span>)</div><div class="line"><span class="comment"># dict中定义三个key，分别是坐标和label，再通过dict创建DataFrame</span></div><div class="line">df = DataFrame(dict(x=X[:,<span class="number">0</span>], y=X[:,<span class="number">1</span>], label=y))</div><div class="line">colors = &#123;<span class="number">0</span>:<span class="string">'red'</span>, <span class="number">1</span>:<span class="string">'blue'</span>, <span class="number">2</span>:<span class="string">'green'</span>&#125;</div><div class="line">fig, ax = pyplot.subplots()</div><div class="line"><span class="comment">#groupby可以通过传入需要分组的参数实现对数据的分组</span></div><div class="line">grouped = df.groupby(<span class="string">'label'</span>)</div><div class="line"><span class="keyword">for</span> key, group <span class="keyword">in</span> grouped:</div><div class="line">   group.plot(ax=ax, kind=<span class="string">'scatter'</span>, x=<span class="string">'x'</span>, y=<span class="string">'y'</span>, label=key, color=colors[key])</div><div class="line">pyplot.show()</div></pre></td></tr></table></figure>
<p>例2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line"><span class="comment"># 把数据划分到自定义的区间中</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cla</span><span class="params">(n,lim)</span>:</span></div><div class="line">    <span class="keyword">return</span><span class="string">'[%.f,%.f)'</span>%(lim*(n//lim),lim*(n//lim)+lim) <span class="comment"># map function</span></div><div class="line"></div><div class="line"><span class="comment"># 默认第一行是标题，从第二行开始是数据。sep是分隔符</span></div><div class="line">df = pd.read_csv(<span class="string">'/home/david/iaudience-plan-statistics.csv'</span>, sep=<span class="string">','</span>)</div><div class="line"><span class="comment"># 设置某列的数据类型</span></div><div class="line">df[<span class="string">'precent'</span>] = df[<span class="string">'precent'</span>].astype(<span class="string">'float64'</span>)</div><div class="line"><span class="comment"># 对planid做group，group后对precent做sum</span></div><div class="line">grouped = df[<span class="string">'precent'</span>].groupby(df[<span class="string">'planid'</span>]).sum()</div><div class="line"></div><div class="line">c = pd.DataFrame(grouped)</div><div class="line"><span class="comment"># 用c.precent或c['precent']都可以</span></div><div class="line">addone = pd.Series([cla(s,<span class="number">1</span>) <span class="keyword">for</span> s <span class="keyword">in</span> c.precent])</div><div class="line">c[<span class="string">'addone'</span>] = addone</div><div class="line">groups3 = c.groupby([<span class="string">'addone'</span>]).count()</div><div class="line">groups3[<span class="string">'precent'</span>].plot(<span class="string">'bar'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p><a href="https://blog.csdn.net/xinxing__8185/article/details/48022401" target="_blank" rel="noopener">https://blog.csdn.net/xinxing__8185/article/details/48022401</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">from pandas import Series, DataFrame  </div><div class="line">  </div><div class="line">data = DataFrame(&#123;&apos;k&apos;: [1, 1, 2, 2]&#125;)  </div><div class="line">  </div><div class="line">print data  </div><div class="line">  </div><div class="line">IsDuplicated = data.duplicated()  </div><div class="line">  </div><div class="line">print IsDuplicated  </div><div class="line">print type(IsDuplicated)  </div><div class="line">  </div><div class="line">data = data.drop_duplicates()  </div><div class="line">print data</div></pre></td></tr></table></figure>
<p>DataFrame的duplicated方法返回一个布尔型Series,表示各行是否重复行。</p>
<p>而 drop_duplicates方法，它用于返回一个移除了重复行的DataFrame</p>
<p>这两个方法会判断全部列，你也可以指定部分列进行重复项判段。</p>
<p>例如，希望对名字为k2的列进行去重，</p>
<p>data.drop_duplicates([‘k2’])</p>
<h1 id="多个DataFrame操作"><a href="#多个DataFrame操作" class="headerlink" title="多个DataFrame操作"></a>多个DataFrame操作</h1><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">objs 是需要拼接的对象集合，一般为列表或者字典</div><div class="line">axis=0 是行拼接，拼接之后行数增加，列数也根据join来定，join=’outer’时，列数是两表并集。同理join=’inner’,列数是两表交集。</div><div class="line">在默认情况下，axis=0为纵向拼接，此时有</div><div class="line">concat([df1,df2]) 等价于 df1.append(df2)</div><div class="line"></div><div class="line">在axis=1 时为横向拼接 ，此时有</div><div class="line">concat([df1,df2],axis=1) 等价于 merge(df1,df2,left_index=True,right_index=True,how=&apos;outer&apos;)</div></pre></td></tr></table></figure>
<h1 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h1><h2 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h2><p>使用一个全局常量填充缺失值：将缺失值用同一个常数（如Unknown或﹣∞）替换。如果缺失值都用Unknown替换，则挖掘程序可能误认为它们形成了一个有趣的概念，因为它们都具有相同的值“Unknown”。因此此方法虽然简单但不可靠。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data.Cabin.fillna(&apos;unknown&apos;,inplace=True)</div><div class="line"></div><div class="line">df_all.fillna(0, inplace=True)</div></pre></td></tr></table></figure>
<p>使用属性的均值填充缺失值：例如，假定顾客的平均收入为56000美元，则使用该值替换income中的缺失值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data.Age.fillna(data.Age.mean(),inplace=True)</div></pre></td></tr></table></figure>
<h2 id="新建列并赋值"><a href="#新建列并赋值" class="headerlink" title="新建列并赋值"></a>新建列并赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">frame[&apos;panduan&apos;] = frame.city.apply(lambda x: 1 if &apos;ing&apos; in x else 0)</div></pre></td></tr></table></figure>
<h2 id="Drop列"><a href="#Drop列" class="headerlink" title="Drop列"></a>Drop列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df1t.drop([&apos;app&apos;], axis=1, inplace=True)</div></pre></td></tr></table></figure>
<h2 id="选择列"><a href="#选择列" class="headerlink" title="选择列"></a>选择列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">col_imp = [&apos;mobile_city_code&apos;,&apos;label&apos;]</div><div class="line">df_train = pd.DataFrame(df_train, columns=col_imp)</div></pre></td></tr></table></figure>
<h2 id="改列名"><a href="#改列名" class="headerlink" title="改列名"></a>改列名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.rename(columns=&#123;&apos;A&apos;:&apos;a&apos;, &apos;C&apos;:&apos;c&apos;&#125;, inplace = True)</div></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="用kmeans聚类"><a href="#用kmeans聚类" class="headerlink" title="用kmeans聚类"></a>用kmeans聚类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment">#读取文本数据到DataFrame中，将数据转换为matrix，保存在dataSet中</span></div><div class="line">df = pd.read_table(<span class="string">'d:/22.txt'</span>)</div><div class="line">dataSet = df.as_matrix(columns=<span class="keyword">None</span>)</div><div class="line"><span class="comment"># n_clusters=4，参数设置需要的分类这里设置成4类</span></div><div class="line">kmeans = KMeans(n_clusters=<span class="number">4</span>, random_state=<span class="number">0</span>).fit(dataSet)</div><div class="line"><span class="comment">#center为各类的聚类中心，保存在df_center的DataFrame中给数据加上标签</span></div><div class="line">center = kmeans.cluster_centers_</div><div class="line">df_center = pd.DataFrame(center, columns=[<span class="string">'x'</span>, <span class="string">'y'</span>])</div><div class="line"><span class="comment">#标注每个点的聚类结果</span></div><div class="line">labels = kmeans.labels_</div><div class="line"><span class="comment">#将原始数据中的索引设置成得到的数据类别，根据索引提取各类数据并保存</span></div><div class="line">df = pd.DataFrame(dataSet, index=labels, columns=[<span class="string">'x'</span>, <span class="string">'y'</span>])</div><div class="line">df1 = df[df.index==<span class="number">0</span>]</div><div class="line">df2 = df[df.index==<span class="number">1</span>]</div><div class="line">df3 = df[df.index==<span class="number">2</span>]</div><div class="line">df4 = df[df.index==<span class="number">3</span>]</div><div class="line"><span class="comment">#绘图</span></div><div class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>), dpi=<span class="number">80</span>)</div><div class="line">axes = plt.subplot()</div><div class="line"><span class="comment">#s表示点大小，c表示color，marker表示点类型，DataFrame数据列引用参考博客其他文章</span></div><div class="line">type1 = axes.scatter(df1.loc[:,[<span class="string">'x'</span>]], df1.loc[:,[<span class="string">'y'</span>]], s=<span class="number">50</span>, c=<span class="string">'red'</span>, marker=<span class="string">'d'</span>)</div><div class="line">type2 = axes.scatter(df2.loc[:,[<span class="string">'x'</span>]], df2.loc[:,[<span class="string">'y'</span>]], s=<span class="number">50</span>, c=<span class="string">'green'</span>, marker=<span class="string">'*'</span>)</div><div class="line">type3 = axes.scatter(df3.loc[:,[<span class="string">'x'</span>]], df3.loc[:,[<span class="string">'y'</span>]], s=<span class="number">50</span>, c=<span class="string">'brown'</span>, marker=<span class="string">'p'</span>)</div><div class="line">type4 = axes.scatter(df4.loc[:,[<span class="string">'x'</span>]], df4.loc[:,[<span class="string">'y'</span>]], s=<span class="number">50</span>, c=<span class="string">'black'</span>)</div><div class="line"><span class="comment">#显示聚类中心数据点</span></div><div class="line">type_center = axes.scatter(df_center.loc[:,<span class="string">'x'</span>], df_center.loc[:,<span class="string">'y'</span>], s=<span class="number">40</span>, c=<span class="string">'blue'</span>)</div><div class="line">plt.xlabel(<span class="string">'x'</span>, fontsize=<span class="number">16</span>)</div><div class="line">plt.ylabel(<span class="string">'y'</span>, fontsize=<span class="number">16</span>)</div><div class="line">axes.legend((type1, type2, type3, type4, type_center), (<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'center'</span>), loc=<span class="number">1</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<h1 id="转ndarray"><a href="#转ndarray" class="headerlink" title="转ndarray"></a>转ndarray</h1><p><a href="https://blog.csdn.net/flyfrommath/article/details/69388675" target="_blank" rel="noopener">https://blog.csdn.net/flyfrommath/article/details/69388675</a></p>
<h1 id="onehot后转dataframe"><a href="#onehot后转dataframe" class="headerlink" title="onehot后转dataframe"></a>onehot后转dataframe</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">import pandas as pd</div><div class="line">import numpy as np</div><div class="line">from sklearn.datasets import load_iris</div><div class="line">sns.set()</div><div class="line"></div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line">#Iris Plot</div><div class="line">iris = load_iris()</div><div class="line">n_samples, m_features = iris.data.shape</div><div class="line"></div><div class="line">#Load Data</div><div class="line">X, y = iris.data, iris.target</div><div class="line">D_target_dummy = dict(zip(np.arange(iris.target_names.shape[0]), iris.target_names))</div><div class="line"></div><div class="line">DF_data = pd.DataFrame(X,columns=iris.feature_names)</div><div class="line">DF_data[&quot;target&quot;] = pd.Series(y).map(D_target_dummy)</div><div class="line">#sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)  \</div><div class="line">#0                  5.1               3.5                1.4               0.2   </div><div class="line">#1                  4.9               3.0                1.4               0.2   </div><div class="line">#2                  4.7               3.2                1.3               0.2   </div><div class="line">#3                  4.6               3.1                1.5               0.2   </div><div class="line">#4                  5.0               3.6                1.4               0.2   </div><div class="line">#5                  5.4               3.9                1.7               0.4   </div><div class="line"></div><div class="line">DF_dummies = pd.get_dummies(DF_data[&quot;target&quot;])</div><div class="line">#setosa  versicolor  virginica</div><div class="line">#0         1           0          0</div><div class="line">#1         1           0          0</div><div class="line">#2         1           0          0</div><div class="line">#3         1           0          0</div><div class="line">#4         1           0          0</div><div class="line">#5         1           0          0</div><div class="line"></div><div class="line">from sklearn.preprocessing import OneHotEncoder, LabelEncoder</div><div class="line">def f1(DF_data):</div><div class="line">    Enc_ohe, Enc_label = OneHotEncoder(), LabelEncoder()</div><div class="line">    DF_data[&quot;Dummies&quot;] = Enc_label.fit_transform(DF_data[&quot;target&quot;])</div><div class="line">    DF_dummies2 = pd.DataFrame(Enc_ohe.fit_transform(DF_data[[&quot;Dummies&quot;]]).todense(), columns = Enc_label.classes_)</div><div class="line">    return(DF_dummies2)</div><div class="line"></div><div class="line">%timeit pd.get_dummies(DF_data[&quot;target&quot;])</div><div class="line">#1000 loops, best of 3: 777 µs per loop</div><div class="line"></div><div class="line">%timeit f1(DF_data)</div><div class="line">#100 loops, best of 3: 2.91 ms per loop</div></pre></td></tr></table></figure>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="Pycharm-Pandas无法绘图"><a href="#Pycharm-Pandas无法绘图" class="headerlink" title="Pycharm Pandas无法绘图"></a>Pycharm Pandas无法绘图</h2><p>最近用了pycharm，感觉还不错，就是pandas中Series、DataFrame的plot()方法不显示图片就给我结束了,但是我在ipython里就能画图</p>
<p>以前的代码是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import matplotlib.pyplot as plt</div><div class="line">from pandas import DataFrame,Series</div><div class="line"></div><div class="line">Series([4,5,7]).plot()</div></pre></td></tr></table></figure>
<p>发现只要加个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.show()</div><div class="line">就可以显示图像了了</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/工具和环境/vim命令/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/工具和环境/vim命令/" class="post-title-link" itemprop="url">vim命令</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-30 16:39:52" itemprop="dateModified" datetime="2018-01-30T16:39:52+08:00">2018-01-30</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具和环境/" itemprop="url" rel="index"><span itemprop="name">工具和环境</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/工具和环境/vim命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/工具和环境/vim命令/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="查找并删除"><a href="#查找并删除" class="headerlink" title="查找并删除"></a>查找并删除</h1><p>:g/要删除的内容/d</p>
<p>查找</p>
<p>/要查找的</p>
<p>按n就是下一个</p>
<p>删除一行</p>
<p>dd</p>
<p>查找匹配的个数</p>
<p>:%s/refering_site/&amp;/gn</p>
<p>或</p>
<p>:%s/17779//gn</p>
<p>:%s/“opxcreativeid”:16650//gn</p>
<h1 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h1><p>%s/源字符串/目的字符串/g</p>
<p>如</p>
<p>:%s/\/home\/weinan/\/opt\/pig_home\/bshare_etl/g</p>
<p>:%s/gpadmin/gpxmo/g</p>
<p>:%s/\t-1/\t1/g</p>
<p>:%s/“//g</p>
<p>:%s/16-06-28/16-06-29/g</p>
<h1 id="多行变1行"><a href="#多行变1行" class="headerlink" title="多行变1行"></a>多行变1行</h1><p>大写V选中行+shift J</p>
<h1 id="替换每行的行首、行尾"><a href="#替换每行的行首、行尾" class="headerlink" title="替换每行的行首、行尾"></a>替换每行的行首、行尾</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:1,$ s/^/HELLO/g</div><div class="line">:1,$ s/$/WORLD/g</div></pre></td></tr></table></figure>
<h1 id="sh文件的编码转成unix"><a href="#sh文件的编码转成unix" class="headerlink" title="sh文件的编码转成unix"></a>sh文件的编码转成unix</h1><p>查看用<code>:set fileformat</code></p>
<p>修改用<code>:set fileformat=unix</code></p>
<h1 id="编码从latin1转成utf8"><a href="#编码从latin1转成utf8" class="headerlink" title="编码从latin1转成utf8"></a>编码从latin1转成utf8</h1><p>:e ++enc=cp936<br>:set fileencoding=utf-8</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/机器学习笔记-最大熵/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/机器学习笔记-最大熵/" class="post-title-link" itemprop="url">机器学习笔记-最大熵</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/机器学习笔记-最大熵/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/机器学习笔记-最大熵/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、最大熵原理"><a href="#1、最大熵原理" class="headerlink" title="1、最大熵原理"></a>1、最大熵原理</h1><p>日常生活中，很多事情的发生表现出一定的随机性，试验的结果往往是不确定的，也不知道这个随机现象所服从的概率分布。<strong>最大熵的实质</strong>就是，在已知部分知识的前提下，关于未知分布最合理的推断就是符合已知知识最不确定或者最随机的推断。任何其他的选择都意味着我们增加了其他的约束和假设。</p>
<p>将最大熵应用到分类，就是最大熵模型。给定一个训练集：</p>
<script type="math/tex; mode=display">
T = \{  (x_1,y_1),  (x_2,y_2),..., (x_N,y_N)\}</script><p>其中$x_i \in X$是输入，$y_i \in Y$是输出，X和Y表示输入和输出空间。N为样本数。<strong>目标是</strong>，利用最大熵原理选出一个最好的分类模型，即对于任意给定的输入$x \in X$，可以以概率$p(y|x)$输出$y \in Y$ 。</p>
<p>按照最大熵原理，应该<strong>优先保证模型满足已知的所有约束</strong>。思路是，从训练数据T中抽取若干有用的特征，要求这些特征在T上关于经验分布$\tilde{p}(x,y)$的数学期望与它们在模型中关于$p(x,y)$的数学期望相等。这样，一个特征就是一个约束了。</p>
<p>这里就涉及到，<strong>特征如何刻画？经验分布如何表示？</strong></p>
<h1 id="2、特征函数"><a href="#2、特征函数" class="headerlink" title="2、特征函数"></a>2、特征函数</h1><p>假设通过特征选择，抽取若干特征。特征通常由特征函数来表示。例如</p>
<script type="math/tex; mode=display">
f(x,y) =\left\{\begin{matrix}
\begin{aligned}
& 1，若x,y满足某个事实 \\ 
& 0，否则
\end{aligned}
\end{matrix}\right.</script><p>这里的特征不是指输入的某个特征，而是指输入和输出共同的特征。</p>
<blockquote>
<p>例如，假设我们需要判断“打”是动词还是量词，已知的训练数据有</p>
<p>(x1,y1)=(一打火柴，量词);</p>
<p>(x2,y2)=(三打啤酒，量词);</p>
<p>(x3,y3)=(打电话，动词);</p>
<p>(x4,y4)=(打篮球，动词);</p>
<p>通过观察，发现“打”前面是数字时，是量词，“打”后面是名词时，是动词。这就是从训练数据中提取的两个特征，可分别用特征函数表示为</p>
</blockquote>
<h1 id="3、经验分布"><a href="#3、经验分布" class="headerlink" title="3、经验分布"></a>3、经验分布</h1><p>经验（概率）分布就是通过对训练集T进行统计得到的分布，用$\tilde p$表示。这里列举两个经验分布</p>
<script type="math/tex; mode=display">
\tilde p(x,y) = \frac {count(x,y)} {N} , \tilde p(x)=\frac {count(x)} {N}</script><p>其中，count表示出现的次数。</p>
<h1 id="4、约束条件"><a href="#4、约束条件" class="headerlink" title="4、约束条件"></a>4、约束条件</h1><p>对于任意一个特征函数f，$E<em>{\tilde p}f$ 表示f在训练数据T上关于$\tilde p(x,y)$的数学期望， $E</em>{p}f$ 表示f在训练数据T上关于$p(x,y)$的数学期望。按照期望的定义，我们有</p>
<script type="math/tex; mode=display">
E_{\tilde p}f=\sum_{x,y}\tilde p(x,y)f(x,y)</script><script type="math/tex; mode=display">
E_{ p}f=\sum_{x,y} p(x,y)f(x,y)</script><p>其中，p(x,y)是未知的，而建模的目标是生成$p(y|x)$，因此，根据Bayes定理，$p(x,y)=p(x)p(y|x)$。在样本数量足够的条件下，$p(x)$可以用$\tilde p(x)$近似表示。这样</p>
<script type="math/tex; mode=display">
E_{ p}f=\sum_{x,y} \tilde p(x)p(y|x)f(x,y)</script><p>对于概率分布$p(y|x)$，我们希望特征f的期望值应该和从训练集中得到的特征期望值是一致的，因此，<strong>增加约束</strong></p>
<script type="math/tex; mode=display">
E_{ p}f=E_{\tilde p}f</script><p>假设我们从训练集中抽取了n个特征，相应的，便有n个特征函数$f_i(i=1,2,…,n)$以及n个约束条件</p>
<script type="math/tex; mode=display">
C_i:E_{ p}(f_i)=E_{\tilde p}(f_i) \tag {3-1}</script><blockquote>
<p>关于约束条件的几何解释</p>
<p><img src="/2017/07/12/机器学习/机器学习笔记-最大熵/最大熵1.png" alt="最大熵1"></p>
<p>（a）：P是所有可能的概率空间，此时没有约束条件，所有的概率模型$p(y|x)$都是允许的；</p>
<p>（b）：增加了一个线性约束条件$C_1$，此时，目标分布$p(y|x)$只能落在由$C_1$定义的线段上；</p>
<p>（c）：在（b）的基础上增加了另一个约束条件$C_2$ ，且$C_1 \cap C_2  \neq \varnothing$。此时，目标分布只能落在交点上，即被唯一确定；</p>
<p>（d）：在（b）基础上增加了另一个约束$C_3$，且$C_1 \cap C_2  = \varnothing$，此时不存在能够同时满足$C_1$和$C_3$的$p(y|x)$。</p>
</blockquote>
<p>利用（3-1）定义的约束条件，我们定义P的一个子空间</p>
<script type="math/tex; mode=display">
C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><h1 id="5、最大熵模型"><a href="#5、最大熵模型" class="headerlink" title="5、最大熵模型"></a>5、最大熵模型</h1><p>由于我们的目标是获得一个条件分布，因此这里也采用相应的条件熵</p>
<script type="math/tex; mode=display">
H(p(y|x))=-\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)</script><p>可以看出这里也是用$\tilde p(x)$来近似$p(x)$。以下将$H(p(y|x))$简记为$H(p)$。至此，可以给出最大熵模型的完整描述。</p>
<p>对于给定的训练集T，特征函数$f_i(x,y), i=1,2,…n$，最大熵模型就是求解</p>
<script type="math/tex; mode=display">
\underset {p \in C} {max} \ \  H(p) = \begin{pmatrix}
-\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)
\end{pmatrix}, \\
s.t. \sum_y p(y|x)=1 \tag {5-1} \\
s.t. \ C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><p>其中的s.t.是为了保证$p(y|x)$是一个（合法的）条件概率分布。</p>
<p>等价于一个求极小值问题</p>
<script type="math/tex; mode=display">
\underset {p \in C} {min} \ \  -H(p) = \begin{pmatrix}
\sum_{x,y} \tilde p(x)p(y|x)\log p(y|x)
\end{pmatrix}, \\
s.t. \sum_y p(y|x)=1 \tag {5-2} \\
s.t. \ C=\{p \in P | E_p(f_i)={\tau}_i, i=1,2,...,n\}</script><h1 id="6、模型求解"><a href="#6、模型求解" class="headerlink" title="6、模型求解"></a>6、模型求解</h1><p>对于5-1的求解，主要思路和步骤如下：</p>
<ol>
<li>利用Lagrange乘子将最大熵模型由一个带约束的最优化问题转为无约束的最优化问题，这是一个<strong>极小极大问题（min max）</strong>。</li>
<li>利用对偶问题等价性，转化为求解上一步得到的极大/极小问题的对偶问题，也是一个极大极小问题。</li>
</ol>
<h2 id="6-1-原始问题和对偶问题"><a href="#6-1-原始问题和对偶问题" class="headerlink" title="6.1 原始问题和对偶问题"></a>6.1 原始问题和对偶问题</h2><p>根据（5-2），引入拉格朗日乘子$\lambda=(\lambda_0,\lambda_1,…,\lambda_n)^T$，定义拉格朗日函数</p>
<script type="math/tex; mode=display">
L(p,\lambda) = -H(p) + \lambda_0(1-\sum_y p(y|x))+\sum_{i=1}^n\lambda_i(\tau_i-E_p(f_i))  \tag{6-1}</script><p>利用对偶性，求解（6-1）的<strong>原始问题</strong>表示为：</p>
<script type="math/tex; mode=display">
\underset {p \in C} {min}\  \underset {\lambda} {max}\ L(p,\lambda) \tag{6-2}</script><p><strong>对偶问题</strong>为：</p>
<script type="math/tex; mode=display">
\underset {\lambda} {max}\ \underset {p \in C} {min}\  L(p,\lambda) \tag{6-3}</script><p>由于$H(p)$是关于p的凸函数，因此要求解最大熵模型，只需求解对偶问题（6-3）即可。</p>
<h3 id="6-1-1-指数形式的解"><a href="#6-1-1-指数形式的解" class="headerlink" title="6.1.1 指数形式的解"></a>6.1.1 指数形式的解</h3><p>首先求解内部的极小问题。由于$\underset {p \in C} {min}\  L(p,\lambda)$是关于$\lambda$的函数，将其记做：</p>
<script type="math/tex; mode=display">
\Psi (\lambda) =\underset {p \in C} {min}\  L(p,\lambda) = L(p_{\lambda}, \lambda) \tag {6-4}</script><p>其中</p>
<script type="math/tex; mode=display">
p_{\lambda}=\underset {p \in C} {argmin}\ L(p,\lambda)=p_{\lambda}(y|x) \tag {6-5}</script><p>根据拉格朗日乘子法，求$L(p,\lambda)$对$p(y|x)$的偏导，得（求解过程略）：</p>
<script type="math/tex; mode=display">
p_{\lambda}=\frac {1} {Z_{\lambda}(x)} \ \exp(\sum_{i=1}^n \lambda_i f_i(x,y)) \tag{6-6}</script><p>其中，</p>
<script type="math/tex; mode=display">
Z_{\lambda}(x)=\sum_y \exp(\sum_{i=1}^n \lambda_i f_i(x,y)) \tag{6-7}</script><p>称为<strong>规范化因子</strong>（normalizing factor）。注意，此时已经没有$\lambda_0$了。</p>
<p>由（6-6）定义的$p_{\lambda}$就是最大熵模型的解，它具有<strong>指数形式</strong>。其中，$\lambda_i$就是特征$f_i$的权重，越大表示特征越重要。</p>
<h3 id="6-1-2-最大似然估计"><a href="#6-1-2-最大似然估计" class="headerlink" title="6.1.2 最大似然估计"></a>6.1.2 最大似然估计</h3><p>得到对偶问题的内层极小值问题的解之后，接着求解外层的极大值问题$\underset {\lambda} {max} \ \Psi(\lambda)$。</p>
<p>设其解为</p>
<script type="math/tex; mode=display">
\lambda^* = \underset {\lambda} {argmax} \ \Psi(\lambda) \tag{6-8}</script><p>则最大熵模型的解为</p>
<script type="math/tex; mode=display">
p^*=p_{\lambda^*} \tag{6-9}</script><p>根据推导，最大化$\Psi(\lambda)$与最大似然估计是等价的！</p>
<h1 id="7、最优化方法"><a href="#7、最优化方法" class="headerlink" title="7、最优化方法"></a>7、最优化方法</h1><p>通用的方法有梯度下降，拟牛顿法等，最大熵模型有两个量身定做的方法：通用迭代尺度法（Generalized Iterative Scaling，GIS）和改进的迭代尺度法（Impoved Iterative Scaling，IIS）。</p>
<h2 id="7-1-GIS算法"><a href="#7-1-GIS算法" class="headerlink" title="7.1 GIS算法"></a>7.1 GIS算法</h2><blockquote>
<p>算法1：</p>
<p>S1：初始化参数，令$\lambda=0$</p>
<p>S2：计算$E_{\tilde p}(f_i),\ i=1,2,…,n$</p>
<p>S3：执行一次迭代，对参数做一次刷新。</p>
<p>​    计算$E<em>{p</em>{\lambda}}(f_i)$</p>
<p>​    FOR i=1,2,…,n DO {</p>
<p>​        $\lambda<em>i\  += \ \eta \log\frac {E</em>{\tilde p}(f<em>i)} {E</em>{p_{\lambda}}(f_i)}$</p>
<p>​    }</p>
<p>S4：检查是否收敛，若未收敛则继续S3</p>
</blockquote>
<p>其中，$\eta$是学习率，在实际中取$\frac {1} {C}$，$$，表示训练数据中包含特征最多的那个样本所包含的特征个数。</p>
<script type="math/tex; mode=display">
\Delta\lambda_i=\eta \log\frac {E_{\tilde p}(f_i)} {E_{p_{\lambda}}(f_i)}</script><p>是校正量。</p>
<p>每次迭代，先用当前的权重估算每个特征$f<em>i$在训练数据中的概率分布的期望，然后逐个与相应的经验分布的期望比较，其偏差程度通过$\log\frac {E</em>{\tilde p}(f<em>i)} {E</em>{p_{\lambda}}(f_i)}$来进行刻画。</p>
<p>收敛条件就是当两次迭代的$\lambda$在一个较小的范围。</p>
<p>GIS每次迭代时间很长，不太稳定，容易溢出，一般不会使用。</p>
<h2 id="7-2-IIS算法"><a href="#7-2-IIS算法" class="headerlink" title="7.2 IIS算法"></a>7.2 IIS算法</h2><p>与GIS的不同主要在$\Delta\lambda_i$的计算上。IIS通过求解方程</p>
<script type="math/tex; mode=display">
\sum_{x,y} \tilde p(x)p(y|x)f_i(x,y)\exp(\Delta\lambda_i\sum_{i=1}^nf_i(x,y))=\tilde p(f_i)</script><p>1）若$\sum<em>{i=1}^nf_i(x,y)$为常数，即对任意样本(x,y)，都有$\sum</em>{i=1}^nf_i(x,y)=C$，则</p>
<script type="math/tex; mode=display">
\Delta\lambda_i=\frac {1} {C} \log\frac {E_{\tilde p}(f_i)} {E_{p_{\lambda}}(f_i)}</script><p>此时，IIS可以看做是GIS的一种推广。</p>
<p>2）若$\sum_{i=1}^nf_i(x,y)$不是常数，则需要通过数值方式来求解$\Delta\lambda_i$，如牛顿法。</p>
<h1 id="8、优缺点"><a href="#8、优缺点" class="headerlink" title="8、优缺点"></a>8、优缺点</h1><p>优点是：在建模时，只需要集中精力选取特征，不需要花费精力考虑如何使用这些特征，可以灵活使用不同类型的特征。</p>
<p>缺点是计算量大。</p>
<p>参考</p>
<p>【1】 <a href="http://blog.csdn.net/itplus/article/details/26550273" target="_blank" rel="noopener">最大熵学习笔记</a></p>
<p>【2】统计学习方法</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/工具和环境/scp免密码登录/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/工具和环境/scp免密码登录/" class="post-title-link" itemprop="url">scp免密码登录</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-01-30 16:38:16" itemprop="dateModified" datetime="2018-01-30T16:38:16+08:00">2018-01-30</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具和环境/" itemprop="url" rel="index"><span itemprop="name">工具和环境</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/工具和环境/scp免密码登录/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/工具和环境/scp免密码登录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>假设A要免密码传输文件到B</p>
<p>在A上创建秘钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa</div></pre></td></tr></table></figure>
<p>拷贝id_rsa.pub到B的.ssh，并改名为authorized_keys</p>
<p>注意要修改权限</p>
<p>A机器</p>
<p>.ssh目录，以及/home/当前用户 需要700权限，参考以下操作调整</p>
<p>sudo chmod 700 ~/.ssh</p>
<p>sudo chmod 700 /home/当前用户</p>
<p>B机器</p>
<p>.ssh目录下的authorized_keys文件需要600或644权限，参考以下操作调整</p>
<p>sudo chmod 600 ~/.ssh/authorized_keys</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/Elastic Search/Elastic Search配置和使用/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/Elastic Search/Elastic Search配置和使用/" class="post-title-link" itemprop="url">Elastic Search 配置和使用</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Elastic-Search/" itemprop="url" rel="index"><span itemprop="name">Elastic Search</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/Elastic Search/Elastic Search配置和使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/Elastic Search/Elastic Search配置和使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官网：<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/products/elasticsearch</a>    </p>
<p>最好的教程：<a href="https://es.xiaoleilu.com/" target="_blank" rel="noopener">https://es.xiaoleilu.com/</a></p>
<p>docker的ELK环境：<a href="https://hub.docker.com/r/sebp/elk/" target="_blank" rel="noopener">https://hub.docker.com/r/sebp/elk/</a></p>
<p>ES 5.4中文文档   <a href="http://cwiki.apachecn.org/pages/viewpage.action?pageId=4260364" target="_blank" rel="noopener">http://cwiki.apachecn.org/pages/viewpage.action?pageId=4260364</a></p>
<h1 id="0、基本概念"><a href="#0、基本概念" class="headerlink" title="0、基本概念"></a>0、基本概念</h1><p><strong>接近实时（NRT）</strong></p>
<pre><code>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒）。
</code></pre><p><strong>集群（cluster）</strong><br>    一个集群就是由一个或多个节点组织在一起，它们共同持有你整个的数据，并一起提供索引和搜索功能。一个集群一个唯一的名字标识，这个名字默认就是 “elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。在产品环境中显式地设定这个名字是一个好 习惯，但是使用默认值来进行测试/开发也是不错的。</p>
<p><strong>节点（node）</strong><br>    一个节点是你集群中的一个服务器，作为集群的一部分，它存储你的数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况 下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网 络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p>
<pre><code>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意 味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。

在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</div><div class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</div></pre></td></tr></table></figure>
<p><strong>索引（index）</strong></p>
<pre><code>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名 字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。

在一个集群中，如果你想，可以定义任意多的索引。
</code></pre><p><strong>类型（type）</strong></p>
<pre><code>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个 类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类 型，当然，也可以为评论数据定义另一个类型。
</code></pre><p><strong>文档（document）</strong></p>
<pre><code>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。

在一个index/type里面，只要你想，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。
</code></pre><p><strong>分片和复制（shards &amp; replicas）</strong></p>
<pre><code>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。

为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。

分片之所以重要，主要有两方面的原因：

    - 允许你水平分割/扩展你的内容容量
    - 允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量

至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。

在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非 常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。

复制之所以重要，有两个主要原因：
    - 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。
    - 扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行

总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和 复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变 分片的数量。

默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。
</code></pre><h1 id="1、安装-5-5-0"><a href="#1、安装-5-5-0" class="headerlink" title="1、安装-5.5.0"></a>1、安装-5.5.0</h1><h2 id="1-1-ElasticSearch"><a href="#1-1-ElasticSearch" class="headerlink" title="1.1 ElasticSearch"></a>1.1 ElasticSearch</h2><p>下载的</p>
<p>elasticsearch-5.5.0.tar.gz</p>
<p>kibana-5.5.0-linux-x86_64.tar.gz</p>
<p>解压到/home/david/opt，在主目录直接运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch</div></pre></td></tr></table></figure>
<p>启动服务，启动后，访问localhost:9200，若出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;Jr1It8C&quot;,</div><div class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</div><div class="line">  &quot;cluster_uuid&quot; : &quot;JMo_h3-USdegKS1yZ0WCnA&quot;,</div><div class="line">  &quot;version&quot; : &#123;</div><div class="line">    &quot;number&quot; : &quot;5.5.0&quot;,</div><div class="line">    &quot;build_hash&quot; : &quot;260387d&quot;,</div><div class="line">    &quot;build_date&quot; : &quot;2017-06-30T23:16:05.735Z&quot;,</div><div class="line">    &quot;build_snapshot&quot; : false,</div><div class="line">    &quot;lucene_version&quot; : &quot;6.6.0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>则说明安装成功。</p>
<h2 id="1-2-Marvel"><a href="#1-2-Marvel" class="headerlink" title="1.2 Marvel"></a>1.2 Marvel</h2><p>5.0后集成到了x-pack中</p>
<p>1）安装X-pack到elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/elasticsearch-plugin install x-pack</div></pre></td></tr></table></figure>
<p>2）安装到kibana</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kibana-plugin install x-pack</div></pre></td></tr></table></figure>
<p>用户名elastic</p>
<p>密码changeme</p>
<h2 id="1-3-关闭服务"><a href="#1-3-关闭服务" class="headerlink" title="1.3 关闭服务"></a>1.3 关闭服务</h2><p>关闭Elastic search </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep elastic</div></pre></td></tr></table></figure>
<p>关闭kibana </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fuser -n tcp 5601</div></pre></td></tr></table></figure>
<h1 id="2、第一个例子"><a href="#2、第一个例子" class="headerlink" title="2、第一个例子"></a>2、第一个例子</h1><p>摘自教程</p>
<blockquote>
<p>假设我们刚好在<strong>Megacorp</strong>工作，这时人力资源部门出于某种目的需要让我们创建一个员工目录，这个目录用于促进人文关怀和用于实时协同工作，所以它有以下不同的需求：</p>
<ul>
<li>数据能够包含多个值的标签、数字和纯文本。</li>
<li>检索任何员工的所有信息。</li>
<li>支持结构化搜索，例如查找30岁以上的员工。</li>
<li>支持简单的全文搜索和更复杂的<strong>短语(phrase)</strong>搜索</li>
<li>高亮搜索结果中的关键字</li>
<li>能够利用图表管理分析这些数据</li>
</ul>
</blockquote>
<h2 id="2-1-索引员工文档"><a href="#2-1-索引员工文档" class="headerlink" title="2.1 索引员工文档"></a>2.1 索引员工文档</h2><p><strong>索引</strong>含义的区分</p>
<p>你可能已经注意到<strong>索引(index)</strong>这个词在Elasticsearch中有着不同的含义，所以有必要在此做一下区分:</p>
<ul>
<li>索引（名词） 如上文所述，一个<strong>索引(index)</strong>就像是传统关系数据库中的<strong>数据库</strong>，它是相关文档存储的地方，index的复数是<strong>indices </strong>或<strong>indexes</strong>。</li>
<li>索引（动词） <strong>「索引一个文档」</strong>表示把一个文档存储到<strong>索引（名词）</strong>里，以便它可以被检索或者查询。这很像SQL中的<code>INSERT</code>关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。</li>
<li>倒排索引 传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做<strong>倒排索引(inverted index)</strong>的数据结构来达到相同目的。</li>
</ul>
<p>创建一个员工目录</p>
<ul>
<li>每个文档的类型为<code>employee</code>。</li>
<li><code>employee</code>类型归属于索引<code>megacorp</code>。</li>
<li><code>megacorp</code>索引存储在Elasticsearch集群中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">PUT /megacorp/employee/1</div><div class="line">&#123;</div><div class="line">    &quot;first_name&quot; : &quot;John&quot;,</div><div class="line">    &quot;last_name&quot; :  &quot;Smith&quot;,</div><div class="line">    &quot;age&quot; :        25,</div><div class="line">    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,</div><div class="line">    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">PUT /megacorp/employee/2</div><div class="line">&#123;</div><div class="line">    &quot;first_name&quot; :  &quot;Jane&quot;,</div><div class="line">    &quot;last_name&quot; :   &quot;Smith&quot;,</div><div class="line">    &quot;age&quot; :         32,</div><div class="line">    &quot;about&quot; :       &quot;I like to collect rock albums&quot;,</div><div class="line">    &quot;interests&quot;:  [ &quot;music&quot; ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">PUT /megacorp/employee/3</div><div class="line">&#123;</div><div class="line">    &quot;first_name&quot; :  &quot;Douglas&quot;,</div><div class="line">    &quot;last_name&quot; :   &quot;Fir&quot;,</div><div class="line">    &quot;age&quot; :         35,</div><div class="line">    &quot;about&quot;:        &quot;I like to build cabinets&quot;,</div><div class="line">    &quot;interests&quot;:  [ &quot;forestry&quot; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-2-检索文档"><a href="#2-2-检索文档" class="headerlink" title="2.2 检索文档"></a>2.2 检索文档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/1</div></pre></td></tr></table></figure>
<p>响应的内容中包含一些文档的元信息，John Smith的原始JSON文档包含在<code>_source</code>字段中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   &quot;_index&quot;: &quot;megacorp&quot;,</div><div class="line">   &quot;_type&quot;: &quot;employee&quot;,</div><div class="line">   &quot;_id&quot;: &quot;1&quot;,</div><div class="line">   &quot;_version&quot;: 1,</div><div class="line">   &quot;found&quot;: true,</div><div class="line">   &quot;_source&quot;: &#123;</div><div class="line">      &quot;first_name&quot;: &quot;John&quot;,</div><div class="line">      &quot;last_name&quot;: &quot;Smith&quot;,</div><div class="line">      &quot;age&quot;: 25,</div><div class="line">      &quot;about&quot;: &quot;I love to go rock climbing&quot;,</div><div class="line">      &quot;interests&quot;: [</div><div class="line">         &quot;sports&quot;,</div><div class="line">         &quot;music&quot;</div><div class="line">      ]</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>简单搜索</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div></pre></td></tr></table></figure>
<p>使用关键字<code>_search</code>来取代原来的文档ID。响应内容的<code>hits</code>数组中包含了我们所有的三个文档。默认情况下搜索会返回前10个结果。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="attr">"took"</span>: <span class="number">6</span>,</div><div class="line">   <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</div><div class="line">   <span class="attr">"_shards"</span>: &#123;</div><div class="line">      <span class="attr">"total"</span>: <span class="number">5</span>,</div><div class="line">      <span class="attr">"successful"</span>: <span class="number">5</span>,</div><div class="line">      <span class="attr">"failed"</span>: <span class="number">0</span></div><div class="line">   &#125;,</div><div class="line">   <span class="attr">"hits"</span>: &#123;</div><div class="line">      <span class="attr">"total"</span>: <span class="number">3</span>,</div><div class="line">      <span class="attr">"max_score"</span>: <span class="number">1</span>,</div><div class="line">      <span class="attr">"hits"</span>: [</div><div class="line">         &#123;</div><div class="line">            <span class="attr">"_index"</span>: <span class="string">"megacorp"</span>,</div><div class="line">            <span class="attr">"_type"</span>: <span class="string">"employee"</span>,</div><div class="line">            <span class="attr">"_id"</span>: <span class="string">"2"</span>,</div><div class="line">            <span class="attr">"_score"</span>: <span class="number">1</span>,</div><div class="line">            <span class="attr">"_source"</span>: &#123;</div><div class="line">               <span class="attr">"first_name"</span>: <span class="string">"Jane"</span>,</div><div class="line">               <span class="attr">"last_name"</span>: <span class="string">"Smith"</span>,</div><div class="line">               <span class="attr">"age"</span>: <span class="number">32</span>,</div><div class="line">               <span class="attr">"about"</span>: <span class="string">"I like to collect rock albums"</span>,</div><div class="line">               <span class="attr">"interests"</span>: [</div><div class="line">                  <span class="string">"music"</span></div><div class="line">               ]</div><div class="line">            &#125;</div><div class="line">         &#125;,</div><div class="line">         ......        </div><div class="line">      ]</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，让我们搜索姓氏中包含<strong>“Smith”</strong>的员工。要做到这一点，我们将在命令行中使用轻量级的搜索方法。这种方法常被称作<strong>查询字符串(query string)</strong>搜索，因为我们像传递URL参数一样去传递查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search?q=last_name:Smith</div></pre></td></tr></table></figure>
<h2 id="2-3-使用DSL语句查询"><a href="#2-3-使用DSL语句查询" class="headerlink" title="2.3 使用DSL语句查询"></a>2.3 使用DSL语句查询</h2><p>查询字符串搜索便于通过命令行完成<strong>特定(ad hoc)</strong>的搜索，但是它也有局限性（参阅简单搜索章节）。Elasticsearch提供丰富且灵活的查询语言叫做<strong>DSL查询(Query DSL)</strong>,它允许你构建更加复杂、强大的查询。</p>
<p><strong>DSL(Domain Specific Language特定领域语言)</strong>以JSON请求体的形式出现。我们可以这样表示之前关于“Smith”的查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;match&quot; : &#123;</div><div class="line">            &quot;last_name&quot; : &quot;Smith&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-4-更复杂的搜索"><a href="#2-4-更复杂的搜索" class="headerlink" title="2.4 更复杂的搜索"></a>2.4 更复杂的搜索</h2><p>我们让搜索稍微再变的复杂一些。我们依旧想要找到姓氏为“Smith”的员工，但是我们只想得到年龄大于30岁的员工。我们的语句将添加<strong>过滤器(filter)</strong>,它使得我们高效率的执行一个结构化搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">GET /megacorp/employee/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot; : &#123;</div><div class="line">        &quot;filtered&quot; : &#123;</div><div class="line">            &quot;filter&quot; : &#123;</div><div class="line">                &quot;range&quot; : &#123;</div><div class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; &lt;1&gt;</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &quot;query&quot; : &#123;</div><div class="line">                &quot;match&quot; : &#123;</div><div class="line">                    &quot;last_name&quot; : &quot;smith&quot; &lt;2&gt;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.0以后的DSL语法变了</p>
<h1 id="3、数据"><a href="#3、数据" class="headerlink" title="3、数据"></a>3、数据</h1><h2 id="3-1-文档"><a href="#3-1-文档" class="headerlink" title="3.1 文档"></a>3.1 文档</h2><p>一个文档不只有数据。它还包含了<strong>元数据(metadata)</strong>——<strong>关于</strong>文档的信息。三个必须的元数据节点是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>节点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_index</code></td>
<td>文档存储的地方</td>
</tr>
<tr>
<td><code>_type</code></td>
<td>文档代表的对象的类</td>
</tr>
<tr>
<td><code>_id</code></td>
<td>文档的唯一标识</td>
</tr>
</tbody>
</table>
</div>
<h3 id="index"><a href="#index" class="headerlink" title="_index"></a><code>_index</code></h3><p><strong>索引(index)</strong>类似于关系型数据库里的“数据库”——它是我们存储和索引关联数据的地方。</p>
<blockquote>
<p>提示：</p>
<p>事实上，我们的数据被存储和索引在<strong>分片(shards)</strong>中，索引只是一个把一个或多个分片分组在一起的逻辑空间。然而，这只是一些内部细节——我们的程序完全不用关心分片。对于我们的程序而言，文档存储在<strong>索引(index)</strong>中。剩下的细节由Elasticsearch关心既可。</p>
</blockquote>
<p>我们将会在《索引管理》章节中探讨如何创建并管理索引，但现在，我们将让Elasticsearch为我们创建索引。我们唯一需要做的仅仅是选择一个索引名。这个名字必须是全部小写，不能以下划线开头，不能包含逗号。让我们使用<code>website</code>做为索引名。</p>
<h3 id="type"><a href="#type" class="headerlink" title="_type"></a><code>_type</code></h3><p>在应用中，我们使用对象表示一些“事物”，例如一个用户、一篇博客、一个评论，或者一封邮件。每个对象都属于一个<strong>类(class)</strong>，这个类定义了属性或与对象关联的数据。<code>user</code>类的对象可能包含姓名、性别、年龄和Email地址。</p>
<p>在关系型数据库中，我们经常将相同类的对象存储在一个表里，因为它们有着相同的结构。同理，在Elasticsearch中，我们使用相同<strong>类型(type)</strong>的文档表示相同的“事物”，因为他们的数据结构也是相同的。</p>
<p>每个<strong>类型(type)</strong>都有自己的<strong>映射(mapping)</strong>或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的<strong>映射(mapping)</strong>会告诉Elasticsearch不同的文档如何被索引。 我们将会在《映射》章节探讨如何定义和管理映射，但是现在我们将依赖Elasticsearch去自动处理数据结构。</p>
<p><code>_type</code>的名字可以是大写或小写，不能包含下划线或逗号。我们将使用<code>blog</code>做为类型名。</p>
<h3 id="id"><a href="#id" class="headerlink" title="_id"></a><code>_id</code></h3><p><strong>id</strong>仅仅是一个字符串，它与<code>_index</code>和<code>_type</code>组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，你可以自定义<code>_id</code>，也可以让Elasticsearch帮你自动生成。</p>
<h2 id="3-2-索引一个文档"><a href="#3-2-索引一个文档" class="headerlink" title="3.2 索引一个文档"></a>3.2 索引一个文档</h2><h3 id="自定义ID"><a href="#自定义ID" class="headerlink" title="自定义ID"></a><strong>自定义ID</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/123</div><div class="line">&#123;</div><div class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</div><div class="line">  &quot;text&quot;:  &quot;Just trying this out...&quot;,</div><div class="line">  &quot;date&quot;:  &quot;2014/01/01&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Elasticsearch的响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   &quot;_index&quot;: &quot;website&quot;,</div><div class="line">   &quot;_type&quot;: &quot;blog&quot;,</div><div class="line">   &quot;_id&quot;: &quot;123&quot;,</div><div class="line">   &quot;_version&quot;: 1,</div><div class="line">   &quot;result&quot;: &quot;created&quot;,</div><div class="line">   &quot;_shards&quot;: &#123;</div><div class="line">      &quot;total&quot;: 2,</div><div class="line">      &quot;successful&quot;: 1,</div><div class="line">      &quot;failed&quot;: 0</div><div class="line">   &#125;,</div><div class="line">   &quot;created&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_version</code> ：Elasticsearch中每个文档都有版本号，每当文档变化（包括删除）都会使<code>_version</code>增加。</p>
<h3 id="自增ID"><a href="#自增ID" class="headerlink" title="自增ID"></a>自增ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">POST /website/blog/</div><div class="line">&#123;</div><div class="line">  &quot;title&quot;: &quot;My second blog entry&quot;,</div><div class="line">  &quot;text&quot;:  &quot;Still trying this out...&quot;,</div><div class="line">  &quot;date&quot;:  &quot;2014/01/01&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自动生成的ID有22个字符长，URL-safe, Base64-encoded string universally unique identifiers, 或者叫 <a href="http://en.wikipedia.org/wiki/Uuid" target="_blank" rel="noopener">UUIDs</a>。</p>
<h2 id="3-3-检索"><a href="#3-3-检索" class="headerlink" title="3.3 检索"></a>3.3 检索</h2><p>想要从Elasticsearch中获取文档，我们使用同样的<code>_index</code>、<code>_type</code>、<code>_id</code>，但是HTTP方法改为<code>GET</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /website/blog/123?pretty</div></pre></td></tr></table></figure>
<blockquote>
<h3 id="pretty"><a href="#pretty" class="headerlink" title="pretty"></a><code>pretty</code></h3><p>在任意的查询字符串中增加<code>pretty</code>参数，类似于上面的例子。会让Elasticsearch<strong>美化输出(pretty-print)</strong>JSON响应以便更加容易阅读。<code>_source</code>字段不会被美化，它的样子与我们输入的一致。</p>
</blockquote>
<p><code>{&quot;found&quot;: true}</code>。这意味着文档已经找到。</p>
<p>如果我们请求一个不存在的文档，依旧会得到一个JSON，不过<code>found</code>值变成了<code>false</code>。</p>
<p>此外，HTTP响应状态码也会变成<code>&#39;404 Not Found&#39;</code>代替<code>&#39;200 OK&#39;</code>。我们可以在<code>curl</code>后加<code>-i</code>参数得到响应头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -i -XGET http://localhost:9200/website/blog/124?pretty</div></pre></td></tr></table></figure>
<h3 id="检索文档的一部分"><a href="#检索文档的一部分" class="headerlink" title="检索文档的一部分"></a>检索文档的一部分</h3><p>通常，<code>GET</code>请求将返回文档的全部，存储在<code>_source</code>参数中。但是可能你感兴趣的字段只是<code>title</code>。请求个别字段可以使用<code>_source</code>参数。多个字段可以使用逗号分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /website/blog/123?_source=title,text</div></pre></td></tr></table></figure>
<p>或者你只想得到<code>_source</code>字段而不要其他的元数据，你可以这样请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /website/blog/123/_source</div></pre></td></tr></table></figure>
<h2 id="3-4-更新整个文档"><a href="#3-4-更新整个文档" class="headerlink" title="3.4 更新整个文档"></a>3.4 更新整个文档</h2><p>文档在Elasticsearch中是不可变的——我们不能修改他们。如果需要更新已存在的文档，我们可以使用《索引文档》章节提到的<code>index</code> API <em>重建索引(reindex)</em> 或者替换掉它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/123</div><div class="line">&#123;</div><div class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</div><div class="line">  &quot;text&quot;:  &quot;I am starting to get the hang of this...&quot;,</div><div class="line">  &quot;date&quot;:  &quot;2014/01/02&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在响应中，我们可以看到Elasticsearch把<code>_version</code>增加了，且<code>result</code>是updated</p>
<p><code>update</code> API。这个API <em>似乎</em> 允许你修改文档的局部，但事实上Elasticsearch遵循与之前所说完全相同的过程，这个过程如下：</p>
<ol>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档</li>
</ol>
<p>唯一的不同是<code>update</code> API完成这一过程只需要一个客户端请求既可，不再需要<code>get</code>和<code>index</code>请求了。</p>
<h2 id="3-5-创建新文档"><a href="#3-5-创建新文档" class="headerlink" title="3.5 创建新文档"></a>3.5 创建新文档</h2><p>请记住<code>_index</code>、<code>_type</code>、<code>_id</code>三者唯一确定一个文档。所以要想保证文档是新加入的，最简单的方式是使用<code>POST</code>方法让Elasticsearch自动生成唯一<code>_id</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">POST /website/blog/</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果要确保是create操作</p>
<p>1）使用<code>op_type</code>查询参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/123?op_type=create</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>2）在URL后加<code>/_create</code>做为端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PUT /website/blog/123/_create</div><div class="line">&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>如果包含相同的<code>_index</code>、<code>_type</code>和<code>_id</code>的文档已经存在，Elasticsearch将返回<code>409 Conflict</code>响应状态码</p>
<h2 id="3-6-删除文档"><a href="#3-6-删除文档" class="headerlink" title="3.6 删除文档"></a>3.6 删除文档</h2><p>使用<code>DELETE</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE /website/blog/123</div></pre></td></tr></table></figure>
<blockquote>
<p>删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch将会在你之后添加更多索引的时候才会在后台进行删除内容的清理。</p>
</blockquote>
<h2 id="3-7-Mapping"><a href="#3-7-Mapping" class="headerlink" title="3.7 Mapping"></a>3.7 Mapping</h2><p><a href="http://m635674608.iteye.com/blog/2259804" target="_blank" rel="noopener">ElasticSearch的Mapping之字段类型</a></p>
<p>（一）核心数据类型： </p>
<p>（1）string： 默认会被分词，一个完整示例如下 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&quot;status&quot;: &#123;  </div><div class="line">         &quot;type&quot;:  &quot;string&quot;, //字符串类型  </div><div class="line">         &quot;index&quot;: &quot;analyzed&quot;//分词，不分词是：not_analyzed ，设置成no，字段将不会被索引  </div><div class="line">         &quot;analyzer&quot;:&quot;ik&quot;//指定分词器  </div><div class="line">         &quot;boost&quot;:1.23//字段级别的分数加权  </div><div class="line">          &quot;doc_values&quot;:false//对not_analyzed字段，默认都是开启，分词字段不能使用，对排序和聚合能提升较大性能，节约内存  </div><div class="line">           &quot;fielddata&quot;:&#123;&quot;format&quot;:&quot;disabled&quot;&#125;//针对分词字段，参与排序或聚合时能提高性能，不分词字段统一建议使用doc_value  </div><div class="line">           &quot;fields&quot;:&#123;&quot;raw&quot;:&#123;&quot;type&quot;:&quot;string&quot;,&quot;index&quot;:&quot;not_analyzed&quot;&#125;&#125; //可以对一个字段提供多种索引模式，同一个字段的值，一个分词，一个不分词  </div><div class="line">           &quot;ignore_above&quot;:100 //超过100个字符的文本，将会被忽略，不被索引  </div><div class="line">           &quot;include_in_all&quot;:ture//设置是否此字段包含在_all字段中，默认是true，除非index设置成no选项  </div><div class="line">           &quot;index_options&quot;:&quot;docs&quot;//4个可选参数docs（索引文档号） ,freqs（文档号+词频），positions（文档号+词频+位置，通常用来距离查询），offsets（文档号+词频+位置+偏移量，通常被使用在高亮字段）分词字段默认是position，其他的默认是docs  </div><div class="line">           &quot;norms&quot;:&#123;&quot;enable&quot;:true,&quot;loading&quot;:&quot;lazy&quot;&#125;//分词字段默认配置，不分词字段：默认&#123;&quot;enable&quot;:false&#125;，存储长度因子和索引时boost，建议对需要参与评分字段使用 ，会额外增加内存消耗量  </div><div class="line">            &quot;null_value&quot;:&quot;NULL&quot;//设置一些缺失字段的初始化值，只有string可以使用，分词字段的null值也会被分词  </div><div class="line">            &quot;position_increament_gap&quot;:0//影响距离查询或近似查询，可以设置在多值字段的数据上火分词字段上，查询时可指定slop间隔，默认值是100  </div><div class="line">             &quot;store&quot;:false//是否单独设置此字段的是否存储而从_source字段中分离，默认是false，只能搜索，不能获取值  </div><div class="line">              &quot;search_analyzer&quot;:&quot;ik&quot;//设置搜索时的分词器，默认跟ananlyzer是一致的，比如index时用standard+ngram，搜索时用standard用来完成自动提示功能  </div><div class="line">               &quot;similarity&quot;:&quot;BM25&quot;//默认是TF/IDF算法，指定一个字段评分策略，仅仅对字符串型和分词类型有效  </div><div class="line">               &quot;term_vector&quot;:&quot;no&quot;//默认不存储向量信息，支持参数yes（term存储），with_positions（term+位置）,with_offsets（term+偏移量），with_positions_offsets(term+位置+偏移量) 对快速高亮fast vector highlighter能提升性能，但开启又会加大索引体积，不适合大数据量用  </div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<h1 id="4、结构化查询DSL"><a href="#4、结构化查询DSL" class="headerlink" title="4、结构化查询DSL"></a>4、结构化查询DSL</h1><p>match 相当于and</p>
<p>should 相当于or</p>
<p>must_not 相当于not</p>
<h2 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h2><p>精确查询</p>
<h2 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html</a></p>
<p>match查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;: &#123;</div><div class="line">        &quot;match&quot; : &#123;</div><div class="line">            &quot;message&quot; : &quot;this is a test&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>判断某个字段不为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;filter&quot;: [</div><div class="line">        &#123; &quot;script&quot;:&#123;&quot;script&quot;:&quot;doc[&apos;interests&apos;].values.length==60&quot;&#125; &#125;  </div><div class="line">      ]</div></pre></td></tr></table></figure>
<h2 id="should"><a href="#should" class="headerlink" title="should"></a>should</h2><h1 id="5、聚合统计"><a href="#5、聚合统计" class="headerlink" title="5、聚合统计"></a>5、聚合统计</h1><h2 id="对查询的结果聚合"><a href="#对查询的结果聚合" class="headerlink" title="对查询的结果聚合"></a>对查询的结果聚合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">GET iclick_persona/iclick/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; </div><div class="line">    &quot;bool&quot;: &#123; </div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;articles.domains&quot;:   &quot;www.baby-kingdom.com&quot;        &#125;&#125;, </div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;province&quot;: &quot;HK&quot; &#125;&#125;,</div><div class="line">        &#123;&quot;match&quot;: &#123;&quot;interests&quot;: &quot;20&quot;&#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;interests&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;&quot;field&quot;: &quot;interests&quot;,</div><div class="line">        &quot;size&quot;: 50</div><div class="line">      &#125; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>统计月活跃度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">GET iclick_persona/iclick/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; </div><div class="line">    &quot;bool&quot;: &#123; </div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;articles.domains&quot;:   &quot;www.baby-kingdom.com&quot; &#125;&#125;, </div><div class="line">        &#123; &quot;term&quot;: &#123; &quot;province&quot;: &quot;HK&quot; &#125;&#125;</div><div class="line">      ],</div><div class="line">      &quot;filter&quot;: &#123;</div><div class="line">        &quot;range&quot;: &#123;</div><div class="line">          &quot;create_time&quot;: &#123;&quot;gte&quot; : &quot;2017-08-10&quot;&#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;create_time&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;&quot;field&quot;: &quot;create_time&quot;,&quot;size&quot;: 50,&quot;order&quot;: &#123;</div><div class="line">        &quot;_term&quot;: &quot;asc&quot;</div><div class="line">      &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看香港的人群每天有多少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">GET iclick_persona/iclick/_search?size=0</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123; </div><div class="line">    &quot;bool&quot;: &#123; </div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123; &quot;match&quot;: &#123; &quot;province&quot;: &quot;HK&quot; &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;dates&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;create_time&quot;,</div><div class="line">        &quot;size&quot;: 100,</div><div class="line">        &quot;order&quot;: &#123;</div><div class="line">          &quot;_term&quot;: &quot;asc&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>按条件删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">POST iclick_persona/iclick/_delete_by_query</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123;</div><div class="line">          &quot;term&quot;: &#123;</div><div class="line">            &quot;create_time&quot;: &#123;</div><div class="line">              &quot;value&quot;: &quot;2017-07-15&quot;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          &quot;term&quot;: &#123;</div><div class="line">            &quot;province&quot;: &#123;</div><div class="line">              &quot;value&quot;: &quot;HK&quot;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="keyword和text区别"><a href="#keyword和text区别" class="headerlink" title="keyword和text区别"></a>keyword和text区别</h1><p><a href="http://blog.csdn.net/lionel_fengj/article/details/78367570" target="_blank" rel="noopener">[ElasticSearch]数据类型keyword和text的区别</a></p>
<p>在 ES2.x 版本字符串数据是没有 keyword 和 text 类型的，只有string类型，ES更新到5版本后，取消了 string 数据类型，代替它的是 keyword 和 text 数据类型。</p>
<p>Text 数据类型被用来索引长文本，比如说电子邮件的主体部分或者一款产品的介绍。这些文本会被分析，在建立索引前会将这些文本进行分词，转化为词的组合，建立索引。允许 ES来检索这些词语。text 数据类型不能用来排序和聚合。</p>
<p>Keyword不需要进行分词。可以被用来检索过滤、排序和聚合。keyword 类型字段只能用本身来进行检索。</p>
<p>默认是text类型。</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>最简单的一个match例子：</p>
<p>查询和”我的宝马多少马力”这个查询语句匹配的文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;match&quot;: &#123;</div><div class="line">        &quot;content&quot; : &#123;</div><div class="line">            &quot;query&quot; : &quot;我的宝马多少马力&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的查询匹配就会进行分词，比如”宝马多少马力”会被分词为”宝马 多少 马力”, 所有有关”宝马 多少 马力”, 那么所有包含这三个词中的一个或多个的文档就会被搜索出来。<br>并且根据lucene的评分机制(TF/IDF)来进行评分。</p>
<h2 id="match-phrase"><a href="#match-phrase" class="headerlink" title="match_phrase"></a>match_phrase</h2><p>比如上面一个例子，一个文档”我的保时捷马力不错”也会被搜索出来，那么想要精确匹配所有同时包含”宝马 多少 马力”的文档怎么做？就要使用 match_phrase 了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;match_phrase&quot;: &#123;</div><div class="line">        &quot;content&quot; : &#123;</div><div class="line">            &quot;query&quot; : &quot;我的宝马多少马力&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完全匹配可能比较严，我们会希望有个可调节因子，少匹配一个也满足，那就需要使用到slop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;match_phrase&quot;: &#123;</div><div class="line">        &quot;content&quot; : &#123;</div><div class="line">            &quot;query&quot; : &quot;我的宝马多少马力&quot;,</div><div class="line">            &quot;slop&quot; : 1</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h2><p>如果我们希望两个字段进行匹配，其中一个字段有这个文档就满足的话，使用multi_match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;multi_match&quot;: &#123;</div><div class="line">        &quot;query&quot; : &quot;我的宝马多少马力&quot;,</div><div class="line">        &quot;fields&quot; : [&quot;title&quot;, &quot;content&quot;]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是multi_match就涉及到匹配评分的问题了。</p>
<h2 id="best-fields"><a href="#best-fields" class="headerlink" title="best_fields"></a>best_fields</h2><p>我们希望完全匹配的文档占的评分比较高，则需要使用best_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;multi_match&quot;: &#123;</div><div class="line">      &quot;query&quot;: &quot;我的宝马发动机多少&quot;,</div><div class="line">      &quot;type&quot;: &quot;best_fields&quot;,</div><div class="line">      &quot;fields&quot;: [</div><div class="line">        &quot;tag&quot;,</div><div class="line">        &quot;content&quot;</div><div class="line">      ],</div><div class="line">      &quot;tie_breaker&quot;: 0.3</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思就是完全匹配”宝马 发动机”的文档评分会比较靠前，如果只匹配宝马的文档评分乘以0.3的系数</p>
<h2 id="most-fields"><a href="#most-fields" class="headerlink" title="most_fields"></a>most_fields</h2><p>我们希望越多字段匹配的文档评分越高，就要使用most_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;multi_match&quot;: &#123;</div><div class="line">      &quot;query&quot;: &quot;我的宝马发动机多少&quot;,</div><div class="line">      &quot;type&quot;: &quot;most_fields&quot;,</div><div class="line">      &quot;fields&quot;: [</div><div class="line">        &quot;tag&quot;,</div><div class="line">        &quot;content&quot;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="cross-fields"><a href="#cross-fields" class="headerlink" title="cross_fields"></a>cross_fields</h2><p>我们会希望这个词条的分词词汇是分配到不同字段中的，那么就使用cross_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;multi_match&quot;: &#123;</div><div class="line">      &quot;query&quot;: &quot;我的宝马发动机多少&quot;,</div><div class="line">      &quot;type&quot;: &quot;cross_fields&quot;,</div><div class="line">      &quot;fields&quot;: [</div><div class="line">        &quot;tag&quot;,</div><div class="line">        &quot;content&quot;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="term"><a href="#term" class="headerlink" title="term"></a>term</h2><p>term是代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;term&quot;: &#123;</div><div class="line">      &quot;content&quot;: &quot;汽车保养&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查出的所有文档都包含”汽车保养”这个词组的词汇。</p>
<p>使用term要确定的是这个字段是否“被分析”(analyzed)，默认的字符串是被分析的。</p>
<p>拿官网上的例子举例：</p>
<p>mapping是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">PUT my_index</div><div class="line">&#123;</div><div class="line">  &quot;mappings&quot;: &#123;</div><div class="line">    &quot;my_type&quot;: &#123;</div><div class="line">      &quot;properties&quot;: &#123;</div><div class="line">        &quot;full_text&quot;: &#123;</div><div class="line">          &quot;type&quot;:  &quot;string&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;exact_value&quot;: &#123;</div><div class="line">          &quot;type&quot;:  &quot;string&quot;,</div><div class="line">          &quot;index&quot;: &quot;not_analyzed&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PUT my_index/my_type/1</div><div class="line">&#123;</div><div class="line">  &quot;full_text&quot;:   &quot;Quick Foxes!&quot;,</div><div class="line">  &quot;exact_value&quot;: &quot;Quick Foxes!&quot;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的full_text是被分析过的，所以full_text的索引中存的就是[quick, foxes]，而extra_value中存的是[Quick Foxes!]。</p>
<p>那下面的几个请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;term&quot;: &#123;</div><div class="line">      &quot;exact_value&quot;: &quot;Quick Foxes!&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求的出数据，因为完全匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET my_index/my_type/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;term&quot;: &#123;</div><div class="line">      &quot;full_text&quot;: &quot;Quick Foxes!&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求不出数据的，因为full_text分词后的结果中没有[Quick Foxes!]这个分词。</p>
<h3 id="对查询的结果排序"><a href="#对查询的结果排序" class="headerlink" title="对查询的结果排序"></a>对查询的结果排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">GET iclick_persona/iclick/_search</div><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123;&quot;term&quot;: &#123;</div><div class="line">          &quot;articles.domains&quot;: &#123;</div><div class="line">            &quot;value&quot;: &quot;play.google.com&quot;</div><div class="line">          &#125;</div><div class="line">        &#125;&#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;, &quot;sort&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;create_time&quot;: &#123;</div><div class="line">        &quot;order&quot;: &quot;desc&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>联合查询: must,should,must_not</p>
<p>如果我们想要请求”content中带宝马，但是tag中不带宝马”这样类似的需求，就需要用到bool联合查询。<br>联合查询就会使用到must,should,must_not三种关键词。</p>
<p>这三个可以这么理解</p>
<ul>
<li>must: 文档必须完全匹配条件</li>
<li>should: should下面会带一个以上的条件，至少满足一个条件，这个文档就符合should</li>
<li>must_not: 文档必须不匹配条件</li>
</ul>
<p>比如上面那个需求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: &#123;</div><div class="line">        &quot;term&quot;: &#123;</div><div class="line">          &quot;content&quot;: &quot;宝马&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &quot;must_not&quot;: &#123;</div><div class="line">        &quot;term&quot;: &#123;</div><div class="line">          &quot;tags&quot;: &quot;宝马&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p>比如要实现 a &amp;&amp; (b=0 || b=1)这样的需求，则通过嵌套bool来实现，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">GET news_v1/_search</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 20,</div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;bool&quot;: &#123;</div><div class="line">      &quot;must&quot;: [</div><div class="line">        &#123;</div><div class="line">          &quot;multi_match&quot;: &#123;</div><div class="line">            &quot;query&quot;: &quot;美白&quot;,</div><div class="line">            &quot;fields&quot;: [</div><div class="line">              &quot;meta.description&quot;,</div><div class="line">              &quot;title&quot;</div><div class="line">            ]</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">        &quot;bool&quot;: &#123;</div><div class="line">            &quot;should&quot;: [</div><div class="line">              &#123;</div><div class="line">                &quot;term&quot;: &#123;</div><div class="line">                  &quot;lang&quot;: &#123;</div><div class="line">                    &quot;value&quot;: &quot;zh-hk&quot;</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">              &#125;,</div><div class="line">              &#123;</div><div class="line">                &quot;term&quot;: &#123;</div><div class="line">                  &quot;lang&quot;: &#123;</div><div class="line">                    &quot;value&quot;: &quot;en&quot;</div><div class="line">                  &#125;</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            ]</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &quot;ext&quot;: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h2><p>ES自带的排序默认只是可以对数值字段，日期字段或者是字符串字段进行排序，那么，如果我们就是要人为的让包含字段A的排在包含字段B的前面，当前的方式无法满足。</p>
<p>于是需要寻求另一种方式来解决，将给定的A和B转换成数值1和2 从而就能够达到要求的排序。而且是在得分相同的情况才会进行的排序方式！通过脚本实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">GET _search  </div><div class="line">&#123;  </div><div class="line">  &quot;_source&quot;: &#123;  </div><div class="line">    &quot;include&quot;: [&quot;title.Value&quot;,&quot;dataType&quot;,&quot;_score&quot;]  </div><div class="line">  &#125;,   </div><div class="line">  &quot;query&quot;: &#123;  </div><div class="line">    &quot;bool&quot;: &#123;  </div><div class="line">      &quot;should&quot;: [  </div><div class="line">        &#123;  </div><div class="line">          &quot;query_string&quot;: &#123;  </div><div class="line">            &quot;default_field&quot;: &quot;title.Value&quot;,  </div><div class="line">            &quot;query&quot;: &quot;盆地^10  Unconformity&quot;  </div><div class="line">          &#125;  </div><div class="line">        &#125;  </div><div class="line">      ]  </div><div class="line">    &#125;  </div><div class="line">  &#125;,  </div><div class="line">    &quot;sort&quot; : &#123;  </div><div class="line">      &quot;_score&quot;:&#123;  </div><div class="line">        &quot;order&quot; : &quot;dese&quot;  </div><div class="line">      &#125;,  </div><div class="line">    &quot;_script&quot; : &#123;   </div><div class="line">        &quot;script&quot; : &quot;&apos;区带资源量数据&apos; in doc[&apos;dataType&apos;].values?2 :(&apos;其它相关资料5&apos; in doc[&apos;dataType&apos;].values? 1 :3)&quot;,  </div><div class="line">        &quot;type&quot; : &quot;string&quot;,  </div><div class="line">        &quot;order&quot; : &quot;asc&quot;  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="按条件删除"><a href="#按条件删除" class="headerlink" title="按条件删除"></a>按条件删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">POST iclick_persona/iclick/_delete_by_query</div></pre></td></tr></table></figure>
<h1 id="ES的java-api"><a href="#ES的java-api" class="headerlink" title="ES的java api"></a>ES的java api</h1><h2 id="连接到ES"><a href="#连接到ES" class="headerlink" title="连接到ES"></a>连接到ES</h2><p>创建一个客户端连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import org.elasticsearch.client.transport.TransportClient;</div><div class="line">import org.elasticsearch.common.settings.Settings;</div><div class="line">import org.elasticsearch.common.transport.InetSocketTransportAddress;</div><div class="line">import org.elasticsearch.transport.client.PreBuiltTransportClient;</div><div class="line"></div><div class="line">TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</div><div class="line">				.addTransportAddress(new InetSocketTransportAddress(InetAddress</div><div class="line">						.getByName(&quot;10.1.1.111&quot;), 9300));</div></pre></td></tr></table></figure>
<h2 id="创建索引并写入数据"><a href="#创建索引并写入数据" class="headerlink" title="创建索引并写入数据"></a>创建索引并写入数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import org.datanucleus.store.rdbms.request.BulkRequest;</div><div class="line">import org.elasticsearch.action.index.IndexResponse;</div></pre></td></tr></table></figure>
<p>若是单个插入索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 创建es索引</div><div class="line">IndexResponse response = client.prepareIndex(&quot;movie&quot;, &quot;bt&quot;)</div><div class="line">.setSource(JSON.toJSONString(obj)).get();</div></pre></td></tr></table></figure>
<p>若是批量插入索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">String line = null;</div><div class="line">		JSONObject obj = null;</div><div class="line">		</div><div class="line">		TransportClient client = new PreBuiltTransportClient(Settings.EMPTY)</div><div class="line">		.addTransportAddress(new InetSocketTransportAddress(InetAddress</div><div class="line">				.getByName(&quot;10.1.1.111&quot;), 9300));</div><div class="line">		</div><div class="line">		//批量插入索引</div><div class="line">		BulkRequestBuilder brq = client.prepareBulk();</div><div class="line">		</div><div class="line">		File file = new File(&quot;f:\\data_utf8.json&quot;);</div><div class="line">		int cnt = 0;</div><div class="line">		if (file.exists() &amp;&amp; file.isFile()) &#123;</div><div class="line">			InputStreamReader isr = new InputStreamReader(new FileInputStream(</div><div class="line">					file));</div><div class="line">			BufferedReader br = new BufferedReader(isr);</div><div class="line">			while ((line = br.readLine()) != null) &#123;</div><div class="line">				obj = JSON.parseObject(line);</div><div class="line">				</div><div class="line">				brq.add(client.prepareIndex(&quot;btmovie&quot;, &quot;bt&quot;).setSource(JSON.toJSONString(obj)));</div><div class="line">				cnt ++;</div><div class="line">				</div><div class="line">				if (cnt%1000 == 0)</div><div class="line">					System.out.println(cnt);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		brq.execute().actionGet();</div><div class="line">		</div><div class="line">		</div><div class="line">		System.out.println(&quot;done&quot;);</div></pre></td></tr></table></figure>
<h1 id="disable-coord"><a href="#disable-coord" class="headerlink" title="disable_coord"></a>disable_coord</h1><p>true：多个关键词命中，打分会累加</p>
<blockquote>
<ul>
<li>if coord factor is enabled (by default “disable_coord”: false) then it means: <em>if we have more search keywords in text then this result would be more relevant and will get higher score</em>.</li>
<li>if coord factor is disabled(“disable_coord”: true) then it means: <em>no matter how many keywords we have in search text it will be counted just once.</em></li>
</ul>
</blockquote>
<h1 id="minimum-should-match"><a href="#minimum-should-match" class="headerlink" title="minimum_should_match"></a>minimum_should_match</h1><p>在multi_match中，minimum_should_match</p>
<h1 id="相关度控制原理"><a href="#相关度控制原理" class="headerlink" title="相关度控制原理"></a>相关度控制原理</h1><p><a href="http://blog.csdn.net/xyh930929/article/details/72378690?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">http://blog.csdn.net/xyh930929/article/details/72378690?utm_source=itdadao&amp;utm_medium=referral</a></p>
<h1 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h1><p>english_custom</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&quot;analysis&quot;: &#123;</div><div class="line">          &quot;filter&quot;: &#123;</div><div class="line">            &quot;english_stemmer&quot;: &#123;</div><div class="line">              &quot;type&quot;: &quot;stemmer&quot;,</div><div class="line">              &quot;language&quot;: &quot;english&quot;</div><div class="line">            &#125;,</div><div class="line">            &quot;english_stop&quot;: &#123;</div><div class="line">              &quot;type&quot;: &quot;stop&quot;,</div><div class="line">              &quot;stopwords&quot;: &quot;_english_&quot;</div><div class="line">            &#125;,</div><div class="line">            &quot;english_possessive_stemmer&quot;: &#123;</div><div class="line">              &quot;type&quot;: &quot;stemmer&quot;,</div><div class="line">              &quot;language&quot;: &quot;possessive_english&quot;</div><div class="line">            &#125;</div><div class="line">          &#125;,</div><div class="line">          &quot;analyzer&quot;: &#123;</div><div class="line">            &quot;cjk_custom&quot;: &#123;</div><div class="line">              &quot;filter&quot;: [</div><div class="line">                &quot;cjk_width&quot;,</div><div class="line">                &quot;lowercase&quot;,</div><div class="line">                &quot;cjk_bigram&quot;,</div><div class="line">                &quot;english_stop&quot;,</div><div class="line">                &quot;asciifolding&quot;</div><div class="line">              ],</div><div class="line">              &quot;tokenizer&quot;: &quot;standard&quot;</div><div class="line">            &#125;,</div><div class="line">            &quot;english_custom&quot;: &#123;</div><div class="line">              &quot;filter&quot;: [</div><div class="line">                &quot;english_possessive_stemmer&quot;,</div><div class="line">                &quot;lowercase&quot;,</div><div class="line">                &quot;english_stop&quot;,</div><div class="line">                &quot;english_stemmer&quot;,</div><div class="line">                &quot;asciifolding&quot;</div><div class="line">              ],</div><div class="line">              &quot;tokenizer&quot;: &quot;standard&quot;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/读书/计算机程序的构造和解释/CH3/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/" class="post-title-link" itemprop="url">第三章 模块化、对象和状态</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-28 16:02:58" itemprop="dateModified" datetime="2019-06-28T16:02:58+08:00">2019-06-28</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/读书/计算机程序的构造和解释/CH3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/读书/计算机程序的构造和解释/CH3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三章-模块化、对象和状态"><a href="#第三章-模块化、对象和状态" class="headerlink" title="第三章 模块化、对象和状态"></a>第三章 模块化、对象和状态</h1><h2 id="前两章回顾"><a href="#前两章回顾" class="headerlink" title="前两章回顾"></a>前两章回顾</h2><ol>
<li>如何组合<strong>基本过程</strong>和<strong>基本数据</strong></li>
<li>如何构造各种<strong>复合对象</strong>(组合过程/数据)</li>
<li><strong>抽象</strong>在控制和处理程序复杂性中的重要作用</li>
</ol>
<blockquote>
<p>简单问题1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; cons、car和cdr的含义</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>简单问题2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; ;写出以下函数的等价lambda表达式</div><div class="line">&gt; (define (add a b)</div><div class="line">&gt;   (+ a b))</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>但对于程序设计而言，上面这三种手段还不够用，有效设计大型系统，还需要一些组织系统的原则，这体现在下面两方面：</p>
<ol>
<li>只有高效算法，不足以构造出良好的大型系统</li>
<li>系统的功能分解，结构组织和管理与算法一样重要(或更甚之)</li>
</ol>
<p>在大型系统的复杂性问题上，仅学会抽象的思维还不够，还需要一些能帮我们<strong>构造模块化的大型系统的策略</strong>。在这一章，会学习两种组织策略。</p>
<ul>
<li><strong>基于对象的策略</strong></li>
</ul>
<blockquote>
<p>真实系统中的对象随着时间的进展不断变化，模拟它们的系统对象也吸引相应地变化</p>
</blockquote>
<ul>
<li><strong>基于流处理的策略</strong></li>
</ul>
<blockquote>
<p>关注流过系统的信息流</p>
</blockquote>
<h2 id="3-1-赋值和局部状态"><a href="#3-1-赋值和局部状态" class="headerlink" title="3.1 赋值和局部状态"></a>3.1 赋值和局部状态</h2><h3 id="3-1-1-局部状态变量"><a href="#3-1-1-局部状态变量" class="headerlink" title="3.1.1 局部状态变量"></a>3.1.1 局部状态变量</h3><blockquote>
<p>例子：银行取钱</p>
</blockquote>
<p>用withdraw表示该行为，入参amount表示取钱的数量，若账户有足够的钱，返回余额；否则返回Insufficient funds。</p>
<p>为了实现withdraw，我们用一个变量balance表示余额，withdraw检查balance是否够amount，如果是，</p>
<p><code>balance -= amount</code></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> balance <span class="number">100</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">      (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))</div><div class="line"></div><div class="line">-----------------</div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="number">50</span></div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="number">0</span></div><div class="line">&gt; (<span class="name">withdraw</span> <span class="number">50</span>)</div><div class="line"><span class="string">"Insufficient funds"</span></div></pre></td></tr></table></figure>
<p>其中，set的语法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set! &lt;name&gt; &lt;new-value&gt; )</div></pre></td></tr></table></figure>
<p>begin描述对表达式的求值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(begin &lt;exp1&gt;&lt;exp2&gt;...&lt;expk&gt;)</div></pre></td></tr></table></figure>
<p>按顺序求值，并返回最后一个表达式的值。</p>
<p>可以看出，这里的balance是全局变量，在哪里都能读取或修改这个值。如果将其作为局部变量，就只能通过withdraw来访问balance，这样才能更准确的模拟balance这个概念。</p>
<p>于是将其转为局部变量。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> new-withdraw</div><div class="line">  (<span class="name">let</span> ((<span class="name">balance</span> <span class="number">100</span>))</div><div class="line">    (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">             balance)</div><div class="line">      <span class="string">"Insufficient funds"</span>))))</div></pre></td></tr></table></figure>
<p>其中，let创建一个包含局部变量的环境，并设初始值。</p>
<p>make-withdraw创建一种”提款处理器”，它的形参balance描述了有关账户的初始值。(把balance当形参传入)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>)))</div><div class="line"></div><div class="line">(<span class="name">define</span> W1 (<span class="name">make-withdraw</span> <span class="number">100</span>))</div><div class="line">(<span class="name">define</span> W2 (<span class="name">make-withdraw</span> <span class="number">100</span>))</div><div class="line"></div><div class="line">-----------------</div><div class="line">&gt; (<span class="name">W1</span> <span class="number">50</span>)</div><div class="line"><span class="number">50</span></div><div class="line">&gt; (<span class="name">W2</span> <span class="number">60</span>)</div><div class="line"><span class="number">40</span></div></pre></td></tr></table></figure>
<p>可以看出，W1和W2是完全独立的对象，每个都有自己的局部状态变量balance。</p>
<p>再创建一个存钱的对象make-account</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line"></div><div class="line">  (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) withdraw)</div><div class="line">          ((<span class="name">eq</span>? m 'deposit) deposit)</div><div class="line">          (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></div><div class="line">                       m))))</div><div class="line"></div><div class="line">  dispatch)</div></pre></td></tr></table></figure>
<p>对make-account的每次调用都会设置好一个带有balance的环境，在这个环境中，定义了能访问balance的过程deposit和withdraw，另外还有一个过程dispatch，它以一个字符串作为输入，返回这两个局部过程之一。</p>
<p>该过程可以这样使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; (define acc (make-account 100))</div><div class="line"></div><div class="line">; 对acc的每次调用将返回局部定义的过程</div><div class="line">&gt; (acc 'withdraw)</div><div class="line">#&lt;procedure:withdraw&gt;</div><div class="line"></div><div class="line">; 这个过程随后被应用于给定的amount</div><div class="line">&gt; ((acc 'withdraw) 50)</div><div class="line">50</div><div class="line"></div><div class="line">&gt; ((acc 'withdraw) 60)</div><div class="line">"Insufficient funds"</div><div class="line"></div><div class="line">&gt; ((acc 'deposit) 40)</div><div class="line">90</div><div class="line"></div><div class="line">&gt; ((acc 'withdraw) 60)</div><div class="line">30</div><div class="line"></div><div class="line">; 这样将产生另一个完全独立的对象，维护自己的局部balance</div><div class="line">&gt; (define acc2 (make-account 1000))</div></pre></td></tr></table></figure>
<h3 id="3-1-2-引进赋值带来的利益"><a href="#3-1-2-引进赋值带来的利益" class="headerlink" title="3.1.2 引进赋值带来的利益"></a>3.1.2 引进赋值带来的利益</h3><blockquote>
<p>例子：考虑设计一个过程rand，每次被调用就返回一个随机整数</p>
</blockquote>
<p>“随机”是指，对rand的反复调用将产生出一系列的数，这一序列具有均匀分布的统计性质。</p>
<p>假设现在有一个过程rand-update，如果给定一个数x1，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x2 = (rand-update x1)</div><div class="line">x3 = (rand-update x2)</div></pre></td></tr></table></figure>
<p>得到序列x1, x2, x3…将具有我们希望的性质</p>
<p>可以将rand时限为一个带局部状态变量x的过程，初始化为某个固定值random-init，对rand的每次调用算出当前x的rand-update值，返回作为随机数，并将其更新为x的新值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> random-init <span class="number">7</span>)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rand-update</span> x)</div><div class="line">  (<span class="name">let</span> ((<span class="name">a</span> <span class="number">27</span>) (<span class="name">b</span> <span class="number">26</span>) (<span class="name">m</span> <span class="number">127</span>))</div><div class="line">    (<span class="name">modulo</span> (<span class="name">+</span> (<span class="name">*</span> a x) b) m)))</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> rand</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</div><div class="line">      x)))</div></pre></td></tr></table></figure>
<p>当然，你也可以在需要随机数的时候直接调用rand-update，生成同样的随机数序列。但缺点是，这就<strong>需要程序中任何使用随机数的地方都必须显式的记住x的值</strong>，在生成下一个时，将x的值传给rand-update作为参数。</p>
<p>考虑用随机数实现<strong><em>蒙特卡洛法</em></strong> monte-carlo</p>
<blockquote>
<p> 蒙特卡洛模拟：从总体抽取大量随机样本，并通过这些随机样本估计这一随机事件的概率，将这个概率作为问题的解。</p>
</blockquote>
<p>比如，$6/\pi^2$是随机选取的两个整数之间没有公共因子（最大公因子（greatest common divisor，GCD）是1）的概率。</p>
<p>则可以通过每次随机选择两个证书并检查它们的GCD是否为1来近似的获得这个概率，π的近似求值。（Cesaro定理）</p>
<p><a href="https://zhuanlan.zhihu.com/p/47978393" target="_blank" rel="noopener">理解黎曼猜想（二）两个自然数互质的概率是多少？</a></p>
<p>那么，这个过程的核心就是蒙特卡洛模拟（monte-carlo），<strong>它以做某个实验的次数，以及这个实现本身作为参数</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">estimate-pi</span> trials)</div><div class="line">  (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> (<span class="name">monte-carlo</span> trials cesaro-test))))</div><div class="line"></div><div class="line"><span class="comment">; Cesaro实验</span></div><div class="line">(<span class="name">define</span> (<span class="name">cesaro-test</span>)</div><div class="line">  (<span class="name">=</span> (<span class="name">gcd</span> (<span class="name">rand</span>) (<span class="name">rand</span>)) <span class="number">1</span>))</div><div class="line"></div><div class="line"><span class="comment">; 做某个实验的次数，以及这个实现本身作为参数</span></div><div class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> trials experiment)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</div><div class="line">           (<span class="name">/</span> trials-passed trials))</div><div class="line">          ((<span class="name">experiment</span>)</div><div class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) (<span class="name">+</span> trials-passed <span class="number">1</span>)))</div><div class="line">          (<span class="name">else</span></div><div class="line">           (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>) trials-passed))))</div><div class="line">  (<span class="name">iter</span> trials <span class="number">0</span>))</div><div class="line"></div><div class="line">---------------------</div><div class="line">&gt; (<span class="name">estimate-pi</span> <span class="number">50</span>)</div><div class="line"><span class="number">2.449489742783178</span></div></pre></td></tr></table></figure>
<p>现在试一下不用rand，直接用rand-update，如果不使用赋值去模拟局部状态，则</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">random-gcd-test</span> trials initial-x)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> trials-remaining trials-passed x)</div><div class="line">    (<span class="name">let</span> ((<span class="name">x1</span> (<span class="name">rand-update</span> x)))</div><div class="line">      (<span class="name">let</span> ((<span class="name">x2</span> (<span class="name">rand-update</span> x1)))</div><div class="line">        (<span class="name">cond</span> ((<span class="name">=</span> trials-remaining <span class="number">0</span>)</div><div class="line">               (<span class="name">/</span> trials-passed trials))</div><div class="line">              ((<span class="name">=</span> (<span class="name">gcd</span> x1 x2) <span class="number">1</span>)</div><div class="line">               (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</div><div class="line">                     (<span class="name">+</span> trials-passed <span class="number">1</span>)</div><div class="line">                     x2))</div><div class="line">              (<span class="name">else</span></div><div class="line">                (<span class="name">iter</span> (<span class="name">-</span> trials-remaining <span class="number">1</span>)</div><div class="line">                      trials-passed</div><div class="line">                      x2))))))</div><div class="line">  (<span class="name">iter</span> trials <span class="number">0</span> initial-x))</div></pre></td></tr></table></figure>
<p>很明显看到区别，在上面的方法中，蒙特卡洛可以<strong>抽象出一个公共方法，不限制experiment的具体形式</strong>，而下面的方法中，由于没有随机数生成器的局部状态，random-gcd-test必须显式的操作随机数x1和x2。</p>
<p>赋值和局部变量的好处：</p>
<blockquote>
<p>从复杂计算的角度来看，其他部分都像是<strong>随着时间不断变化，而它们自己隐藏起随时间变化的内部状态</strong>（比如银行账户和随机数生成器）。因此在进行系统抽象的时候，用<strong>局部变量去模拟系统的状态</strong>，用对这些<strong>变量的赋值去模拟状态的变化</strong>。</p>
</blockquote>
<h3 id="3-1-3-引进赋值的代价"><a href="#3-1-3-引进赋值的代价" class="headerlink" title="3.1.3 引进赋值的代价"></a>3.1.3 引进赋值的代价</h3><p>只要不使用赋值，以同样参数对同意过程的两次求值<strong>一定能产生同样的效果</strong>，就像在计算数学函数。不用任何赋值的程序设计成为<strong>函数式编程</strong>。</p>
<p><em>赋值如何让事情复杂化了？</em></p>
<p>来看make-withdraw的一个简化版本，其中不再关注是否有足够余额的问题：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; The Costs of Introducing Assignment</span></div><div class="line">(<span class="name">define</span> (<span class="name">make-simplified-withdraw</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">    balance))</div><div class="line">(<span class="name">define</span> W (<span class="name">make-simplified-withdraw</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div><div class="line">&gt; (<span class="name">W</span> <span class="number">20</span>)</div><div class="line"><span class="number">-15</span></div></pre></td></tr></table></figure>
<p>如果没有set</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-decrementer</span> balance)</div><div class="line">  (<span class="name">lambda</span> (<span class="name">amount</span>)</div><div class="line">    (<span class="name">-</span> balance amount)))</div><div class="line">(<span class="name">define</span> D (<span class="name">make-decrementer</span> <span class="number">25</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div><div class="line"></div><div class="line">&gt; (<span class="name">D</span> <span class="number">20</span>)</div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure>
<p>用<strong>代换模型</strong>来解释<code>make-decrementer</code>如何工作。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((<span class="name">make-decrementer</span> <span class="number">25</span>) <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="comment">; 25代替balance</span></div><div class="line">((<span class="name">lambda</span> (<span class="name">amount</span>) (<span class="name">-</span> <span class="number">25</span> amount)) <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="comment">; 应用运算符，20代替lambda中的amount</span></div><div class="line">(<span class="name">-</span> <span class="number">25</span> <span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>类似的，来看<code>make-simplified-withdraw</code>如何工作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">((make-simplified-withdraw 25)   20)</div><div class="line"></div><div class="line">; 25代替balance</div><div class="line">((lambda (amount) (set! balance (- 25 amount)) 25)   20))</div><div class="line"></div><div class="line">; 20代替lambda中的amount，先将balance设为5，再返回25</div><div class="line">(set! balance (- 25 20)) 25</div></pre></td></tr></table></figure>
<p>可见这里如果用<strong>代换模型</strong>，则这个过程首先将balance设为5，再返回25，显示是有问题的。造成这种问题的根源是：</p>
<p>在代换模型中，语言的符号（如balance）就是<strong>值的名字</strong>，而一旦引进了<strong>set和变量的值可以变化</strong>的想法，一个变量就不再是一个简单的名字了。</p>
<p><strong>同一和变化</strong></p>
<p>从这里暴露出的问题，远远不是打破了一个简单的计算模型，其意义要深远得多。一旦将变化引入了我们的计算模型，许多以前非常简单明了的概念现在都变得有问题了。</p>
<p>首先考虑两个物体实际上“<strong>同一</strong>”的概念。如果一个语言在表达式里支持“同一的东西可以相互替换”的概念，这样替换不会改变表达式的值，这个语言就称为是具有<font color="#FF0033" size="5">引用透明性</font>。</p>
<p>在我们的计算机语言包含了赋值操作之后，也就打破了引用透明性，产生了<strong>副作用</strong>。</p>
<ul>
<li><strong>修改变量的值</strong></li>
<li>IO 操作，如写数据到磁盘</li>
<li>UI 操作，如修改了一个按钮的可操作状态</li>
</ul>
<p><a href="https://juejin.im/post/5a58134751882573370794cc" target="_blank" rel="noopener">引用透明性和等式推理</a></p>
<p><strong>命令式编程的缺陷</strong></p>
<p>除了引入变量和赋值导致计算模型的复杂性之外，还容易出现一些不会在函数式编程中出现的错误，比如：</p>
<p>1.2.1节的迭代求阶乘</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> product counter)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</div><div class="line">      product</div><div class="line">        <span class="comment">; 注意这里</span></div><div class="line">      (<span class="name">iter</span> (<span class="name">*</span> counter product)</div><div class="line">	    (<span class="name">+</span> counter <span class="number">1</span>))))</div><div class="line">  (<span class="name">iter</span> <span class="number">1</span> <span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>如果用命令式编程，显式的通过赋值去更新变量product和counter的值</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">factorial</span> n)</div><div class="line">  (<span class="name">let</span> ((<span class="name">product</span> <span class="number">1</span>)</div><div class="line">	(<span class="name">counter</span> <span class="number">1</span>))</div><div class="line">    (<span class="name">define</span> (<span class="name">iter</span>)</div><div class="line">      (<span class="name">if</span> (<span class="name">&gt;</span> counter n)</div><div class="line">	product</div><div class="line">          <span class="comment">; 这两行的陷阱</span></div><div class="line">	(<span class="name">begin</span> (<span class="name">set!</span> product (<span class="name">*</span> counter product))</div><div class="line">	       (<span class="name">set!</span> counter (<span class="name">+</span> counter <span class="number">1</span>))</div><div class="line">	       (<span class="name">iter</span>))))</div><div class="line">    (<span class="name">iter</span>)))</div></pre></td></tr></table></figure>
<p>上述写法是正确的，但是如果颠倒其中两行的顺序</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;(set! counter (+ counter 1))</span></div><div class="line"><span class="comment">;(set! product (* counter product))</span></div></pre></td></tr></table></figure>
<p>结果就不对了。一般来说，<strong>带有赋值操作的程序强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本</strong>。</p>
<p>接下来要解决的问题就是，要给涉及赋值的表达式提供一种区别于之前的计算模型。</p>
<h2 id="3-2-求值的环境模型"><a href="#3-2-求值的环境模型" class="headerlink" title="3.2 求值的环境模型"></a>3.2 求值的环境模型</h2><p>之前说<strong>代换模型</strong>不再适用于赋值表达式。由于赋值操作的存在，此时的变量必须以某种方式指定了一个“位置”，相应的值可以存储在那里。在我们的新求值模型里，这种位置将维持在称为 <strong>环境</strong> 的结构中。</p>
<p>一些概念：</p>
<p>1）<strong>环境</strong>：<strong>框架</strong>的一个序列</p>
<p>2）<strong>框架</strong>：每个框架包含着一些 <strong>约束</strong> 的表格</p>
<p>3）<strong>约束</strong>：变量名和值相关联。（在一个框架里，任何变量至多只能有一个约束）</p>
<p>4）<strong>指针</strong>：每个框架还包含着一个<strong>指针</strong>，指向这一框架的<em>外围环境</em>。</p>
<p>5）<strong>变量</strong>：一个<em>变量</em>相对于某个特定环境的<em>值</em>，</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_1.png" alt="img"></p>
<p>​                                                                                一个简单的环境结构</p>
<p>1、2、3是三个框架，  ABCD都是环境指针，其中CD指向同一个环境。</p>
<p>环境对于求值过程是至关重要的，因为它确定了表达式求值的上下文。假设始终有一个全局环境，只包含一个框架（没有外围环境），这个环境包含所有关于基本过程的符号的值。</p>
<h3 id="3-2-1-求值规则"><a href="#3-2-1-求值规则" class="headerlink" title="3.2.1 求值规则"></a>3.2.1 求值规则</h3><p>在求值的环境模型中，过程只能通过一种方式创建，那就是通过求值一个lambda表达式。例如</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">  (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p>过程定义的语法形式，不过是作为隐含lambda表达式的语法糖，等价于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> square</div><div class="line">  (<span class="name">lambda</span> (<span class="name">x</span>) (<span class="name">*</span> x x))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_3.png" alt="img"></p>
<p>过程对象的环境部分是一个指向全局环境的指针，因此产生这个过程的lambda表达式是在全局环境中求值的。</p>
<p>这里增加了一个新约束：将过程对象约束给符号square。一般来说，<strong>define就是把一个新的约束加入到框架中</strong>。</p>
<p>假设现在对表达式<code>(square 5)</code>求值，结果是创建了一个新环境——E1。</p>
<p>1）E1从一个框架开始，这个框架包含5赋值给x的约束。</p>
<p>2）E1引出的指针表示这个框架的外围环境是全局环境</p>
<p><strong>过程应用的环境模型</strong>：</p>
<ul>
<li>将一个过程对象应用于一组实际参数，将<strong>构造出一个新框架</strong>，其中将过程的<strong>形式参数约束到调用时的实际参数</strong>，而后在构造起的这一新环境的<strong>上下文中求值过程体</strong>。这个新框架的外围环境就是作为被应用的那个过程对象的一部分的环境。</li>
<li>相对于一个给定环境<strong>求值一个 lambda表达式</strong>，将会创建起一个过程对象，这个过程对象是一个序对，由该 lambda表达式 的正文和一个指向环境的指针组成，这一指针指向的就是创建这个过程对象时的环境。</li>
</ul>
<p>关于<code>set!</code>的行为方式</p>
<p>在某个环境里求值 <strong><em>赋值表达式</em></strong> 时，要求我们首先在环境中确定有关变量的约束位置，而后再修改这个约束，使之表示这个新值。</p>
<p>这也就是说，首先需要<strong>找到包含这个变量的约束的第一个框架，而后修改这一框架</strong>。如果该变量在环境中没有约束，将报告一个错误。</p>
<h3 id="3-2-2-简单过程的应用"><a href="#3-2-2-简单过程的应用" class="headerlink" title="3.2.2 简单过程的应用"></a>3.2.2 简单过程的应用</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">square</span> x)</div><div class="line">  (<span class="name">*</span> x x))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-of-squares</span> x y)</div><div class="line">  (<span class="name">+</span> (<span class="name">square</span> x) (<span class="name">square</span> y)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">f</span> a)</div><div class="line">  (<span class="name">sum-of-squares</span> (<span class="name">+</span> a <span class="number">1</span>) (<span class="name">*</span> a <span class="number">2</span>)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_4.png" alt="img"></p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/3_5.png" alt="img"></p>
<p>求值 <code>(f 5)</code>：</p>
<ol>
<li>创建一个新环境 <code>E1</code>，参数 <code>a</code> 被约束到 5。在 <code>E1</code> 中求值 <code>(sum-of-square (+ a 1) (* a2))</code></li>
<li>求值组合式，首先求值子表达式。第一个子表达式 <code>sum-of-square</code> 以一个过程对象为值。（在 <code>E1</code> 的框架中未寻找到约束，而后进入有关的外围环境，并找到约束）</li>
<li>创建环境 <code>E2</code>，现在需要把过程对象 <code>sum-of-square</code> 应用于实参 6 和 10。</li>
</ol>
<h2 id="3-3-用变动的数据做模拟"><a href="#3-3-用变动的数据做模拟" class="headerlink" title="3.3 用变动的数据做模拟"></a>3.3 用变动的数据做模拟</h2><h3 id="3-3-1-变动的表结构"><a href="#3-3-1-变动的表结构" class="headerlink" title="3.3.1 变动的表结构"></a>3.3.1 变动的表结构</h3><p>针对序对的基本改变函数是set-car!和set-cdr!。<code>set-car!</code>要求两个参数，其中第一个参数必须是一个序对。然后修改这个序对，将它的car指针替换为指向set-car!第二个参数的指针。</p>
<p>假设x是<code>((a b) c d)</code>，y是<code>(e f)</code>，执行</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190612130259772.png" alt="image-20190612130259772"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set-car! x y)</div></pre></td></tr></table></figure>
<p>修改x约束的那个表，将它的car用y的值取代。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190612130309732.png" alt="image-20190612130309732"></p>
<p><strong>共享和相等</strong></p>
<p>当不同的数据对象共享某些序对时，会产生一些问题。例如，考虑下面的结构：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> x (<span class="name">list</span> 'a 'b))</div><div class="line">(<span class="name">define</span> z1 (<span class="name">cons</span> x x))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617143714166.png" alt="image-20190617143714166"></p>
<p>这里的z1是一个序对，car和cdr都指向同一个序对x。</p>
<p>再看另一个结构</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> z2 </div><div class="line">  (<span class="name">cons</span> (<span class="name">list</span> 'a 'b) (<span class="name">list</span> 'a 'b)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617143741708.png" alt="image-20190617143741708"></p>
<p>两个表(a, b)的各个序对互不相同，虽然其中的符号是共享的。</p>
<p>作为表考虑，z1和z2表示同一个表<code>((a b) a b)</code>。一般而言，如果我们只用cons、car、cdr，z1和z2看不出差别。然而，<strong>如果允许修改表结构，共享的情况就会体现出差别</strong>。考虑下面的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">set-to-wow!</span> x)</div><div class="line">  (<span class="name">set-car!</span> (<span class="name">car</span> x) 'wow)</div><div class="line">  x)</div></pre></td></tr></table></figure>
<p>将<code>set-to-wow!</code>应用于z1和z2，将产生不同的结果。对于z1，修改car也就同时修改了cdr。而对于z2，只修改了car。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; z1</div><div class="line">((<span class="name">a</span> b) a b)</div><div class="line"></div><div class="line">&gt; (<span class="name">set-to-wow!</span> z1)</div><div class="line">((<span class="name">wow</span> b) wow b)</div><div class="line"></div><div class="line">&gt; z2</div><div class="line">((<span class="name">a</span> b) a b)</div><div class="line"></div><div class="line">&gt; (<span class="name">set-to-wow!</span> z2)</div><div class="line">((<span class="name">wow</span> b) a b)</div></pre></td></tr></table></figure>
<p>检测表结构是否共享的一种方式是使用<strong>谓词eq?</strong>。谓词<code>(eq? x y)</code>检查x和y作为指针是否相等。这样，对于z1和z2，<code>(eq? (car z1) (cdr z1))</code> 为true <code>(eq? (car z2) (cdr z2))</code> 为false。</p>
<h3 id="3-3-2-队列的表示"><a href="#3-3-2-队列的表示" class="headerlink" title="3.3.2 队列的表示"></a>3.3.2 队列的表示</h3><p>利用<code>set-car!</code> 和 <code>set-cdr!</code>，我们可以用序对构造出一些单靠cons、car、cdr无法构造的数据结构。这一节展示如何构造<strong>队列</strong>。</p>
<p>一个队列是一个序对，数据只能从一端插入（队列的尾），另一端删除（队列的首）。下面显示一个初始是空的队列，之后插入a和b，再删除a，再插入c和d，再删除b。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617145657417.png" alt="image-20190617145657417"></p>
<p>队列可以看做是由下面一组操作定义的结构：</p>
<ul>
<li>一个构造函数(make-queue) ，返回一个空队列。</li>
<li>两个选择函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(empty-queue? ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>检查队列是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(front-queue ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>返回队首的对象，如果空就报错。</p>
<ul>
<li>两个改变函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(insert-queue! ⟨queue⟩ ⟨item⟩)</div></pre></td></tr></table></figure>
<p>插入队尾，返回修改后的队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(delete-queue! ⟨queue⟩)</div></pre></td></tr></table></figure>
<p>删除队首对象，返回修改后的队列。</p>
<p>队列可以表示成一个常规的表，用car、cdr来完成上述操作。但是效率很低，为了插入一个数据项，需要扫描整个表，有<code>O(n)</code>的时间复杂度。那么简单修改一下表的表示方式，就可以只需<code>O(1)</code>的时间复杂度。方法就是加入一个指向队列尾的指针，这里就有两个指针<code>front-ptr</code> 和<code>rear-ptr</code>。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617155741378.png" alt="image-20190617155741378"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">front-ptr</span> queue) (<span class="name">car</span> queue))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rear-ptr</span> queue) (<span class="name">cdr</span> queue))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-front-ptr!</span> queue item) </div><div class="line">  (<span class="name">set-car!</span> queue item))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-rear-ptr!</span> queue item) </div><div class="line">  (<span class="name">set-cdr!</span> queue item))</div></pre></td></tr></table></figure>
<p>现在来实现队列的其他操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(define (empty-queue? queue) </div><div class="line">  (null? (front-ptr queue)))</div><div class="line">  </div><div class="line">(define (make-queue) (cons '() '()))</div><div class="line"></div><div class="line">(define (front-queue queue)</div><div class="line">  (if (empty-queue? queue)</div><div class="line">      (error "FRONT called with an </div><div class="line">              empty queue" queue)</div><div class="line">      (car (front-ptr queue))))</div></pre></td></tr></table></figure>
<p>如果要插入一个对象，按照下图的方式，</p>
<p>1）创建一个新队列，car是需要插入的项，cdr是空表。</p>
<p>2）若队列原来是空，就让<code>front-ptr</code> 和<code>rear-ptr</code>共同指向新序对。否则就修改rear-ptr，而指向新序对。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617162453179.png" alt="image-20190617162453179"></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert-queue!</span> queue item)</div><div class="line">  (<span class="name">let</span> ((<span class="name">new-pair</span> (<span class="name">cons</span> item '())))</div><div class="line">    (<span class="name">cond</span> ((<span class="name">empty-queue</span>? queue)</div><div class="line">           (<span class="name">set-front-ptr!</span> queue new-pair)</div><div class="line">           (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">           queue)</div><div class="line">          (<span class="name">else</span> (<span class="name">set-cdr!</span> (<span class="name">rear-ptr</span> queue) </div><div class="line">                          new-pair)</div><div class="line">                (<span class="name">set-rear-ptr!</span> queue new-pair)</div><div class="line">                queue))))</div></pre></td></tr></table></figure>
<p>要删除对象，就修改front-ptr，指向第二个数据项。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(define (delete-queue! queue)</div><div class="line">  (cond ((empty-queue? queue)</div><div class="line">         (error "DELETE! called with </div><div class="line">                 an empty queue" queue))</div><div class="line">        (else (set-front-ptr! </div><div class="line">               queue </div><div class="line">               (cdr (front-ptr queue)))</div><div class="line">              queue)))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617165406898.png" alt="image-20190617165406898"></p>
<h3 id="3-3-3-表格的表示"><a href="#3-3-3-表格的表示" class="headerlink" title="3.3.3 表格的表示"></a>3.3.3 表格的表示</h3><p>首先考虑一维表格的问题，每个记录实现为key和value的序对。这些记录连接起来就构成一个序对的表。为了向表格里面插入记录时有可以修改的位置，将这种表格构造为一种<strong>带有表头单元的表</strong>。表开头有一个“哑”记录——存放一个特殊符号，<code>*table*</code>。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617170617702.png" alt="image-20190617170617702"></p>
<p>为了从表格中提取信息，定义lookup过程，以key为参数，返回value。lookup基于assoc定义。assoc返回key的那条记录。lookup检查assoc返回的记录是否为假，而后返回value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">cdr</span> record)</div><div class="line">        false)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">assoc</span> key records)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? records) false)</div><div class="line">        ((<span class="name">equal</span>? key (<span class="name">caar</span> records)) </div><div class="line">         (<span class="name">car</span> records))</div><div class="line">        (<span class="name">else</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> records)))))</div></pre></td></tr></table></figure>
<p>如果是插入操作，</p>
<p>1）首先用assoc检查表格中是否有这个key，如果没有，就cons这个key和value，构造出一个新记录。接着插入到表的最前面，位于哑记录之后。</p>
<p>2）如果表格中存在这个记录，就用该记录的cdr设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">record</span> (<span class="name">assoc</span> key (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> record</div><div class="line">        (<span class="name">set-cdr!</span> record value)</div><div class="line">        (<span class="name">set-cdr!</span> table</div><div class="line">                  (<span class="name">cons</span> (<span class="name">cons</span> key value) </div><div class="line">                        (<span class="name">cdr</span> table)))))</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<p>在构造一个新表时，只需创建起一个包含符号<code>*table*</code>的表。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-table</span>)</div><div class="line">  (<span class="name">list</span> '*table*))</div></pre></td></tr></table></figure>
<p><strong>二维表格</strong></p>
<p>二维表格的每个值用两个key索引。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/../../../../../../Desktop/image-20190617172806860.png" alt="image-20190617172806860"></p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190617172821310.png" alt="image-20190617172821310"></p>
<p>二维表的查询。先用第一个key确定对应的子表格，而后用第二个key确定value。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">lookup</span> key-1 key-2 table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> subtable</div><div class="line">        (<span class="name">let</span> ((<span class="name">record</span> </div><div class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</div><div class="line">          (<span class="name">if</span> record (<span class="name">cdr</span> record) false))</div><div class="line">        false)))</div></pre></td></tr></table></figure>
<p>二维表的插入。首先用assoc查看key-1是否有一个子表格，没有就构造，其中只包含一个记录<code>(key-2, value)</code>。若有，就将新值插入该子表格。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">insert!</span> key-1 key-2 value table)</div><div class="line">  (<span class="name">let</span> ((<span class="name">subtable</span> (<span class="name">assoc</span> key-1 (<span class="name">cdr</span> table))))</div><div class="line">    (<span class="name">if</span> subtable</div><div class="line">        (<span class="name">let</span> ((<span class="name">record</span> </div><div class="line">               (<span class="name">assoc</span> key-2 (<span class="name">cdr</span> subtable))))</div><div class="line">          (<span class="name">if</span> record</div><div class="line">              (<span class="name">set-cdr!</span> record value)</div><div class="line">              (<span class="name">set-cdr!</span> </div><div class="line">               subtable</div><div class="line">               (<span class="name">cons</span> (<span class="name">cons</span> key-2 value)</div><div class="line">                     (<span class="name">cdr</span> subtable)))))</div><div class="line">        (<span class="name">set-cdr!</span> </div><div class="line">         table</div><div class="line">         (<span class="name">cons</span> (<span class="name">list</span> key-1 (<span class="name">cons</span> key-2 value))</div><div class="line">               (<span class="name">cdr</span> table)))))</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<p><strong>创建局部表格</strong></p>
<p>上述的lookup和insert!都以整个表格为参数，这也使我们可以将它们用到包含多个表格的程序中。处理多个表格的方式是为每个表格提供一对独立的lookup和insert！过程。</p>
<p>实现的方案是，用过程表示表格，将表格表示为一个以局部状态的方式维持一个内部表格的对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">(define (make-table)</div><div class="line">  (let ((local-table (list '*table*)))</div><div class="line">    (define (lookup key-1 key-2)</div><div class="line">      (let ((subtable </div><div class="line">             (assoc key-1 (cdr local-table))))</div><div class="line">        (if subtable</div><div class="line">            (let ((record </div><div class="line">                   (assoc key-2 </div><div class="line">                          (cdr subtable))))</div><div class="line">              (if record (cdr record) false))</div><div class="line">            false)))</div><div class="line">    (define (insert! key-1 key-2 value)</div><div class="line">      (let ((subtable </div><div class="line">             (assoc key-1 (cdr local-table))))</div><div class="line">        (if subtable</div><div class="line">            (let ((record </div><div class="line">                   (assoc key-2 </div><div class="line">                          (cdr subtable))))</div><div class="line">              (if record</div><div class="line">                  (set-cdr! record value)</div><div class="line">                  (set-cdr! </div><div class="line">                   subtable</div><div class="line">                   (cons (cons key-2 value)</div><div class="line">                         (cdr subtable)))))</div><div class="line">            (set-cdr! </div><div class="line">             local-table</div><div class="line">             (cons (list key-1</div><div class="line">                         (cons key-2 value))</div><div class="line">                   (cdr local-table)))))</div><div class="line">      'ok)</div><div class="line">    (define (dispatch m)</div><div class="line">      (cond ((eq? m 'lookup-proc) lookup)</div><div class="line">            ((eq? m 'insert-proc!) insert!)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          TABLE" m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure>
<p>利用make-table，我们可以实现get和put操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> operation-table (<span class="name">make-table</span>))</div><div class="line">(<span class="name">define</span> get (<span class="name">operation-table</span> 'lookup-proc))</div><div class="line">(<span class="name">define</span> put (<span class="name">operation-table</span> 'insert-proc!))</div></pre></td></tr></table></figure>
<p>这两个操作都访问同一个局部表格，这一表格被封装在由对make-table的调用创建起的对象里面。</p>
<h3 id="3-3-4-数字电路的模拟器"><a href="#3-3-4-数字电路的模拟器" class="headerlink" title="3.3.4 数字电路的模拟器"></a>3.3.4 数字电路的模拟器</h3><p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618100752926.png" alt="image-20190618100752926"></p>
<p>连接基本组件来构造更复杂的功能。比如下面的<strong>半加器</strong>电路，包括一个或门，两个与门和一个非门。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618101130329.png" alt="image-20190618101130329"></p>
<p>当A=1或B=1之一是1时，S=1，当A=1且B=1时，C=1。</p>
<blockquote>
<p><strong>半加器</strong></p>
<p>半加器是实现两个一位二进制数加法运算的器件。它具有两个输入端(被加数A和加数B)及输出端Y。 [1] </p>
<p>A和B是相加的两个数，S是半加和数，C是进位数。</p>
<p>所谓半加就是不考虑进位的加法，它的真值表如下 (见表)：</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618103146103.png" alt="image-20190618103146103"></p>
</blockquote>
<p>现在要构造一个程序来模拟数字逻辑电路。最基本元素是make-wire，用于构造连线。比如可以构造出</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> a (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> b (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> c (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> d (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> e (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> s (<span class="name">make-wire</span>))</div></pre></td></tr></table></figure>
<p>如果需要把一个功能连到一组连线上，就调用一个构造这类功能的过程，参数就是连线。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">or-gate</span> a b d)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">and-gate</span> a b c)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">inverter</span> c e)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">and-gate</span> d e s)</div><div class="line">ok</div></pre></td></tr></table></figure>
<p>再拼接成<strong>半加器</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">half-adder</span> a b s c)</div><div class="line">  (<span class="name">let</span> ((<span class="name">d</span> (<span class="name">make-wire</span>)) (<span class="name">e</span> (<span class="name">make-wire</span>)))</div><div class="line">    (<span class="name">or-gate</span> a b d)</div><div class="line">    (<span class="name">and-gate</span> a b c)</div><div class="line">    (<span class="name">inverter</span> c e)</div><div class="line">    (<span class="name">and-gate</span> d e s)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<p>在这个基础上，可以再构建<strong>全加器</strong>。</p>
<blockquote>
<p><strong>全加器</strong></p>
<p>全加器能进行加数、被加数和低位来的进位信号相加，并根据求和结果给出该位的进位信号。</p>
<p>当多位数相加时，半加器可用于最低位求和，并给出进位数。第二位的相加有两个待加数和，还有一个来自前面低位送来的进位数。这三个数相加，得出本位和数（全加和数）和进位数。这种就是“全加“，下表为全加器的逻辑状态表。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/o4YBAFtYGTaAfKmzAAAvuawUHgA437.png" alt="åå å¨åå¨å å¨çåçååºå«ï¼ç»æååè½ï¼"></p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">full-adder</span> a b c-in sum c-out)</div><div class="line">  (<span class="name">let</span> ((<span class="name">c1</span> (<span class="name">make-wire</span>)) </div><div class="line">        (<span class="name">c2</span> (<span class="name">make-wire</span>))</div><div class="line">        (<span class="name">s</span>  (<span class="name">make-wire</span>)))</div><div class="line">    (<span class="name">half-adder</span> b c-in s c1)</div><div class="line">    (<span class="name">half-adder</span> a s sum c2)</div><div class="line">    (<span class="name">or-gate</span> c1 c2 c-out)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618113425796.png" alt="image-20190618113425796"></p>
<p>从模拟器的角度，各种功能块构成了基础，将功能块连接起来就是这里的组合方法，而将特定的连接模式定义为过程就是这里的抽象方法。</p>
<h4 id="基本功能块"><a href="#基本功能块" class="headerlink" title="基本功能块"></a><strong>基本功能块</strong></h4><p>基本功能块使得在一根连线上的信号变化能够影响其他连线上的信号。我们添加如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(get-signal ⟨wire⟩)</div></pre></td></tr></table></figure>
<p>返回连线上信号的当前值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(set-signal! ⟨wire⟩ ⟨new value⟩)</div></pre></td></tr></table></figure>
<p>将连线上信号修改为新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(add-action! ⟨wire⟩ ⟨procedure of no arguments⟩)</div></pre></td></tr></table></figure>
<p>改变信号值就需要执行该过程。这种过程是一些媒介，能够将相应连线上值的变化传递到其他的连线。</p>
<p>利用这些过程，可以定义基本的数字逻辑功能了。为了把输入通过一个反门连接到输出，用add-action! 为输入关联一个过程，当输入路线的值改变时，执行这一过程。</p>
<p>先看<strong>非门</strong>，在一个inverter-delay后将输出线路设置为这个新值。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">inverter</span> input output)</div><div class="line">  (<span class="name">define</span> (<span class="name">invert-input</span>)</div><div class="line">    (<span class="name">let</span> ((<span class="name">new-value</span> </div><div class="line">           (<span class="name">logical-not</span> (<span class="name">get-signal</span> input))))</div><div class="line">      (<span class="name">after-delay</span> </div><div class="line">       inverter-delay</div><div class="line">       (<span class="name">lambda</span> ()</div><div class="line">         (<span class="name">set-signal!</span> output new-value)))))</div><div class="line">  </div><div class="line">  (<span class="name">add-action!</span> input invert-input)</div><div class="line">  'ok)</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">logical-not</span> s)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">=</span> s <span class="number">0</span>) <span class="number">1</span>)</div><div class="line">        ((<span class="name">=</span> s <span class="number">1</span>) <span class="number">0</span>)</div><div class="line">        (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Invalid signal"</span> s))))</div></pre></td></tr></table></figure>
<p>下面是<strong>与门</strong>的定义。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">and-gate</span> a1 a2 output)</div><div class="line">  (<span class="name">define</span> (<span class="name">and-action-procedure</span>)</div><div class="line">    (<span class="name">let</span> ((<span class="name">new-value</span></div><div class="line">           (<span class="name">logical-and</span> (<span class="name">get-signal</span> a1) </div><div class="line">                        (<span class="name">get-signal</span> a2))))</div><div class="line">      (<span class="name">after-delay</span> </div><div class="line">       and-gate-delay</div><div class="line">       (<span class="name">lambda</span> ()</div><div class="line">         (<span class="name">set-signal!</span> output new-value)))))</div><div class="line">  </div><div class="line">  (<span class="name">add-action!</span> a1 and-action-procedure)</div><div class="line">  (<span class="name">add-action!</span> a2 and-action-procedure)</div><div class="line">  'ok)</div></pre></td></tr></table></figure>
<h4 id="线路的表示"><a href="#线路的表示" class="headerlink" title="线路的表示"></a><strong>线路的表示</strong></h4><p>一条线路是一个具有两个局部状态变量的计算对象：一个是信号值signal-value（初值为0），一个是一组过程action-procedures，在信号值改变时，这些过程需要运行。类似于在3.1.1中处理银行账户的做法实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">(define (make-wire)</div><div class="line">  (let ((signal-value 0) </div><div class="line">        (action-procedures '()))</div><div class="line">       </div><div class="line">    (define (set-my-signal! new-value)</div><div class="line">      (if (not (= signal-value new-value))</div><div class="line">          (begin (set! signal-value new-value)</div><div class="line">                 (call-each </div><div class="line">                  action-procedures))</div><div class="line">          'done))</div><div class="line">       </div><div class="line">    (define (accept-action-procedure! proc)</div><div class="line">      (set! action-procedures </div><div class="line">            (cons proc action-procedures))</div><div class="line">      (proc))</div><div class="line">       </div><div class="line">    (define (dispatch m)</div><div class="line">      (cond ((eq? m 'get-signal) </div><div class="line">             signal-value)</div><div class="line">            ((eq? m 'set-signal!) </div><div class="line">             set-my-signal!)</div><div class="line">            ((eq? m 'add-action!) </div><div class="line">             accept-action-procedure!)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          WIRE" m))))</div><div class="line">    dispatch))</div></pre></td></tr></table></figure>
<p><code>set-my-signal!</code>检查新的信号值是否实际改变了线路上的信号，如果是，就用<code>call-each</code>运行每个动作过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">call-each</span> procedures)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? procedures)</div><div class="line">      'done</div><div class="line">      (<span class="name">begin</span> ((<span class="name">car</span> procedures))</div><div class="line">             (<span class="name">call-each</span> (<span class="name">cdr</span> procedures)))))</div></pre></td></tr></table></figure>
<p>一旦设置好dispatch过程，就可以提供以下访问线路中局部操作的过程：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">get-signal</span> wire)</div><div class="line">  (<span class="name">wire</span> 'get-signal))</div><div class="line">(<span class="name">define</span> (<span class="name">set-signal!</span> wire new-value)</div><div class="line">  ((<span class="name">wire</span> 'set-signal!) new-value))</div><div class="line">(<span class="name">define</span> (<span class="name">add-action!</span> wire action-procedure)</div><div class="line">  ((<span class="name">wire</span> 'add-action!) action-procedure))</div></pre></td></tr></table></figure>
<h4 id="待处理表agenda"><a href="#待处理表agenda" class="headerlink" title="待处理表agenda"></a><strong>待处理表agenda</strong></h4><p>最后是after-delay的实现。要维护一个称为待处理表的数据结构，包含需要完成的事项清单。定义如下操作：</p>
<ul>
<li><code>(make-agenda)</code> 返回一个新的空agenda.</li>
<li><code>(empty-agenda? ⟨agenda⟩)</code> .</li>
<li><code>(first-agenda-item ⟨agenda⟩)</code> 返回agenda第一个item.</li>
<li><code>(remove-first-agenda-item! ⟨agenda⟩)</code> .</li>
<li><code>(add-to-agenda! ⟨time⟩ ⟨action⟩ ⟨agenda⟩)</code> </li>
<li><code>(current-time ⟨agenda⟩)</code> 返回当时的模拟时间。</li>
</ul>
<p>用<code>the-agenda</code>表示特定的待处理表。以下过程向<code>the-agenda</code>中插入一个新item</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">after-delay</span> delay action)</div><div class="line">  (<span class="name">add-to-agenda!</span> </div><div class="line">   (<span class="name">+</span> delay (<span class="name">current-time</span> the-agenda))</div><div class="line">   action</div><div class="line">   the-agenda))</div></pre></td></tr></table></figure>
<p>agenda中的模拟过程用propagate实现，它操作<code>the-agenda</code>，顺序执行agenda的每个过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">propagate</span>)</div><div class="line">  (<span class="name">if</span> (<span class="name">empty-agenda</span>? the-agenda)</div><div class="line">      'done</div><div class="line">      (<span class="name">let</span> ((<span class="name">first-item</span> </div><div class="line">             (<span class="name">first-agenda-item</span> the-agenda)))</div><div class="line">        (<span class="name">first-item</span>)</div><div class="line">        (<span class="name">remove-first-agenda-item!</span> the-agenda)</div><div class="line">        (<span class="name">propagate</span>))))</div></pre></td></tr></table></figure>
<h4 id="一个简单的实例模拟"><a href="#一个简单的实例模拟" class="headerlink" title="一个简单的实例模拟"></a>一个简单的实例模拟</h4><p>下面过程将一个<strong>监测器</strong>放到一个线路上，用于显示模拟器的活动。这一过程会告诉相应线路，只要它的值改变了，就打印出新的值，同时打印当前时间和线路名称。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">probe</span> name wire)</div><div class="line">  (<span class="name">add-action!</span> </div><div class="line">   wire</div><div class="line">   (<span class="name">lambda</span> ()</div><div class="line">     (<span class="name">newline</span>)</div><div class="line">     (<span class="name">display</span> name)</div><div class="line">     (<span class="name">display</span> <span class="string">" "</span>)</div><div class="line">     (<span class="name">display</span> (<span class="name">current-time</span> the-agenda))</div><div class="line">     (<span class="name">display</span> <span class="string">"  New-value = "</span>)</div><div class="line">     (<span class="name">display</span> (<span class="name">get-signal</span> wire)))))</div></pre></td></tr></table></figure>
<p>我们从初始化待处理表和描述各种功能块的延时开始</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> the-agenda (<span class="name">make-agenda</span>))</div><div class="line">(<span class="name">define</span> inverter-delay <span class="number">2</span>)</div><div class="line">(<span class="name">define</span> and-gate-delay <span class="number">3</span>)</div><div class="line">(<span class="name">define</span> or-gate-delay <span class="number">5</span>)</div></pre></td></tr></table></figure>
<p>现在定义4条线路，在其中两条线路上安装监测器</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> input-1 (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> input-2 (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> sum (<span class="name">make-wire</span>))</div><div class="line">(<span class="name">define</span> carry (<span class="name">make-wire</span>))</div><div class="line"></div><div class="line">(<span class="name">probe</span> 'sum sum)</div><div class="line">sum <span class="number">0</span>  New-value = <span class="number">0</span></div><div class="line"></div><div class="line">(<span class="name">probe</span> 'carry carry)</div><div class="line">carry <span class="number">0</span>  New-value = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>然后将这些线路连接到一个半加器电路上</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">half-adder</span> input-1 input-2 sum carry)</div><div class="line">ok</div><div class="line"></div><div class="line">(<span class="name">set-signal!</span> input-1 <span class="number">1</span>)</div><div class="line">done</div><div class="line"></div><div class="line">(<span class="name">propagate</span>)</div><div class="line">sum <span class="number">8</span>  New-value = <span class="number">1</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>在时间8, sum上的信号变为1。现在到了模拟开始之后的8个时间单位。在这一点上，我们可 以将input-2上的信号设置为1，并让有关的值向前传播：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">set-signal!</span> input-2 <span class="number">1</span>)</div><div class="line">done</div><div class="line"></div><div class="line">(<span class="name">propagate</span>)</div><div class="line">carry <span class="number">11</span>  New-value = <span class="number">1</span></div><div class="line">sum <span class="number">16</span>  New-value = <span class="number">0</span></div><div class="line">done</div></pre></td></tr></table></figure>
<p>在时间11处，carry变成1，16处sum变成0。</p>
<h4 id="agenda的实现"><a href="#agenda的实现" class="headerlink" title="agenda的实现"></a>agenda的实现</h4><p>这种待处理表由一些时间段组成，每个时间段是由一个数值（表示时间）和一个队列(见练习3.32)组成的序对，在这个队列里，保存着那些已经安排好的，应该在这一时间段运行的过程。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-time-segment</span> time queue)</div><div class="line">  (<span class="name">cons</span> time queue))</div><div class="line">(<span class="name">define</span> (<span class="name">segment-time</span> s) (<span class="name">car</span> s))</div><div class="line">(<span class="name">define</span> (<span class="name">segment-queue</span> s) (<span class="name">cdr</span> s))</div></pre></td></tr></table></figure>
<p>我们将用3.3.2节描述的队列操作完成在时间段队列上的操作。<br>待处理表本身就是时间段的一个一维表格。与3.3.3节所示的表格的不同之处，就在于这 些时间段应该按照时间递增的顺序排列。此外，我们还需在待处理表的头部保存一个当前时 间（即，此前最后被处理的那个动作的时间）。一个新构造出的待处理表里没有时间段，其当前时间是0。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-agenda</span>) (<span class="name">list</span> <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">current-time</span> agenda) (<span class="name">car</span> agenda))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-current-time!</span> agenda time)</div><div class="line">  (<span class="name">set-car!</span> agenda time))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">segments</span> agenda) (<span class="name">cdr</span> agenda))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">set-segments!</span> agenda segments)</div><div class="line">  (<span class="name">set-cdr!</span> agenda segments))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">first-segment</span> agenda) </div><div class="line">  (<span class="name">car</span> (<span class="name">segments</span> agenda)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">rest-segments</span> agenda) </div><div class="line">  (<span class="name">cdr</span> (<span class="name">segments</span> agenda)))</div></pre></td></tr></table></figure>
<p>若一个agenda没有时间段，那它就是空的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">empty-agenda</span>? agenda)</div><div class="line">  (<span class="name">null</span>? (<span class="name">segments</span> agenda)))</div></pre></td></tr></table></figure>
<p>为了将一个动作加入待处理表，</p>
<p>1）我们首先要检査这个待处理表是否为空。如果真是这样，那么就<strong>创建一个新的时间段</strong>，并将这个时间段装入待处理表里。</p>
<p>2）否则我们就扫描整个的待处理表，检査其中各个时间段的时间。如果发现某个时间段具有合适的时间，那么就把这个动作加入与之关联的队列里。如果碰到了某个比需要预约的时间更晚的时间，那么就将一个新的时间段插入待处理表，插入这个位置之前。如果到达了待处理表的末尾，我们就必须在最后加上一个新的时间段。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-to-agenda!</span> time action agenda)</div><div class="line">  (<span class="name">define</span> (<span class="name">belongs-before</span>? segments)</div><div class="line">    (<span class="name">or</span> (<span class="name">null</span>? segments)</div><div class="line">        (<span class="name">&lt;</span> time </div><div class="line">           (<span class="name">segment-time</span> (<span class="name">car</span> segments)))))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">make-new-time-segment</span> time action)</div><div class="line">    (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">make-queue</span>)))</div><div class="line">      (<span class="name">insert-queue!</span> q action)</div><div class="line">      (<span class="name">make-time-segment</span> time q)))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">add-to-segments!</span> segments)</div><div class="line">    (<span class="name">if</span> (<span class="name">=</span> (<span class="name">segment-time</span> (<span class="name">car</span> segments)) time)</div><div class="line">        (<span class="name">insert-queue!</span> </div><div class="line">         (<span class="name">segment-queue</span> (<span class="name">car</span> segments))</div><div class="line">         action)</div><div class="line">        (<span class="name">let</span> ((<span class="name">rest</span> (<span class="name">cdr</span> segments)))</div><div class="line">          (<span class="name">if</span> (<span class="name">belongs-before</span>? rest)</div><div class="line">              (<span class="name">set-cdr!</span></div><div class="line">               segments</div><div class="line">               (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </div><div class="line">                      time </div><div class="line">                      action)</div><div class="line">                     (<span class="name">cdr</span> segments)))</div><div class="line">              (<span class="name">add-to-segments!</span> rest)))))</div><div class="line">  (<span class="name">let</span> ((<span class="name">segments</span> (<span class="name">segments</span> agenda)))</div><div class="line">    (<span class="name">if</span> (<span class="name">belongs-before</span>? segments)</div><div class="line">        (<span class="name">set-segments!</span></div><div class="line">         agenda</div><div class="line">         (<span class="name">cons</span> (<span class="name">make-new-time-segment</span> </div><div class="line">                time </div><div class="line">                action)</div><div class="line">               segments))</div><div class="line">        (<span class="name">add-to-segments!</span> segments))))</div></pre></td></tr></table></figure>
<p>从待处理表中<strong>删除第一项</strong>的过程，应该删去第一个时间段的队列前端的那一项。如果删 除使这个时间段变空了，我们就将这个时间段也从时间段的表里删去:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">remove-first-agenda-item!</span> agenda)</div><div class="line">  (<span class="name">let</span> ((<span class="name">q</span> (<span class="name">segment-queue</span> </div><div class="line">            (<span class="name">first-segment</span> agenda))))</div><div class="line">    (<span class="name">delete-queue!</span> q)</div><div class="line">    (<span class="name">if</span> (<span class="name">empty-queue</span>? q)</div><div class="line">        (<span class="name">set-segments!</span> </div><div class="line">         agenda </div><div class="line">         (<span class="name">rest-segments</span> agenda)))))</div></pre></td></tr></table></figure>
<p>找出待处理表中里第一项，也就是找出其第一个时间段队列里的第一项。无论何时提取 这个项时，都需要更新待处理表的当前时间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(define (first-agenda-item agenda)</div><div class="line">  (if (empty-agenda? agenda)</div><div class="line">      (error "Agenda is empty: </div><div class="line">              FIRST-AGENDA-ITEM")</div><div class="line">      (let ((first-seg </div><div class="line">             (first-segment agenda)))</div><div class="line">        (set-current-time! </div><div class="line">         agenda </div><div class="line">         (segment-time first-seg))</div><div class="line">        (front-queue </div><div class="line">         (segment-queue first-seg)))))</div></pre></td></tr></table></figure>
<h3 id="3-3-5-约束的传播"><a href="#3-3-5-约束的传播" class="headerlink" title="3.3.5 约束的传播"></a>3.3.5 约束的传播</h3><p>在传统上，<strong>计算机程序总被组织成一种单向的计算，它们对一些事先给定的参数执行某些操作，产生出所需要的输出。</strong>但在另一方面，我们也经常需要模拟一些<strong>由各种量之间的关系描述的系统</strong>。例如，某个机械结构的数学模型里可能包含着这样的一些信息：在一个金属杆的偏转量d与作用于这个杆的力F、杆的长度L、截面面积A和弹性模数之间的关系可以由下面方程描述</p>
<script type="math/tex; mode=display">
dAE=FL</script><p>这种关系并不是单向的，<strong>给定了其中任意的4个量，我们就可以利用它计算出第5个量</strong>。然而，<strong>要将这种方程翻译到传统的程序设计语言，就会迫使我们选出一个量，要求基于另外的4个量去计算出它</strong>。这样，一个用于计算面积A的过程将不能用于计算偏转量。虽然对于A和d的计算都出自这同一个方程。</p>
<p>在这一节里，我们要描绘一种语言的设计，这种语言将使我们可以基于各种关系进行工作。这一语言里的基本元素就是基本约束，它们描述了在不同量之间的某种特定关系。例如，<code>(adder a b c)</code>描述的是量a、b和c之间必须有关系$a+b=c$，<code>(multiplier x y z)</code>描述的是约束关系$xy=z$，而<code>(constant 3.14 x)</code>表示x的值永远都是3.14。</p>
<p>我们的语言里还提供了一些方法，使它们可以用于组合各种基本约束，以便去描述更复杂的关系。在这里，我们将通过构造<strong>约束网络</strong>的方式组合起各种约束，在这种约束网络里，约束通过<strong>连接器</strong>连接起来。连接器是一种对象，它们可以“保存”一个值，使之能参与一个<br>或者多个约束。例如，我们知道在华氏温度和摄氏温度之间的关系是：</p>
<script type="math/tex; mode=display">
9C=5(F-32)</script><p>这样的约束就可以看做是一个网络。通过基本<strong>加法约束</strong>、<strong>乘法约束</strong>和<strong>常量约束</strong>组成。在这个图里，我们看到左边的乘法块有三个引线，分别标记为 m1 、 m2 和p。该乘法约束的这些引线以如下方式连接到网络的其他部分：引线 m1连到连接器 C ，这个连接器将保存摄氏温度。引线 m2 接在连接器 w ，该连接器还连接着一个保存常量 9 的约束块。引线 p 被这一乘法块约束到 m1和 m2 的乘积，它还连接到另一个乘法块的引线p。另一乘法块的 m2连接到常量 5 ，它的 m1 连接到另一加法块的一条引线上。</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/image-20190618163207055.png" alt="image-20190618163207055"></p>
<h4 id="约束系统的使用"><a href="#约束系统的使用" class="headerlink" title="约束系统的使用"></a>约束系统的使用</h4><p>首先调用构造函数make-connector，创建起两个连接器C和F</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> C (<span class="name">make-connector</span>))</div><div class="line">(<span class="name">define</span> F (<span class="name">make-connector</span>))</div><div class="line">(<span class="name">celsius-fahrenheit-converter</span> C F)</div><div class="line">ok</div></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">celsius-fahrenheit-converter</span> c f)</div><div class="line">  (<span class="name">let</span> ((<span class="name">u</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">v</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">w</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">x</span> (<span class="name">make-connector</span>))</div><div class="line">        (<span class="name">y</span> (<span class="name">make-connector</span>)))</div><div class="line">    (<span class="name">multiplier</span> c w u)</div><div class="line">    (<span class="name">multiplier</span> v x u)</div><div class="line">    (<span class="name">adder</span> v y f)</div><div class="line">    (<span class="name">constant</span> <span class="number">9</span> w)</div><div class="line">    (<span class="name">constant</span> <span class="number">5</span> x)</div><div class="line">    (<span class="name">constant</span> <span class="number">32</span> y)</div><div class="line">    'ok))</div></pre></td></tr></table></figure>
<h4 id="约束系统的实现"><a href="#约束系统的实现" class="headerlink" title="约束系统的实现"></a>约束系统的实现</h4><p>类似于数字电路模拟器。虽然约束系统里的基本对象在某些方面更复杂一些,但整个系统却更为简单,因为这里完全不需要关心待处理表和时间延迟等等问题。</p>
<p>连接器的基本操作包括</p>
<ul>
<li><code>(has-value? ⟨connector⟩)</code> .</li>
<li><code>(get-value ⟨connector⟩)</code> .</li>
<li><code>(set-value! ⟨connector⟩ ⟨new-value⟩ ⟨informant⟩)</code> </li>
<li><code>(forget-value! ⟨connector⟩ ⟨retractor⟩)</code> 要求连接器忘记改值。</li>
<li><code>(connect ⟨connector⟩ ⟨new-constraint⟩)</code> 通过连接器参与一个新约束。</li>
</ul>
<p>通过<code>inform-about-value</code>与各个相关约束通信，这一过程告知给定的约束，该连接器有了新值。而<code>inform-about-no-value</code>告知该连接器丧失了原有的值。</p>
<p><code>adder</code>在被求和连接器a1和a2和连接器sum之间构造出一个加法约束。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">; adder将一个新的加法约束连接到指定连接器。me就代表那个加法约束。</div><div class="line">(define (adder a1 a2 sum)</div><div class="line">  ; 当加法约束得到了通知，知道自己的一个连接器有了新值后，process-new-value就会被调用。</div><div class="line">  (define (process-new-value)</div><div class="line">    (cond ((and (has-value? a1) </div><div class="line">                (has-value? a2))</div><div class="line">           (set-value! sum</div><div class="line">                       (+ (get-value a1) </div><div class="line">                          (get-value a2))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? a1) </div><div class="line">                (has-value? sum))</div><div class="line">           (set-value! a2</div><div class="line">                       (- (get-value sum) </div><div class="line">                          (get-value a1))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? a2) </div><div class="line">                (has-value? sum))</div><div class="line">           (set-value! a1</div><div class="line">                       (- (get-value sum) </div><div class="line">                          (get-value a2))</div><div class="line">                       me))))</div><div class="line">  ; 如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行process-new-value。</div><div class="line">  (define (process-forget-value)</div><div class="line">    (forget-value! sum me)</div><div class="line">    (forget-value! a1 me)</div><div class="line">    (forget-value! a2 me)</div><div class="line">    (process-new-value))</div><div class="line">  </div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else (error "Unknown request: </div><div class="line">                        ADDER" request))))</div><div class="line">  (connect a1 me)</div><div class="line">  (connect a2 me)</div><div class="line">  (connect sum me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<p><code>adder</code>将一个新的加法约束连接到指定连接器。<code>me</code>就代表那个加法约束。</p>
<p>当加法约束得到了通知，知道自己的一个连接器有了新值后，<code>process-new-value</code>就会被调用。</p>
<p>如果加法对象被告知自己的一个连接器丢失了值，就要求所有连接器丢掉值，然后再执行<code>process-new-value</code>。</p>
<p>乘法对象类似于加法对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">(define (multiplier m1 m2 product)</div><div class="line">  </div><div class="line">  (define (process-new-value)</div><div class="line">    (cond ((or (and (has-value? m1) </div><div class="line">                    (= (get-value m1) 0))</div><div class="line">               (and (has-value? m2) </div><div class="line">                    (= (get-value m2) 0)))</div><div class="line">           (set-value! product 0 me))</div><div class="line">          ((and (has-value? m1) </div><div class="line">                (has-value? m2))</div><div class="line">           (set-value! product</div><div class="line">                       (* (get-value m1) </div><div class="line">                          (get-value m2))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? product) </div><div class="line">                (has-value? m1))</div><div class="line">           (set-value! m2</div><div class="line">                       (/ (get-value product) </div><div class="line">                          (get-value m1))</div><div class="line">                       me))</div><div class="line">          ((and (has-value? product) </div><div class="line">                (has-value? m2))</div><div class="line">           (set-value! m1</div><div class="line">                       (/ (get-value product) </div><div class="line">                          (get-value m2))</div><div class="line">                       me))))</div><div class="line">  </div><div class="line">  (define (process-forget-value)</div><div class="line">    (forget-value! product me)</div><div class="line">    (forget-value! m1 me)</div><div class="line">    (forget-value! m2 me)</div><div class="line">    (process-new-value))</div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else</div><div class="line">           (error "Unknown request: </div><div class="line">                   MULTIPLIER" </div><div class="line">                  request))))</div><div class="line">  (connect m1 me)</div><div class="line">  (connect m2 me)</div><div class="line">  (connect product me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<p>最后，<strong>监视器</strong>在指定连接器被设置或取消值的时候打印出一个消息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(define (probe name connector)</div><div class="line">  (define (print-probe value)</div><div class="line">    (newline) (display "Probe: ")</div><div class="line">    (display name) (display " = ")</div><div class="line">    (display value))</div><div class="line">  (define (process-new-value)</div><div class="line">    (print-probe (get-value connector)))</div><div class="line">  (define (process-forget-value)</div><div class="line">    (print-probe "?"))</div><div class="line">  (define (me request)</div><div class="line">    (cond ((eq? request 'I-have-a-value)</div><div class="line">           (process-new-value))</div><div class="line">          ((eq? request 'I-lost-my-value)</div><div class="line">           (process-forget-value))</div><div class="line">          (else (error "Unknown request: </div><div class="line">                        PROBE" request))))</div><div class="line">  (connect connector me)</div><div class="line">  me)</div></pre></td></tr></table></figure>
<h4 id="连接器的表示"><a href="#连接器的表示" class="headerlink" title="连接器的表示"></a>连接器的表示</h4><p>连接器用带有局部状态变量value，informant和constraint的过程对象表示，value中保存这个连接器的当前值，informant是设置连接器值的对象，constraint是这一连接器所涉及的所有约束的表。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">(define (make-connector)</div><div class="line">  (let ((value false) </div><div class="line">        (informant false) </div><div class="line">        (constraints '()))</div><div class="line">    ; 当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。</div><div class="line">    (define (set-my-value newval setter)</div><div class="line">      ; 如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束</div><div class="line">      (cond ((not (has-value? me))</div><div class="line">             (set! value newval)</div><div class="line">             (set! informant setter)</div><div class="line">             ; 而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的那个约束之外</div><div class="line">             (for-each-except </div><div class="line">              setter</div><div class="line">              inform-about-value</div><div class="line">              constraints))</div><div class="line">            ((not (= value newval))</div><div class="line">             (error "Contradiction" </div><div class="line">                    (list value newval)))</div><div class="line">            (else 'ignored)))</div><div class="line">       </div><div class="line">    ; 当连接器被要求忘记自己的值时，它就会去运行局部过程forget-my-value。</div><div class="line">    (define (forget-my-value retractor)</div><div class="line">      ; 首先检査这一要求是否来自原先设置值的同一个对象</div><div class="line">      (if (eq? retractor informant)</div><div class="line">          (begin (set! informant false)</div><div class="line">                 ; 如果情况确实如此，连接器就通知它所参与的所有约束，告知它们自己的值已经没有了。</div><div class="line">                 (for-each-except </div><div class="line">                  retractor</div><div class="line">                  inform-about-no-value</div><div class="line">                  constraints))</div><div class="line">          'ignored))</div><div class="line">       </div><div class="line">    ; connect向约束表里加入一个新约束（如果它以前不在表里)。如果这个连接器已经有值，它就会将这一事实通知这个新约束。</div><div class="line">    (define (connect new-constraint)</div><div class="line">      (if (not (memq new-constraint </div><div class="line">                     constraints))</div><div class="line">          (set! constraints</div><div class="line">                (cons new-constraint </div><div class="line">                      constraints)))</div><div class="line">      (if (has-value? me)</div><div class="line">          (inform-about-value new-constraint))</div><div class="line">      'done)</div><div class="line">       </div><div class="line">    ; 连接器过程me完成对于内部过程服务的分派工作，它同时也作为这个连接器对象的代表</div><div class="line">    (define (me request)</div><div class="line">      (cond ((eq? request 'has-value?)</div><div class="line">             (if informant true false))</div><div class="line">            ((eq? request 'value) value)</div><div class="line">            ((eq? request 'set-value!) </div><div class="line">             set-my-value)</div><div class="line">            ((eq? request 'forget) </div><div class="line">             forget-my-value)</div><div class="line">            ((eq? request 'connect) connect)</div><div class="line">            (else (error "Unknown operation: </div><div class="line">                          CONNECTOR"</div><div class="line">                         request))))</div><div class="line">    me))</div></pre></td></tr></table></figure>
<p>当出现了设置一个连接器的要求时，该连接器的局部过程set-my-value就会被调用。如果这一连接器当时并没有值，那么它就设置自己的值，并在informant里记录下要求设置当前值的那个约束。而后这一连接器将通知它所参与的所有约束，除了刚刚要求设置值的<br>那个约束之外。这一工作通过下面的迭代过程完成，它将一个指定过程应用于一个表中的所有对象，除了一个给定的例外：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; 将一个指定过程应用于一个表中的所有对象</span></div><div class="line">(<span class="name">define</span> (<span class="name">for-each-except</span> exception </div><div class="line">                         procedure </div><div class="line">                         list)</div><div class="line">  (<span class="name">define</span> (<span class="name">loop</span> items)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">null</span>? items) 'done)</div><div class="line">          ((<span class="name">eq</span>? (<span class="name">car</span> items) exception) </div><div class="line">           (<span class="name">loop</span> (<span class="name">cdr</span> items)))</div><div class="line">          (<span class="name">else</span> (<span class="name">procedure</span> (<span class="name">car</span> items))</div><div class="line">                (<span class="name">loop</span> (<span class="name">cdr</span> items)))))</div><div class="line">  (<span class="name">loop</span> list))</div></pre></td></tr></table></figure>
<p>下面几个过程为分派提供了一个语法界面：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">has-value</span>? connector)</div><div class="line">  (<span class="name">connector</span> 'has-value?))</div><div class="line">(<span class="name">define</span> (<span class="name">get-value</span> connector)</div><div class="line">  (<span class="name">connector</span> 'value))</div><div class="line">(<span class="name">define</span> (<span class="name">set-value!</span> connector </div><div class="line">                    new-value </div><div class="line">                    informant)</div><div class="line">  ((<span class="name">connector</span> 'set-value!) </div><div class="line">   new-value </div><div class="line">   informant))</div><div class="line">(<span class="name">define</span> (<span class="name">forget-value!</span> connector retractor)</div><div class="line">  ((<span class="name">connector</span> 'forget) retractor))</div><div class="line">(<span class="name">define</span> (<span class="name">connect</span> connector new-constraint)</div><div class="line">  ((<span class="name">connector</span> 'connect) new-constraint))</div></pre></td></tr></table></figure>
<h2 id="3-4-并发：时间是一个本质问题"><a href="#3-4-并发：时间是一个本质问题" class="headerlink" title="3.4 并发：时间是一个本质问题"></a>3.4 并发：时间是一个本质问题</h2><p>在并发的情况下，由赋值引入的复杂性问题将变得更加严重。</p>
<h3 id="3-4-1-并发系统中时间的性质"><a href="#3-4-1-并发系统中时间的性质" class="headerlink" title="3.4.1 并发系统中时间的性质"></a>3.4.1 并发系统中时间的性质</h3><p>假设由Peter和Paul进行的取款被实现为两个独立的进程，共享同一个变量balance</p>
<p><img src="/2017/07/12/读书/计算机程序的构造和解释/CH3/pic/TB2lzajiVXXXXcHXXXXXXXXXXXX_!!581166664.png" alt="Peterä¸Paulåæ¶ååä¸ä¸ªè´¦æ·çä¸ç§åºæ¯"></p>
<p><strong>并发程序的正确行为</strong></p>
<ul>
<li>1）对并发地一种可能限制方式是：规定能修改共享状态变量的两个操作都不允许同时发生。（<strong>低效</strong>）</li>
<li>2）另一种不严厉的方式是：保证并发系统产生的结果与各个进程<strong>按照某种方式顺序运行产生出的结果</strong>完全一样。<ul>
<li>2.1）它并没有要求各个进程实际上顺序地运行，而只是要求它们<strong>产生的结果与 <em>假设</em> 它们顺序运行所产生的结果相同</strong>。</li>
<li>2.2）一个并发程序完全可能产生多于一个 “正确的” 结果，因为我们只要求其结果与按照 <em>某种</em> 方式顺序化的结果相同。</li>
</ul>
</li>
</ul>
<p>对于2.2），比如Peter和Paul的共享账户有100，Peter存入40，同时Paul取出账户中钱的一半。则可能产生两种余额，70或90。</p>
<h3 id="3-4-2-控制并发的机制"><a href="#3-4-2-控制并发的机制" class="headerlink" title="3.4.2 控制并发的机制"></a>3.4.2 控制并发的机制</h3><p>在设计并发系统时，设法做出一些一般性的机制，使我们可能<strong>限制并行进程之间的交错情况</strong>，以保证程序具有正确的行为方式。<br>人们已经为此目的而开发了许多不同的机制，我们讨论其中的一种：<strong>串行化组</strong>（serializer）</p>
<p><strong>对共享变量的串行访问</strong></p>
<p><strong>串行化</strong>：使进程可以并发地执行，但是其中也有一些过程不能并发地执行。</p>
<p>Scheme的串行化</p>
<p>通过<strong>串行化组</strong>实现这种限制。构造的方式是调用make-serializer，这一过程的实现将在后面给出。对一个给定串行化组的所有调用返回的串行化过程都属于同一个集合。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-account</span> balance)</div><div class="line">  (<span class="name">define</span> (<span class="name">withdraw</span> amount)</div><div class="line">    (<span class="name">if</span> (<span class="name">&gt;=</span> balance amount)</div><div class="line">        (<span class="name">begin</span> (<span class="name">set!</span> balance (<span class="name">-</span> balance amount))</div><div class="line">               balance)</div><div class="line">        <span class="string">"Insufficient funds"</span>))</div><div class="line">  </div><div class="line">  (<span class="name">define</span> (<span class="name">deposit</span> amount)</div><div class="line">    (<span class="name">set!</span> balance (<span class="name">+</span> balance amount))</div><div class="line">    balance)</div><div class="line"></div><div class="line">  <span class="comment">; 关键改动</span></div><div class="line">  (<span class="name">let</span> ((<span class="name">protected</span> (<span class="name">make-serializer</span>)))</div><div class="line">    (<span class="name">define</span> (<span class="name">dispatch</span> m)</div><div class="line">      (<span class="name">cond</span> ((<span class="name">eq</span>? m 'withdraw) (<span class="name">protected</span> withdraw))</div><div class="line">            ((<span class="name">eq</span>? m 'deposit) (<span class="name">protected</span> deposit))</div><div class="line">            ((<span class="name">eq</span>? m 'balance) deposit)</div><div class="line">            (<span class="name">else</span> (<span class="name">error</span> <span class="string">"Unknown request -- MAKE-ACCOUNT"</span></div><div class="line">                         m))))</div></pre></td></tr></table></figure>
<p><strong>使用多重共享资源的复杂性</strong></p>
<p>如果只存在一个共享资源（如银行账户），串行化的使用问题相对简单。如果存在多项共享资源，并发程序的设计就可能变得非常难以把握了。</p>
<p>比如现在可以交换两个账户的余额。假设Peter和Paul都能访问账户a1, a2, a3。Peter要交换a1和a3，同时Paul要交换a1和a2，虽然对单个账户做了串行化，但交换操作还是可能产生不正确的结果。</p>
<p><strong>串行化的实现</strong></p>
<p>使用<strong>互斥元（mutex）</strong>的同步机制来实现串行化。mutex是一种对象，提供两种操作</p>
<p>1）获取（acquired）</p>
<p>2）释放（released）</p>
<p>一旦一个mutex被获取，对它的任何操作都必须等released之后。</p>
<p>在make-serializer的实现中，关联一个mutex。<strong>给定一个过程p，串行化组先返回一个mutex，再运行p，然后释放mutex，这样就能保证这个串行化组产生的所有过程中，一次只能运行一个p</strong>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-serializer</span>)</div><div class="line">   (<span class="name">let</span> ((<span class="name">mutex</span> (<span class="name">make-mutex</span>))</div><div class="line">         (<span class="name">lambda</span> (<span class="name">p</span>)</div><div class="line">           (<span class="name">define</span> (<span class="name">serialized-p</span> . args)</div><div class="line">             (<span class="name">mutex</span> 'acquired)</div><div class="line">             (<span class="name">let</span> ((<span class="name">val</span> (<span class="name">apply</span> p args)))</div><div class="line">               (<span class="name">mutex</span> 'release)</div><div class="line">               val))</div><div class="line">           serialized-p))))</div></pre></td></tr></table></figure>
<p>mutex是一个Boolean，在mutex的构造函数中，初始化为false。</p>
<p>在acquired时，先判断是否为false，若是，设置为true然后使用；否则在循环中等待，直到检测为false。</p>
<p>在acquired操作时，有一个<code>test-and-set!</code>方法，用于检查mutex并返回结果，其中若检查结果为false，在返回false之前还要设置为true。</p>
<p>这里的关键是，<code>test-and-set!</code>必须以原子操作的方式执行。比如说，一旦某进程检查了一个mutex发现是false，就必须在其他进程检查这个mutex之前完成为true的设置，否则mutex的机制就失效了。目前多CPU的电脑中提供了专门指令，直接在硬件中支持原子操作。</p>
<p><strong>死锁</strong></p>
<p>比如Peter要交换a2和a1，则进入了保护a2的串行化进程；Paul同时要交换a1和a2，则进入了保护a1的串行化进程。于是双方都无法继续了。</p>
<p>避免死锁的一种方式，就是首先给每个账户确定一个<strong>唯一的标识编号</strong>，再重写serialized-exchange，使每个进程总是首先去<strong>保护较低编号</strong>的账户。</p>
<p><strong>并发性、时间和通信</strong></p>
<p>我们已经看到，在并发系统的程序设计中，为什么需要去控制不同进程访问共享变量的事件发生的顺序，也看到了如何通过审慎地使用串行化去完成这方面的控制。但是并发性的基本问题比这些更深刻，因为，从一种更基本的观点看，“共享状态”究竟意味着什么，这件事常常并不清楚。</p>
<p>像<code>test-and-set!</code>这样的机制，都要求进程能在任意时刻去检查一个全局性的共享标志。在实现新型高速处理器时，由于在那里需要采用各种优化技术，例如流水线和缓存，因此就不可能在每个时刻都保持存储器内容的一致性，此时完成上述的检查将很有问题，也必然非常低效。正因为这样，在当前的多处理器系统里，串行化方式正在被并发控制的各种新技术取代，比如<strong>屏障同步</strong></p>
<h2 id="3-5-流"><a href="#3-5-流" class="headerlink" title="3.5 流"></a>3.5 流</h2><p>流是另一种模拟现实物理世界的设计策略，其核心思想就是<strong>用数学概念上的函数来表示一现实物体的改变</strong>，比如对象X，可以用<code>X(t)</code>来表示，如果我们想集中关心的是一个个时刻的x，那么就可以将它看作一个变化的量。如果关注的是这些值的整个时间史，那么就不需要强调其中的变化——这一函数本身是没有改变的。</p>
<p>在第二章我们学习了<strong>序列</strong>和<strong>表</strong>的概念（P84）。从抽象的观点看，流也是一个序列，但如果把流表示为表，必能完全揭示流处理的威力。这里要引入一种叫“<strong>延时求值</strong>”的技术。</p>
<h3 id="3-5-1-流作为延时的表"><a href="#3-5-1-流作为延时的表" class="headerlink" title="3.5.1 流作为延时的表"></a>3.5.1 流作为延时的表</h3><p>我们之前建立了一些对序列操作的抽象机制，比如map、filter、accumulate等。但如果我们将序列表示为表，表达可以更优雅，但效率很低。</p>
<p>例如，要计算一个区间内的素数之和。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">accumulate</span> op initial sequence)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? sequence)</div><div class="line">    initial</div><div class="line">    (<span class="name">op</span> (<span class="name">car</span> sequence)</div><div class="line">        (<span class="name">accumulate</span> op initial (<span class="name">cdr</span> sequence)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">prime</span>? n)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> n next)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">=</span> n next) #t)</div><div class="line">          ((<span class="name">=</span> <span class="number">0</span> (<span class="name">remainder</span> n next)) #f)</div><div class="line">          (<span class="name">else</span> (<span class="name">iter</span> n (<span class="name">+</span> next <span class="number">1</span>)))))</div><div class="line">  (<span class="name">iter</span> n <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">    '()</div><div class="line">    (<span class="name">cons</span> low (<span class="name">enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>) high))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">filter</span> predicate sequence)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? sequence) '())</div><div class="line">        ((<span class="name">predicate</span> (<span class="name">car</span> sequence))</div><div class="line">         (<span class="name">cons</span> (<span class="name">car</span> sequence)</div><div class="line">               (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence))))</div><div class="line">        (<span class="name">else</span> (<span class="name">filter</span> predicate (<span class="name">cdr</span> sequence)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</div><div class="line">  (<span class="name">define</span> (<span class="name">iter</span> count accum)</div><div class="line">    (<span class="name">cond</span> ((<span class="name">&gt;</span> count b) accum)</div><div class="line">          ((<span class="name">prime</span>? count) (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) (<span class="name">+</span> count accum))</div><div class="line">          (<span class="name">else</span> (<span class="name">iter</span> (<span class="name">+</span> count <span class="number">1</span>) accum))))</div><div class="line">    (<span class="name">iter</span> a <span class="number">0</span>)))</div></pre></td></tr></table></figure>
<p>如果用序列操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">sum-primes</span> a b)</div><div class="line">  (<span class="name">accumulate</span> + </div><div class="line">              <span class="number">0</span></div><div class="line">              (<span class="name">filter</span> prime? (<span class="name">enumerate-interval</span> a b))))</div></pre></td></tr></table></figure>
<p>在执行计算时，第一个程序只需要<strong>维护正在累积的和</strong>。第二个程序只有<strong>等enumate-interval构造完成这一区间所有整数的表之后</strong>，过滤器才能开始工作。这就需要大量的中间存储，增加计算开销。</p>
<p>流是一种非常巧妙的想法，使我们<strong>既可以利用各种序列操作，又不会带来将序列作为表操作的性能代价</strong>。</p>
<p>从表面上看，流也是表，但对他们进行操作的过程的名字不同。有构造函数cons-stream，以及两个选择函数stream-car和stream-cdr，满足如下约束</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">stream-car</span> (<span class="name">cons-stream</span> x y))=x</div><div class="line">(<span class="name">stream-cdr</span> (<span class="name">cons-stream</span> x y))=y</div></pre></td></tr></table></figure>
<p>我们用和第二章各种表操作（如list-ref，map和for-each等）类似的方式来操作流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">stream-car</span> s)</div><div class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc s)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span> </div><div class="line">       (<span class="name">proc</span> (<span class="name">stream-car</span> s))</div><div class="line">       (<span class="name">stream-map</span> proc (<span class="name">stream-cdr</span> s)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-for-each</span> proc s)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? s)</div><div class="line">      'done</div><div class="line">      (<span class="name">begin</span> </div><div class="line">        (<span class="name">proc</span> (<span class="name">stream-car</span> s))</div><div class="line">        (<span class="name">stream-for-each</span> proc </div><div class="line">                         (<span class="name">stream-cdr</span> s)))))</div></pre></td></tr></table></figure>
<p>核心的诉求是，<strong>对于流的cdr的求值要等到真正通过过程stream-cdr去访问它的时候再做，而不是在构造stream-cdr的时候做</strong>。</p>
<p>流的实现将基于一种称为<strong>delay</strong>的特殊形式，对于<code>(delay &lt;exp&gt;)</code>的求值不是对表达式求值，而是返回一个称为 <strong>延时对象</strong> 的对象。这个对象可以看做是对未来某个时间要对表达式求值的一个允诺。</p>
<p>和delay一起的还有一个<strong>force</strong>的过程，它以一个延时对象为参数，执行相应的求值工作，也就是说，force就用来迫使delay完成所允诺的求值。下面用这两个概念来构造流。</p>
<p>cons-stream的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cons-stream ⟨a⟩ ⟨b⟩)</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cons ⟨a⟩ (delay ⟨b⟩))</div></pre></td></tr></table></figure>
<p>可见，定义的时候，b还没有放到cons的cdr中。再看对cons的取值，</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) </div><div class="line">  (<span class="name">car</span> stream))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) </div><div class="line">  (<span class="name">force</span> (<span class="name">cdr</span> stream)))</div></pre></td></tr></table></figure>
<p><strong>流实现的行为方式</strong></p>
<p>我们再来看之前的过滤出素数的例子</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">stream-car</span> </div><div class="line"> (<span class="name">stream-cdr</span></div><div class="line">  (<span class="name">stream-filter</span> </div><div class="line">   prime? (<span class="name">stream-enumerate-interval</span> </div><div class="line">           <span class="number">10000</span> <span class="number">1000000</span>))))</div></pre></td></tr></table></figure>
<p>计算开始于对参数10000 1000000调用stream-enumerate-interval。它的实现是</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-enumerate-interval</span> low high)</div><div class="line">  (<span class="name">if</span> (<span class="name">&gt;</span> low high)</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span></div><div class="line">       low</div><div class="line">       (<span class="name">stream-enumerate-interval</span> (<span class="name">+</span> low <span class="number">1</span>)</div><div class="line">                                  high))))</div></pre></td></tr></table></figure>
<p>这样，由stream-enumerate-interval返回的结果就是通过cons-stream形成的：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10000</span></div><div class="line">      (<span class="name">delay</span> </div><div class="line">        (<span class="name">stream-enumerate-interval</span> </div><div class="line">         <span class="number">10001</span> </div><div class="line">         <span class="number">1000000</span>)))</div></pre></td></tr></table></figure>
<p>也就是说，当stream-enumerate-interval返回一个流的时候，car是10000，而cdr是一个<strong>允诺</strong>，表示当需要的时候，才在这个区间中枚举更多的内容。</p>
<p>再来看这个流程构建后的过滤</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) </div><div class="line">         the-empty-stream)</div><div class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</div><div class="line">         (<span class="name">cons-stream</span> </div><div class="line">          (<span class="name">stream-car</span> stream)</div><div class="line">          (<span class="name">stream-filter</span> </div><div class="line">           pred</div><div class="line">           (<span class="name">stream-cdr</span> stream))))</div><div class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> </div><div class="line">               pred </div><div class="line">               (<span class="name">stream-cdr</span> stream)))))</div></pre></td></tr></table></figure>
<p>首先检查stream-car，因为这个数不是素数（10000），再进一步检查stream-cdr，这个时候对stream-cdr的调用会迫使系统对延时的stream-enumerate-interval求值，这一次就返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10001</span></div><div class="line">      (<span class="name">delay</span> </div><div class="line">        (<span class="name">stream-enumerate-interval</span> </div><div class="line">         <span class="number">10002</span> </div><div class="line">         <span class="number">1000000</span>)))</div></pre></td></tr></table></figure>
<p>如此进行，直到找到第一个素数10007，此时stream-filter根据其定义返回</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons-stream</span> </div><div class="line"> (<span class="name">stream-car</span> stream)</div><div class="line"> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))</div></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">10007</span></div><div class="line">      (<span class="name">delay</span></div><div class="line">        (<span class="name">stream-filter</span></div><div class="line">         prime?</div><div class="line">         (<span class="name">cons</span> <span class="number">10008</span></div><div class="line">               (<span class="name">delay</span></div><div class="line">                 (<span class="name">stream-enumerate-interval</span> </div><div class="line">                  <span class="number">10009</span> <span class="number">1000000</span>))))))</div></pre></td></tr></table></figure>
<p>这样在stream-cdr中，又迫使延时的stream-filter求值，转而再去迫使stream-enumerate-interval求值，直到再找到下一个素数……</p>
<p>一般而言，可以将延时求值看做是一种“由需要驱动”的设计，其中流处理的每个阶段都仅仅活动到足够满足下一阶段的需要。</p>
<p><strong>delay和force的实现</strong></p>
<p>delay必须包装起一个表达式，使其可以在以后根据需要求值。delay实际上也是一个lambda表达式的语法糖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(delay ⟨exp⟩)</div><div class="line">=</div><div class="line">(lambda () ⟨exp⟩)</div></pre></td></tr></table></figure>
<p>而force就是简单调用由delay产生的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(define (force delayed-object)</div><div class="line">  (delayed-object))</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/congyihao/article/details/60747909" target="_blank" rel="noopener">Java 8 - 通过lambda表达式进行惰性计算</a></p>
<p>lambda表达式的出现使得JDK8内部发生了很多有趣的变化, 其中就包括惰性计算的特性.<br>这里以JDK标准库中的Logger为例, 1.8以前的log方法有如下签名:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String msg)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</div><div class="line">&gt;             <span class="keyword">return</span>;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msg);</div><div class="line">&gt;         doLog(lr);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>也就是说客户端程序调用log方法的时候, 无论最终是否触发log行为, <code>msg</code>始终是要被计算的. 若计算<code>msg</code>是非常耗时的行为, 那么无疑会造成不必要的开销. 下面是一个调用的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; log(Level.WARNING, <span class="string">"Log msg: "</span> + someExpensiveOperation());</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在java 1.8版本出现之后, 该方法多了如下重载:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, Supplier&lt;String&gt; msgSupplier)</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">if</span> (!isLoggable(level)) &#123;</div><div class="line">&gt;             <span class="keyword">return</span>;</div><div class="line">&gt;         &#125;</div><div class="line">&gt;         LogRecord lr = <span class="keyword">new</span> LogRecord(level, msgSupplier.get());</div><div class="line">&gt;         doLog(lr);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><code>Supplier</code>是一个<code>FunctionalInterface</code>, 也就是说现在的<code>log</code>方法可以接受一个无参的lambda表达式作为参数, 而计算的过程也被延迟到了<code>supplier.get()</code>的调用时. 改进后的调用例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// 注意: 传入的lambda表达式并不会立即执行, 而是在log中判断isLoggable(level)成功后才会执行</span></div><div class="line">&gt; log(Level.WARNING, () -&gt; <span class="string">"Log msg: "</span> + someExpensiveOperation());</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>这里还存在一个优化。有时需要多次对同一个delay求值，这就需要delay能保存上一次求出的值。于是可以将delay实现为一种特殊的记忆过程，它以一个无参过程为参数，返回该过程的记忆性版本。这种记忆性过程在第一次执行时将结果保存，下一次求值时再返回之前保存的</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">memo-proc</span> proc)</div><div class="line">  (<span class="name">let</span> ((<span class="name">already-run</span>? false) (<span class="name">result</span> false))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">if</span> (<span class="name">not</span> already-run?)</div><div class="line">          (<span class="name">begin</span> (<span class="name">set!</span> result (<span class="name">proc</span>))</div><div class="line">                 (<span class="name">set!</span> already-run? true)</div><div class="line">                 result)</div><div class="line">          result))))</div></pre></td></tr></table></figure>
<p>此后再定义delay，使得<code>(delay ⟨exp⟩)</code>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(memo-proc (lambda () ⟨exp⟩))</div></pre></td></tr></table></figure>
<h3 id="3-5-2-无穷流"><a href="#3-5-2-无穷流" class="headerlink" title="3.5.2 无穷流"></a>3.5.2 无穷流</h3><p>用流表示无穷长的序列。</p>
<p>比如以下的流可以表示所有正整数序列。这是一个无穷长的流。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</div><div class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">100</span>)</div><div class="line"><span class="number">101</span></div></pre></td></tr></table></figure>
<p>用这个就可以表示，例如不能被7整除的整数的流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">divisible</span>? x y) (<span class="name">=</span> (<span class="name">remainder</span> x y) <span class="number">0</span>))</div><div class="line"></div><div class="line">(<span class="name">define</span> no-sevens</div><div class="line">  (<span class="name">stream-filter</span> (<span class="name">lambda</span> (<span class="name">x</span>) </div><div class="line">                   (<span class="name">not</span> (<span class="name">divisible</span>? x <span class="number">7</span>)))</div><div class="line">                 integers))</div></pre></td></tr></table></figure>
<p>之后在用访问这个流元素的方式找出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; (stream-ref no-sevens 100)</div><div class="line">117</div></pre></td></tr></table></figure>
<p>也可以定义斐波那契数列的无穷流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">fibgen</span> a b)</div><div class="line">  (<span class="name">cons-stream</span> a (<span class="name">fibgen</span> b (<span class="name">+</span> a b))))</div><div class="line">(<span class="name">define</span> fibs (<span class="name">fibgen</span> <span class="number">0</span> <span class="number">1</span>))</div><div class="line"></div><div class="line">------------------</div><div class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">6</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<p>这样定义出的<code>fibs</code>是一个序对，其car是0，cdr是一个求值<code>(fibgen 1 1)</code>的允诺。求该表达式时，又将产生一个序对，car是，cdr是<code>(fibgen 1 2)</code>。</p>
<p><strong>隐式的定义流</strong></p>
<p>上面的integers和fibs是通过描述“生成”过程的方式定义的，这种过程是一个个的计算出流的元素。另一种就是<strong>隐式的求值</strong>。</p>
<p>例如，下面表达式将ones定义为1的一个无穷流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(define ones (cons-stream 1 ones))</div></pre></td></tr></table></figure>
<p>这种方式就像在定义一个递归过程：这里的ones是一个序对，car是1，cdr是求值ones的一个允诺。而对cdr的求值又得到了一个1和cdr的允诺。</p>
<p>add-streams操作产生出两个给定流的逐对元素之和</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">add-streams</span> s1 s2) </div><div class="line">  (<span class="name">stream-map</span> + s1 s2))</div></pre></td></tr></table></figure>
<p>现在可以用另一种方式定义整数流integers</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> integers </div><div class="line">  (<span class="name">cons-stream</span> <span class="number">1</span> (<span class="name">add-streams</span> ones integers)))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> integers <span class="number">10</span>)</div><div class="line"><span class="number">11</span></div></pre></td></tr></table></figure>
<p>首元素是1，其余是ones和integers之和。这样，integers的第二个元素就是1加上integers的第一个元素，也就是2。第三个元素就是1加上integers的第二个元素，也就是3。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">; 原版integers定义</span></div><div class="line">(<span class="name">define</span> (<span class="name">integers-starting-from</span> n)</div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   n (<span class="name">integers-starting-from</span> (<span class="name">+</span> n <span class="number">1</span>))))</div><div class="line">(<span class="name">define</span> integers (<span class="name">integers-starting-from</span> <span class="number">1</span>))</div></pre></td></tr></table></figure>
<p>同样的风格也可以定义出斐波那契数列</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> fibs </div><div class="line">  (<span class="name">cons-stream</span> </div><div class="line">   <span class="number">0</span> (<span class="name">cons-stream</span></div><div class="line">      <span class="number">1</span> (<span class="name">add-streams</span> </div><div class="line">         (<span class="name">stream-cdr</span> fibs) fibs))))</div><div class="line"></div><div class="line">&gt; (<span class="name">stream-ref</span> fibs <span class="number">11</span>)</div><div class="line"><span class="number">89</span></div></pre></td></tr></table></figure>
<p>这个定义是fib是一个从0和1开始的流，而这个流的其余部分都可以通过加起流fibs和移动了一个位置的fibs而得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    1 1 2 3 5  8 13 21 … = (stream-cdr fibs)</div><div class="line">    0 1 1 2 3  5  8 13 … = fibs</div><div class="line">0 1 1 2 3 5 8 13 21 34 … = fibs</div></pre></td></tr></table></figure>
<h3 id="3-5-5-函数式程序的模块化和对象的模块化"><a href="#3-5-5-函数式程序的模块化和对象的模块化" class="headerlink" title="3.5.5 函数式程序的模块化和对象的模块化"></a>3.5.5 函数式程序的模块化和对象的模块化</h3><p>正如在3.1.2中看到的，引进赋值的主要收益就是使我们可以<strong>增强系统的模块化</strong>，把一个大系统的状态中的某些部分封装，或者说<strong>“隐藏”到局部变量里</strong>。</p>
<p>流模型可以<strong>提供等价的模块化，同时又不必使用赋值</strong>。为了展示这方面的情况，我们可以重新实现前面在 3.1.2 节看过的π的蒙特卡罗估计，这次从流的观点出发来做。</p>
<p>这里的一个关键性的模块化问题，就是我们希望<strong>将一个随机数生成器的内部状态隐蔽起来，隔离在使用随机数的程序之外</strong>。从过程 <code>rand-update</code> 开始，它所提供的一系列值就是我们所需的随机数，用它作为一个随机数生成器：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> rand</div><div class="line">  (<span class="name">let</span> ((<span class="name">x</span> random-init))</div><div class="line">    (<span class="name">lambda</span> ()</div><div class="line">      (<span class="name">set!</span> x (<span class="name">rand-update</span> x))</div><div class="line">      x)))</div></pre></td></tr></table></figure>
<p>在这个流的描述中，看不到什么随机数生成器。在这里只有一个随机数的流，通过对rand-update的一系列顺序调用产生：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> random-numbers</div><div class="line">  (<span class="name">cons-stream</span> random-init</div><div class="line">               (<span class="name">stream-map</span> rand-update </div><div class="line">                           random-numbers)))</div></pre></td></tr></table></figure>
<p>用它构造出在<code>random-numbers</code>流中顺序的数对上的的Cesaro实验的输出流</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">map-successive-pairs</span> f s)</div><div class="line">  (<span class="name">cons-stream</span></div><div class="line">   (<span class="name">f</span> (<span class="name">stream-car</span> s) </div><div class="line">      (<span class="name">stream-car</span> (<span class="name">stream-cdr</span> s)))</div><div class="line">   (<span class="name">map-successive-pairs</span> </div><div class="line">    f (<span class="name">stream-cdr</span> (<span class="name">stream-cdr</span> s)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> cesaro-stream</div><div class="line">  (<span class="name">map-successive-pairs</span></div><div class="line">   (<span class="name">lambda</span> (<span class="name">r1</span> r2) (<span class="name">=</span> (<span class="name">gcd</span> r1 r2) <span class="number">1</span>))</div><div class="line">   random-numbers))</div></pre></td></tr></table></figure>
<p>现在将<code>cesaro-stream</code>扔进<code>monte-carlo</code>过程，该过程生成一个可能性估计的流。得到的结果就变换到一个估计π值的流。这一版本的程序<strong>不需要用参数去告诉它试多少次</strong>，只要查看更后面的值，就可以得到更好的π的估计。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">monte-carlo</span> experiment-stream </div><div class="line">                     passed </div><div class="line">                     failed)</div><div class="line">  (<span class="name">define</span> (<span class="name">next</span> passed failed)</div><div class="line">    (<span class="name">cons-stream</span></div><div class="line">     (<span class="name">/</span> passed (<span class="name">+</span> passed failed))</div><div class="line">     (<span class="name">monte-carlo</span></div><div class="line">      (<span class="name">stream-cdr</span> experiment-stream) </div><div class="line">      passed </div><div class="line">      failed)))</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-car</span> experiment-stream)</div><div class="line">      (<span class="name">next</span> (<span class="name">+</span> passed <span class="number">1</span>) failed)</div><div class="line">      (<span class="name">next</span> passed (<span class="name">+</span> failed <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> pi</div><div class="line">  (<span class="name">stream-map</span></div><div class="line">   (<span class="name">lambda</span> (<span class="name">p</span>) (<span class="name">sqrt</span> (<span class="name">/</span> <span class="number">6</span> p)))</div><div class="line">   (<span class="name">monte-carlo</span> cesaro-stream <span class="number">0</span> <span class="number">0</span>)))</div><div class="line"></div><div class="line">------------------------</div><div class="line">&gt; (<span class="name">stream-ref</span> pi <span class="number">1000</span>)</div><div class="line"><span class="number">3.24037034920393</span></div></pre></td></tr></table></figure>
<p>而且，这一方法也非常模块化，这里<strong>构造了一个一般性的monte-carlo过程，它可以处理任何试验，而且这里没有赋值，也没有局部状态</strong>。</p>
<p>附：流执行的预先定义函数</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; stream-&gt;list</span></div><div class="line"></div><div class="line">(<span class="name">define</span> stream-&gt;list</div><div class="line">  (<span class="name">lambda</span> (<span class="name">strm</span> n)</div><div class="line">    (<span class="name">if</span> (<span class="name">or</span> (<span class="name">stream-null</span>? strm) (<span class="name">zero</span>? n))</div><div class="line">        '()</div><div class="line">        (<span class="name">cons</span> (<span class="name">stream-car</span> strm)</div><div class="line">              (<span class="name">stream-&gt;list</span> (<span class="name">stream-cdr</span> strm) (<span class="name">sub1</span> n))))))</div><div class="line"></div><div class="line"></div><div class="line">(<span class="name">define-syntax</span> delay</div><div class="line">  (<span class="name">syntax-rules</span> ()</div><div class="line">    ((<span class="name">_</span> exp) (<span class="name">lambda</span> () exp))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">force</span> delayed-object)</div><div class="line">  (<span class="name">delayed-object</span>))</div><div class="line"></div><div class="line">(<span class="name">define-syntax</span> cons-stream</div><div class="line">  (<span class="name">syntax-rules</span> ()</div><div class="line">    ((<span class="name">_</span> a b) (<span class="name">cons</span> a (<span class="name">delay</span> b)))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-car</span> stream) (<span class="name">car</span> stream))</div><div class="line"> </div><div class="line">(<span class="name">define</span> (<span class="name">stream-cdr</span> stream) (<span class="name">force</span> (<span class="name">cdr</span> stream)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-null</span>? stream)</div><div class="line">  (<span class="name">null</span>? stream))</div><div class="line"></div><div class="line">(<span class="name">define</span> the-empty-stream '())</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-ref</span> s n)</div><div class="line">  (<span class="name">if</span> (<span class="name">=</span> n <span class="number">0</span>)</div><div class="line">      (<span class="name">stream-car</span> s)</div><div class="line">      (<span class="name">stream-ref</span> (<span class="name">stream-cdr</span> s) (<span class="name">-</span> n <span class="number">1</span>))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-map</span> proc . argstreams)</div><div class="line">  (<span class="name">if</span> (<span class="name">stream-null</span>? (<span class="name">car</span> argstreams))</div><div class="line">      the-empty-stream</div><div class="line">      (<span class="name">cons-stream</span></div><div class="line">       (<span class="name">apply</span> proc (<span class="name">map</span> stream-car argstreams))</div><div class="line">       (<span class="name">apply</span> stream-map</div><div class="line">              (<span class="name">cons</span> proc</div><div class="line">                    (<span class="name">map</span> stream-cdr</div><div class="line">                         argstreams))))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">stream-filter</span> pred stream)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">stream-null</span>? stream) the-empty-stream)</div><div class="line">        ((<span class="name">pred</span> (<span class="name">stream-car</span> stream))</div><div class="line">         (<span class="name">cons-stream</span> (<span class="name">stream-car</span> stream)</div><div class="line">                      (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream))))</div><div class="line">        (<span class="name">else</span> (<span class="name">stream-filter</span> pred (<span class="name">stream-cdr</span> stream)))))</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liujiacai.net/blog/2015/12/26/sicp-chapter3-summary/" target="_blank" rel="noopener">SICP 第三章总结</a></p>
<p><a href="https://github.com/rsy56640/daily_learning/tree/master/SICP#3" target="_blank" rel="noopener">SICP note</a></p>
<p><a href="https://sicp.liujiacai.net/chap3/exercise.html" target="_blank" rel="noopener">第三章习题索引</a></p>
<p><a href="https://sarabander.github.io/sicp/html/3_002e5.xhtml" target="_blank" rel="noopener">第三章英文版</a></p>
<p><a href="https://wizardforcel.gitbooks.io/sicp-py/content/" target="_blank" rel="noopener">SICP Python 描述 中文版</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/hadoop-spark/hive笔记/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/hadoop-spark/hive笔记/" class="post-title-link" itemprop="url">hive笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-19 13:06:22" itemprop="dateModified" datetime="2019-06-19T13:06:22+08:00">2019-06-19</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hadoop-spark/" itemprop="url" rel="index"><span itemprop="name">hadoop-spark</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/hadoop-spark/hive笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/hadoop-spark/hive笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="插入hive表控制part文件数量"><a href="#插入hive表控制part文件数量" class="headerlink" title="插入hive表控制part文件数量"></a>插入hive表控制part文件数量</h1><p><a href="http://blog.sina.com.cn/s/blog_604c7cdd0102wbsw.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_604c7cdd0102wbsw.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- 每个文件上限500M</div><div class="line">set hive.exec.reducers.bytes.per.reducer=512000000;</div><div class="line">insert overwrite table carthage.gps_address_info_weekly_bak PARTITION(DATA_DATE=&apos;2019-01-15&apos;)</div><div class="line">select * from carthage.gps_address_info DISTRIBUTE by RAND();</div><div class="line">-- DISTRIBUTE by RAND()主要靠这个控制reduce的文件数</div></pre></td></tr></table></figure>
<h1 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set hive.mapred.mode=strict</div></pre></td></tr></table></figure>
<p>有助于前置解决一些语法和可能的逻辑错误。</p>
<h1 id="限制小文件数量"><a href="#限制小文件数量" class="headerlink" title="限制小文件数量"></a>限制小文件数量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set mapred.max.split.size=256000000;        -- 决定每个map处理的最大的文件大小，单位为B</div><div class="line">set mapred.min.split.size.per.node=10000000;         -- 节点中可以处理的最小的文件大小</div><div class="line">set mapred.min.split.size.per.rack=10000000;          -- 机架中可以处理的最小的文件大小</div></pre></td></tr></table></figure>
<h1 id="查询时如何去掉重复数据"><a href="#查询时如何去掉重复数据" class="headerlink" title="查询时如何去掉重复数据"></a>查询时如何去掉重复数据</h1><p>假设数据为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name  adx        tran_id                  cost        ts</div><div class="line">ck        5         125.168.10.0           33.00   1407234660</div><div class="line">ck        5         187.18.99.00           33.32   1407234661</div><div class="line">ck        5         125.168.10.0           33.24   1407234661</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from (select *,row_number() over (partition by tran_id order by timestamp asc) num from table) t where t.num=1;</div></pre></td></tr></table></figure>
<blockquote>
<p>附上：<br><strong>ROW_NUMBER() OVER函数的基本用法 </strong></p>
<p>语法：ROW_NUMBER() OVER(PARTITION BY COLUMN ORDER BY COLUMN) </p>
<p>简单的说row_number()从1开始，为每一条分组记录返回一个数字，这里的ROW_NUMBER() OVER (ORDER BY xlh DESC) 是先把xlh列降序，再为降序以后的没条xlh记录返回一个序号。<br>示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; xlh           row_num </div><div class="line">&gt; 1700              1 </div><div class="line">&gt; 1500              2 </div><div class="line">&gt; 1085              3 </div><div class="line">&gt; 710                4 </div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>row_number() OVER (PARTITION BY COL1 ORDER BY COL2) 表示根据COL1分组，在分组内部根据 COL2排序，而此函数计算的值就表示每组内部排序后的顺序编号（组内连续的唯一的) </p>
</blockquote>
<h1 id="split后的数组长度"><a href="#split后的数组长度" class="headerlink" title="split后的数组长度"></a>split后的数组长度</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size(split(driving_districts,&apos;;&apos;))</div></pre></td></tr></table></figure>
<h1 id="切换队列"><a href="#切换队列" class="headerlink" title="切换队列"></a>切换队列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set mapred.job.queue.name=data;</div></pre></td></tr></table></figure>
<p>sqoop切换队列是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-D mapred.job.queue.name=data</div></pre></td></tr></table></figure>
<h1 id="加载hdfs的udf"><a href="#加载hdfs的udf" class="headerlink" title="加载hdfs的udf"></a>加载hdfs的udf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ADD JAR hdfs://iclick/zyz/udf/zyz_udf2.jar;</div><div class="line">CREATE TEMPORARY FUNCTION get_region as &apos;org.apache.hadoop.hive.ql.udf.Ip2GeoCodeUDF&apos;;</div></pre></td></tr></table></figure>
<h1 id="Hive-Trash"><a href="#Hive-Trash" class="headerlink" title="Hive Trash"></a>Hive Trash</h1><p>hive删除表时，会移除表的元数据和数据，而HDFS上的数据，如果配置了Trash，会移到.Trash/Current目录下。删除外部表时，表中的数据不会被删除。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>用groupby代替distinct，少用orderby</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">同事写了个hive的sql语句，执行效率特别慢，跑了一个多小时程序只是map完了，reduce进行到20%。</div><div class="line">该Hive语句如下：</div><div class="line">select count(distinct ip) </div><div class="line">from (select ip as ip from comprehensive.f_client_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot;  </div><div class="line">union all </div><div class="line">select pub_ip as ip from f_app_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot; </div><div class="line">union all select ip as ip from format_log.format_pv1 where year=&quot;2013&quot; and month=&quot;10&quot; and url_first_id=1 </div><div class="line">) d </div><div class="line"></div><div class="line">       分析：select ip as ip from comprehensive.f_client_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot;这个语句筛选出来的数据约有10亿条，select pub_ip as ip from f_app_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot;约有10亿条条，select ip as ip from format_log.format_pv1 where year=&quot;2013&quot; and month=&quot;10&quot; and url_first_id=1 筛选出来的数据约有10亿条，总的数据量大约30亿条。这么大的数据量，使用disticnt函数，所有的数据只会shuffle到一个reducer上，导致reducer数据倾斜严重。</div><div class="line">       解决办法：</div><div class="line">       首先，通过使用groupby，按照ip进行分组。改写后的sql语句如下：</div><div class="line">select count(*) </div><div class="line">from </div><div class="line">(select ip </div><div class="line">from</div><div class="line">(select ip as ip from comprehensive.f_client_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot; </div><div class="line">union all </div><div class="line">select pub_ip as ip from f_app_boot_daily where year=&quot;2013&quot; and month=&quot;10&quot; </div><div class="line">union all select ip as ip from format_log.format_pv1 where year=&quot;2013&quot; and month=&quot;10&quot; and url_first_id=1</div><div class="line">) d </div><div class="line">group by ip ) b </div><div class="line">       然后，合理的设置reducer数量，将数据分散到多台机器上。set mapred.reduce.tasks=50; </div><div class="line">       经过优化后，速度提高非常明显。整个作业跑完大约只需要20多分钟的时间。</div></pre></td></tr></table></figure>
<p>提高order by的性能<a href="https://blog.csdn.net/djd1234567/article/details/51917603" target="_blank" rel="noopener">https://blog.csdn.net/djd1234567/article/details/51917603</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Hive中的order by跟传统的sql语言中的order by作用是一样的，会对查询的结果做一次全局排序，所以说，只有hive的sql中制定了order by所有的数据都会到同一个reducer进行处理（不管有多少map，也不管文件有多少的block只会启动一个reducer）。但是对于大量数据这 将会消耗很长的时间去执行。</div><div class="line"></div><div class="line">    这里跟传统的sql还有一点区别：如果指定了hive.mapred.mode=strict（默认值是nonstrict）,这时就必须指定limit 来限制输出条数，原因是：所有的数据都会在同一个reducer端进行，数据量大的情况下可能不能出结果，那么在这样的严格模式下，必须指定输出的条数。</div><div class="line"></div><div class="line">    所以数据量大的时候能不用order by就不用，可以使用sort by结合distribute by来进行实现。sort by是局部排序，而distribute by是控制map怎么划分reducer。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    Hive中指定了sort by，那么在每个reducer端都会做排序，也就是说保证了局部有序（每个reducer出来的数据是有序的，但是不能保证所有的数据是有序的，除非只有一个reducer），好处是：执行了局部排序之后可以为接下去的全局排序提高不少的效率（其实就是做一次归并排序就可以做到全局排序了）</div><div class="line"></div><div class="line"></div><div class="line">    ditribute by是控制map的输出在reducer是如何划分的，举个例子，我们有一张表，mid是指这个store所属的商户，money是这个商户的盈利，name是这个store的名字</div><div class="line"></div><div class="line">store:</div><div class="line"></div><div class="line"></div><div class="line">mid	money	name</div><div class="line">AA	15.0	商店1</div><div class="line">AA	20.0	商店2</div><div class="line">BB	22.0	商店3</div><div class="line">CC	44.0	商店4</div><div class="line">    执行hive语句：</div><div class="line"></div><div class="line">[sql] view plain copy</div><div class="line">select mid, money, name from store distribute by mid sort by mid asc, money asc  </div><div class="line">我 们所有的mid相同的数据会被送到同一个reducer去处理，这就是因为指定了distribute by mid，这样的话就可以统计出每个商户中各个商店盈利的排序了（这个肯定是全局有序的，因为相同的商户会放到同一个reducer去处理）。这里需要注意 的是distribute by必须要写在sort by之前。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">cluster by</div><div class="line">    cluster by的功能就是distribute by和sort by相结合，如下2个语句是等价的：</div><div class="line"></div><div class="line">[sql] view plain copy</div><div class="line">select mid, money, name from store cluster by mid  </div><div class="line">select mid, money, name from store distribute by mid sort by mid  </div><div class="line">    如果需要获得与上面的中语句一样的效果：</div><div class="line"></div><div class="line">[sql] view plain copy</div><div class="line">select mid, money, name from store cluster by mid sort by money  </div><div class="line">    注意被cluster by指定的列只能是降序，不能指定asc和desc。</div></pre></td></tr></table></figure>
<h1 id="问题集"><a href="#问题集" class="headerlink" title="问题集"></a>问题集</h1><h2 id="查询ES表报错"><a href="#查询ES表报错" class="headerlink" title="查询ES表报错"></a>查询ES表报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Failed with exception java.io.IOException:org.elasticsearch.hadoop.rest.EsHadoopInvalidRequest: The number of slices [1126] is too large. It must be less than [1024]. This limit can be set by changing the [index.max_slices_per_scroll] index level settin</div></pre></td></tr></table></figure>
<p>修改es的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PUT /megacorp/_settings</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">  &quot;index&quot;: &#123;</div><div class="line"></div><div class="line">    &quot;max_slices_per_scroll&quot; : 1126</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="上传hive-UDF包后重启hive-server报错"><a href="#上传hive-UDF包后重启hive-server报错" class="headerlink" title="上传hive UDF包后重启hive server报错"></a>上传hive UDF包后重启hive server报错</h2><h2 id="hive-udf没有权限执行"><a href="#hive-udf没有权限执行" class="headerlink" title="hive udf没有权限执行"></a>hive udf没有权限执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error while compiling statement: FAILED: SemanticException No valid privileges User dmp does not have privileges for CREATEFUNCTION The required privileges: Server=server1-&gt;URI=file:///home/hive/aux_libs/carthage-common-udf-hive-test.jar-&gt;action=*;</div></pre></td></tr></table></figure>
<h2 id="没有找到jar包的报错"><a href="#没有找到jar包的报错" class="headerlink" title="没有找到jar包的报错"></a>没有找到jar包的报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error while compiling statement: FAILED: SemanticException [Error 10014]: Line 1:7 Wrong arguments &apos;70.0&apos;: org.apache.hadoop.hive.ql.metadata.HiveException: Unable to execute method public java.lang.String com.mljr.carthage.common.geo.udf.hive.UDFGeoLocation.evaluate(java.lang.Double,java.lang.Double) on object com.mljr.carthage.common.geo.udf.hive.UDFGeoLocation@54ee9573 of class com.mljr.carthage.common.geo.udf.hive.UDFGeoLocation with arguments &#123;50.0:java.lang.Double, 70.0:java.lang.Double&#125; of size 2</div></pre></td></tr></table></figure>
<p>其他都是可以的，就这个udf的第二个参数一直报错。经测试，还是UDF本身的问题，跟参数的设置没有关系。</p>
<p>最后发现问题是udf的jar包上传后，关联的一些jar包没有打进去，手动加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</div><div class="line">				&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</div><div class="line">				&lt;version&gt;1.6&lt;/version&gt;</div><div class="line">				&lt;executions&gt;</div><div class="line">					&lt;execution&gt;</div><div class="line">						&lt;phase&gt;package&lt;/phase&gt;</div><div class="line">						&lt;goals&gt;</div><div class="line">							&lt;goal&gt;shade&lt;/goal&gt;</div><div class="line">						&lt;/goals&gt;</div><div class="line">						&lt;configuration&gt;</div><div class="line">							&lt;artifactSet&gt;</div><div class="line">								&lt;includes&gt;</div><div class="line">									&lt;include&gt;com.mljr.carthage:carthage-common-geo&lt;/include&gt;</div><div class="line">									&lt;include&gt;com.alibaba:fastjson&lt;/include&gt;</div><div class="line">									&lt;include&gt;com.github.davidmoten:geo&lt;/include&gt;</div><div class="line">									&lt;include&gt;com.github.davidmoten:grumpy-core&lt;/include&gt;</div><div class="line">								&lt;/includes&gt;</div><div class="line">							&lt;/artifactSet&gt;</div><div class="line">						&lt;/configuration&gt;</div><div class="line">					&lt;/execution&gt;</div><div class="line">				&lt;/executions&gt;</div><div class="line">			&lt;/plugin&gt;</div></pre></td></tr></table></figure>
<h1 id="hive用高版本的UDF"><a href="#hive用高版本的UDF" class="headerlink" title="hive用高版本的UDF"></a>hive用高版本的UDF</h1><p>在hive2.0中有类似于months_between的函数，可以实现2个时间之间的月份差。但是低版本没有这个函数</p>
<p>解决：</p>
<p>下载hive-2.1源码包</p>
<p><a href="http://mirrors.hust.edu.cn/apache/hive/hive-2.2.0/" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/apache/hive/hive-2.2.0/</a></p>
<p>导入eclipse，查找months_between</p>
<p>在org.apache.hadoop.hive.ql.udf.generic包下找到GenericUDFMonthsBetween类，移植即可</p>
<p>/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFMonthsBetween.java</p>
<h1 id="String转date"><a href="#String转date" class="headerlink" title="String转date"></a>String转date</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cast(to_date(from_unixtime(unix_timestamp(&apos;12-05-2010&apos;, &apos;dd-MM-yyyy&apos;))) as date)</div></pre></td></tr></table></figure>
<h1 id="MapJoin异常问题处理总结"><a href="#MapJoin异常问题处理总结" class="headerlink" title="MapJoin异常问题处理总结"></a>MapJoin异常问题处理总结</h1><p><a href="https://yq.aliyun.com/articles/64306" target="_blank" rel="noopener">https://yq.aliyun.com/articles/64306</a></p>
<h1 id="替换hive分隔符"><a href="#替换hive分隔符" class="headerlink" title="替换hive分隔符"></a>替换hive分隔符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;.bak&apos; &apos;s/^A/,/g&apos; baseinfo05.csv</div></pre></td></tr></table></figure>
<p><code>^A</code>要用ctrl+V+A打出来</p>
<h1 id="LOAD-DATA"><a href="#LOAD-DATA" class="headerlink" title="LOAD DATA"></a>LOAD DATA</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOAD DATA [LOCAL] INPATH &apos;filepath&apos; [OVERWRITE] INTO TABLE tablename[PARTITION (partcol1=val1,partcol2=val2,…)]</div></pre></td></tr></table></figure>
<p>最好不要用LOCAL，要从hadoop加载数据。local读的是hive服务器的本地路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">from pyhive import hive</div><div class="line">from TCLIService.ttypes import TOperationState</div><div class="line"></div><div class="line"># 打开hive连接</div><div class="line">hiveConn = hive.connect(host=&apos;192.168.83.135&apos;,port=11111,username=&apos;hadoop&apos;)</div><div class="line">cursor = hiveConn.cursor()</div><div class="line"></div><div class="line"># 执行sql语句</div><div class="line">sql = &apos;&apos;&apos; LOAD DATA LOCAL INPATH &apos;/home/hadoop/HivePy/employee.txt&apos; OVERWRITE INTO TABLE userdbbypy.employee &apos;&apos;&apos;</div><div class="line">cursor.execute(sql, async=True)</div><div class="line"></div><div class="line"># 得到执行语句的状态</div><div class="line">status = cursor.poll().operationState</div><div class="line">print &quot;status:&quot;,status</div><div class="line"></div><div class="line"># 关闭hive连接</div><div class="line">cursor.close()</div><div class="line">hiveConn.close()</div></pre></td></tr></table></figure>
<h1 id="return-code-3"><a href="#return-code-3" class="headerlink" title="return code 3"></a>return code 3</h1><p>试试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set hive.vectorized.execution.enabled=false;</div></pre></td></tr></table></figure>
<h1 id="hive锁表"><a href="#hive锁表" class="headerlink" title="hive锁表"></a>hive锁表</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Completed compiling command</div></pre></td></tr></table></figure>
<p>若卡在上面的语句，说明锁表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">show locks carthage_dev.baseinfo_personal_info;</div><div class="line">-- 如果是</div><div class="line"></div><div class="line">unlock table dwh_dml_risk_dev.rec_car_operation;</div><div class="line">show locks carthage_dev.baseinfo_personal_info partition(data_date=&apos;20180517&apos;);</div><div class="line">unlock table dwh_dml_risk_dev.rec_car_operation partition(data_date=&apos;2018-09-30&apos;);</div></pre></td></tr></table></figure>
<p>hive解锁的脚本是<code>all_hive_unlock.sh</code></p>
<h1 id="hive新增列报错"><a href="#hive新增列报错" class="headerlink" title="hive新增列报错"></a>hive新增列报错</h1><p>在添加字段是可以通过CASCADE关键字来，避免出现这种问题。如alter table table_name add columns(age int) CASCADE</p>
<p><a href="https://qubole.zendesk.com/hc/en-us/articles/115002396646-Hive-Null-Pointer-Exception-in-select-query-after-modifying-table-definition" target="_blank" rel="noopener">https://qubole.zendesk.com/hc/en-us/articles/115002396646-Hive-Null-Pointer-Exception-in-select-query-after-modifying-table-definition</a></p>
<blockquote>
<p>This can happen in the scenario where table definition and specific partition definition is different, and the underlying data matches table definition but not partition definition.</p>
<p>When a table with partitions is altered to add a column using statement:</p>
<p><em>ALTER TABLE <tablename> ADD COLUMNS (c1 int);</tablename></em></p>
<p>The table definition for existing partitions don’t get modified as per the above statement. As a result of this there is a mismatch between partition and table definition. </p>
<p>This is ok if the partition data matches the definition of partition, but if the data matches definition of table itself, NPE is thrown as there is a mismatch in data vs definition.</p>
<p>To avoid this issue, this statement should be used in hadoop2</p>
<p><em>ALTER TABLE <tablename> ADD COLUMNS (c1 int) CASCADE;</tablename></em> </p>
<p>In case of hadoop1, CASCADE option is not available. Hence, as long as the table is external table, following can be done:</p>
<ol>
<li>Drop and recreate partitions for this table</li>
<li>Alter partition definition for specific partition having issues</li>
</ol>
</blockquote>
<p>用了cascade 无效。</p>
<p>找到原因：</p>
<p>hive表是ORC格式的，因此cascade无效，若改成text格式则成功。</p>
<p>解决方案：</p>
<p>若必须是ORC格式，建表是先预留若干字段，后期改名字</p>
<h1 id="hive分区解锁"><a href="#hive分区解锁" class="headerlink" title="hive分区解锁"></a>hive分区解锁</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show locks carthage_dev.baseinfo_personal_info;</div><div class="line">unlock table carthage_dev.baseinfo_personal_info;</div><div class="line">show locks carthage_dev.baseinfo_personal_info partition(data_date=&apos;20180517&apos;);</div><div class="line">unlock table carthage_dev.baseinfo_personal_info partition(data_date=&apos;20180517&apos;);</div></pre></td></tr></table></figure>
<p>解锁的技巧：</p>
<p>1、定位哪张表锁住，可以分批执行sql，定位关键表</p>
<p>2、show locks并下载，观察锁表的状态，通过</p>
<p><code>show locks table extends</code>可以看依赖的表</p>
<p>3、用脚本all_hive_unlock.sh解锁</p>
<h2 id="hive-column-rename"><a href="#hive-column-rename" class="headerlink" title="hive column rename"></a>hive column rename</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table carthage_dev.gps_wx_stop_status CHANGE stop_region_center_lon stop_status_center_lon string</div></pre></td></tr></table></figure>
<h1 id="hive配置"><a href="#hive配置" class="headerlink" title="hive配置"></a>hive配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-- 输出为gzip</div><div class="line">set hive.exec.compress.output=true;    </div><div class="line">set mapred.output.compression.codec=org.apache.hadoop.io.compress.GzipCodec;</div><div class="line">-- 输出为一个文件</div><div class="line">set mapred.reduce.tasks=1;</div></pre></td></tr></table></figure>
<h1 id="hive-timestamp转时间"><a href="#hive-timestamp转时间" class="headerlink" title="hive timestamp转时间"></a>hive timestamp转时间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">from_unixtime(unix_timestamp(),‘yyyy/MM/dd HH:mm:ss’);</div><div class="line"></div><div class="line">from_unixtime(cast(cast(time as bigint)/1000 as bigint),&apos;yyyy/MM/dd HH:mm:ss&apos;)</div></pre></td></tr></table></figure>
<h1 id="常用日期函数"><a href="#常用日期函数" class="headerlink" title="常用日期函数"></a>常用日期函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">to_date：日期时间转日期函数    </div><div class="line">	select to_date(&apos;2018-04-02 13:34:12&apos;);   输出：2018-04-02   </div><div class="line">from_unixtime：转化unix时间戳到当前时区的时间格式    </div><div class="line">	select from_unixtime(1524573762,&apos;yyyy-MM-dd HH:mm:ss&apos;);    输出：2018-04-24 20:42:42</div><div class="line">unix_timestamp：获取当前unix时间戳    </div><div class="line">	select unix_timestamp();    输出：1524573762  </div><div class="line">	select unix_timestamp(&apos;2018-04-01 13:01:20&apos;);  输出：1522558880</div><div class="line">datediff：返回开始日期减去结束日期的天数    </div><div class="line">	select datediff(&apos;2018-04-09&apos;,&apos;2018-04-01&apos;);    输出：8    </div><div class="line">date_sub：返回日期前n天的日期    </div><div class="line">	select date_sub(&apos;2018-04-09&apos;,4);    输出：2018-04-05    </div><div class="line">date_add：返回日期后n天的日期    </div><div class="line">	select date_add(&apos;2018-04-09&apos;,4);    输出：2018-04-13  </div><div class="line">add_months：月份增加函数</div><div class="line">	select add_months(&apos;2018-02-10&apos;, 2 );    输出：2018-04-10 </div><div class="line">last_day：返回当月底日期</div><div class="line">	select last_day(&apos;2018-02-21&apos;);    输出：2018-02-28</div></pre></td></tr></table></figure>
<h1 id="hive-字符串函数"><a href="#hive-字符串函数" class="headerlink" title="hive 字符串函数"></a>hive 字符串函数</h1><p><strong>1. 字符串长度函数：length</strong></p>
<p>语法: length(string A)</p>
<p>返回值: int</p>
<p>说明：返回字符串A的长度</p>
<p>举例：</p>
<p>hive&gt; select length(‘abcedfg’) from lxw_dual;</p>
<p>7</p>
<p><strong>2. 字符串反转函数：reverse</strong></p>
<p>语法: reverse(string A)</p>
<p>返回值: string</p>
<p>说明：返回字符串A的反转结果</p>
<p>举例：</p>
<p>hive&gt; select reverse(abcedfg’) from lxw_dual;</p>
<p>gfdecba</p>
<p><strong>3. 字符串连接函数：concat</strong></p>
<p>语法: concat(string A, string B…)</p>
<p>返回值: string</p>
<p>说明：返回输入字符串连接后的结果，支持任意个输入字符串</p>
<p>举例：</p>
<p>hive&gt; select concat(‘abc’,’def’,’gh’) from lxw_dual;</p>
<p>abcdefgh</p>
<p><strong>4. 带分隔符字符串连接函数：concat_ws</strong></p>
<p>语法: concat_ws(string SEP, string A, string B…)</p>
<p>返回值: string</p>
<p>说明：返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符</p>
<p>举例：</p>
<p>hive&gt; select concat_ws(‘,’,’abc’,’def’,’gh’) from lxw_dual;</p>
<p>abc,def,gh</p>
<p><strong>5. 字符串截取函数：substr,substring</strong></p>
<p>语法: substr(string A, int start),substring(string A, int start)</p>
<p>返回值: string</p>
<p>说明：返回字符串A从start位置到结尾的字符串</p>
<p>举例：</p>
<p>hive&gt; select substr(‘abcde’,3) from lxw_dual;</p>
<p>cde</p>
<p>hive&gt; select substring(‘abcde’,3) from lxw_dual;</p>
<p>cde</p>
<p>hive&gt;  selectsubstr(‘abcde’,-1) from lxw_dual;  （和ORACLE相同）</p>
<p>e</p>
<p><strong>6. 字符串截取函数：substr,substring</strong></p>
<p>语法: substr(string A, int start, int len),substring(string A, intstart, int len)</p>
<p>返回值: string</p>
<p>说明：返回字符串A从start位置开始，长度为len的字符串</p>
<p>举例：</p>
<p>hive&gt; select substr(‘abcde’,3,2) from lxw_dual;</p>
<p>cd</p>
<p>hive&gt; select substring(‘abcde’,3,2) from lxw_dual;</p>
<p>cd</p>
<p>hive&gt;select substring(‘abcde’,-2,2) from lxw_dual;</p>
<p>de</p>
<p><strong>7. 字符串转大写函数：upper,ucase</strong></p>
<p>语法: upper(string A) ucase(string A)</p>
<p>返回值: string</p>
<p>说明：返回字符串A的大写格式</p>
<p>举例：</p>
<p>hive&gt; select upper(‘abSEd’) from lxw_dual;</p>
<p>ABSED</p>
<p>hive&gt; select ucase(‘abSEd’) from lxw_dual;</p>
<p>ABSED</p>
<p><strong>8. 字符串转小写函数：lower,lcase</strong></p>
<p>语法: lower(string A) lcase(string A)</p>
<p>返回值: string</p>
<p>说明：返回字符串A的小写格式</p>
<p>举例：</p>
<p>hive&gt; select lower(‘abSEd’) from lxw_dual;</p>
<p>absed</p>
<p>hive&gt; select lcase(‘abSEd’) from lxw_dual;</p>
<p>absed</p>
<p><strong>9. 去空格函数：trim</strong></p>
<p>语法: trim(string A)</p>
<p>返回值: string</p>
<p>说明：去除字符串两边的空格</p>
<p>举例：</p>
<p>hive&gt; select trim(‘ abc ‘) from lxw_dual;</p>
<p>abc</p>
<p><strong>10. 左边去空格函数：ltrim</strong></p>
<p>语法: ltrim(string A)</p>
<p>返回值: string</p>
<p>说明：去除字符串左边的空格</p>
<p>举例：</p>
<p>hive&gt; select ltrim(‘ abc ‘) from lxw_dual;</p>
<p>abc</p>
<p><strong>11. 右边去空格函数：rtrim</strong></p>
<p>语法: rtrim(string A)</p>
<p>返回值: string</p>
<p>说明：去除字符串右边的空格</p>
<p>举例：</p>
<p>hive&gt; select rtrim(‘ abc ‘) from lxw_dual;</p>
<p>abc</p>
<p><strong>12. 正则表达式替换函数：regexp_replace</strong></p>
<p>语法: regexp_replace(string A, string B, string C)</p>
<p>返回值: string</p>
<p>说明：将字符串A中的符合java正则表达式B的部分替换为C。注意，在有些情况下要使用转义字符,类似oracle中的regexp_replace函数。</p>
<p>举例：</p>
<p>hive&gt; select regexp_replace(‘foobar’, ‘oo|ar’, ‘’) from lxw_dual;</p>
<p>fb</p>
<p><strong>13. 正则表达式解析函数：regexp_extract</strong></p>
<p>语法: regexp_extract(string subject, string pattern, int index)</p>
<p>返回值: string</p>
<p>说明：将字符串subject按照pattern正则表达式的规则拆分，返回index指定的字符。</p>
<p>举例：</p>
<p>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 1) fromlxw_dual;</p>
<p>the</p>
<p>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 2) fromlxw_dual;</p>
<p>bar</p>
<p>hive&gt; select regexp_extract(‘foothebar’, ‘foo(.*?)(bar)’, 0) fromlxw_dual;</p>
<p>foothebar</p>
<p><strong>注意，在有些情况下要使用转义字符，下面的等号要用双竖线转义，这是java**</strong>正则表达式的规则。**</p>
<p>select data_field,</p>
<p>​     regexp_extract(data_field,’.*?bgStart\=(<sup><a href="#fn_&" id="reffn_&">&</a></sup>+)’,1) as aaa,</p>
<p>​     regexp_extract(data_field,’.*?contentLoaded_headStart\=(<sup><a href="#fn_&" id="reffn_&">&</a></sup>+)’,1) as bbb,</p>
<p>​     regexp_extract(data_field,’.*?AppLoad2Req\=(<sup><a href="#fn_&" id="reffn_&">&</a></sup>+)’,1) as ccc</p>
<p>​     from pt_nginx_loginlog_st</p>
<p>​     where pt = ‘2012-03-26’limit 2;</p>
<p><strong>14. URL解析函数：parse_url</strong></p>
<p>语法: parse_url(string urlString, string partToExtract [, stringkeyToExtract])</p>
<p>返回值: string</p>
<p>说明：返回URL中指定的部分。partToExtract的有效值为：HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.</p>
<p>举例：</p>
<p>hive&gt; selectparse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1" target="_blank" rel="noopener">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1</a>‘, ‘HOST’) fromlxw_dual;</p>
<p>facebook.com</p>
<p>hive&gt; selectparse_url(‘<a href="http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1" target="_blank" rel="noopener">http://facebook.com/path1/p.php?k1=v1&amp;k2=v2#Ref1</a>‘, ‘QUERY’,’k1’) from lxw_dual;</p>
<p>v1</p>
<p><strong>15. json解析函数：get_json_object</strong></p>
<p>语法: get_json_object(string json_string, string path)</p>
<p>返回值: string</p>
<p>说明：解析json的字符串json_string,返回path指定的内容。如果输入的json字符串无效，那么返回NULL。</p>
<p>举例：</p>
<p>hive&gt; select get_json_object(‘{“store”:</p>
<p>>  {“fruit”:[{“weight”:8,”type”:”apple”},{“weight”:9,”type”:”pear”}],</p>
<p>>   “bicycle”:{“price”:19.95,”color”:”red”}</p>
<p>>   },</p>
<p>> “email”:”amy@only_for_json_udf_test.net”,</p>
<p>>  “owner”:”amy”</p>
<p>> }</p>
<p>> ‘,’$.owner’) from lxw_dual;</p>
<p>amy</p>
<p><strong>16. 空格字符串函数：space</strong></p>
<p>语法: space(int n)</p>
<p>返回值: string</p>
<p>说明：返回长度为n的字符串</p>
<p>举例：</p>
<p>hive&gt; select space(10) from lxw_dual;</p>
<p>hive&gt; select length(space(10)) from lxw_dual;</p>
<p>10</p>
<p><strong>17. 重复字符串函数：repeat</strong></p>
<p>语法: repeat(string str, int n)</p>
<p>返回值: string</p>
<p>说明：返回重复n次后的str字符串</p>
<p>举例：</p>
<p>hive&gt; select repeat(‘abc’,5) from lxw_dual;</p>
<p>abcabcabcabcabc</p>
<p><strong>18. 首字符ascii函数：ascii</strong></p>
<p>语法: ascii(string str)</p>
<p>返回值: int</p>
<p>说明：返回字符串str第一个字符的ascii码</p>
<p>举例：</p>
<p>hive&gt; select ascii(‘abcde’) from lxw_dual;</p>
<p>97</p>
<p><strong>19. 左补足函数：lpad</strong></p>
<p>语法: lpad(string str, int len, string pad)</p>
<p>返回值: string</p>
<p>说明：将str进行用pad进行左补足到len位</p>
<p>举例：</p>
<p>hive&gt; select lpad(‘abc’,10,’td’) from lxw_dual;</p>
<p>tdtdtdtabc</p>
<p><strong>注意：与GP**</strong>，ORACLE<strong>**不同，pad</strong> <strong>不能默认</strong></p>
<p><strong>20. 右补足函数：rpad</strong></p>
<p>语法: rpad(string str, int len, string pad)</p>
<p>返回值: string</p>
<p>说明：将str进行用pad进行右补足到len位</p>
<p>举例：</p>
<p>hive&gt; select rpad(‘abc’,10,’td’) from lxw_dual;</p>
<p>abctdtdtdt</p>
<p><strong>21. 分割字符串函数: split</strong></p>
<p>语法:  split(string str, stringpat)</p>
<p>返回值:  array</p>
<p>说明: 按照pat字符串分割str，会返回分割后的字符串数组</p>
<p>举例：</p>
<p>hive&gt; select split(‘abtcdtef’,’t’) from lxw_dual;</p>
<p>[“ab”,”cd”,”ef”]</p>
<p><strong>22. 集合查找函数:find_in_set</strong></p>
<p>语法: find_in_set(string str, string strList)</p>
<p>返回值: int</p>
<p>说明: 返回str在strlist第一次出现的位置，strlist是用逗号分割的字符串。如果没有找该str字符，则返回0</p>
<p>举例：</p>
<p>hive&gt; select find_in_set(‘ab’,’ef,ab,de’) from lxw_dual;</p>
<p>2</p>
<p>hive&gt; select find_in_set(‘at’,’ef,ab,de’) from lxw_dual;</p>
<p>0</p>
<p>instr</p>
<h1 id="group后拼接"><a href="#group后拼接" class="headerlink" title="group后拼接"></a>group后拼接</h1><p>group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select userid,bankid,group_concat(cast(creditlimit as string))</div><div class="line">from vdm_fin.cc_user_bill_0724</div><div class="line">group by userid,bankid</div></pre></td></tr></table></figure>
<p><img src="/2017/07/12/hadoop-spark/hive笔记/pic/70.png" alt="è¿éåå¾çæè¿°"></p>
<p><strong>hive实现相同的功能：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT id,</div><div class="line">concat_ws(&apos;|&apos;, collect_set(str)) </div><div class="line">FROM t  </div><div class="line">GROUP BY id;1234</div></pre></td></tr></table></figure>
<p>主意:collect_set 只能返回不重复的集合<br>若要返回带重复的要用collect_list</p>
<p>2、collect_list 展示子表排序后结果，collect_set 不受子表排序影响<br>select phone,collect_list(user_id) ,collect_set(user_id) from<br>(select * from a order by order_time asc)b<br>group by phone<br>结果：123456789    [1,1,3,2,2]    [1,3,2]</p>
<p>a表数据如下<br>phone    user_id order_time<br>123456789    1    2018/8/23<br>123456789    3    2018/8/24<br>123456789    2    2018/8/25<br>123456789    1    2018/8/22<br>123456789    2    2018/8/26</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/hadoop-spark/spark/spark笔记/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/hadoop-spark/spark/spark笔记/" class="post-title-link" itemprop="url">spark笔记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-15 09:30:56" itemprop="dateModified" datetime="2019-04-15T09:30:56+08:00">2019-04-15</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/hadoop-spark/" itemprop="url" rel="index"><span itemprop="name">hadoop-spark</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/hadoop-spark/spark/spark笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/hadoop-spark/spark/spark笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算圆周率pi"><a href="#算圆周率pi" class="headerlink" title="算圆周率pi"></a>算圆周率pi</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span>;</div><div class="line"><span class="keyword">import</span>  org.apache.spark.<span class="type">SparkContext</span>;</div><div class="line"><span class="keyword">case</span>  <span class="class"><span class="keyword">class</span> <span class="title">PerTypeson</span>[<span class="type">T</span>,<span class="type">S</span>](<span class="params">var name:<span class="type">T</span>,var age:<span class="type">S</span></span>) </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">object</span>   <span class="title">SparkTest</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Spark Pi"</span>).setMaster(<span class="string">"local"</span>)   <span class="comment">//关键</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</div><div class="line">    <span class="keyword">val</span>   <span class="type">NUM_SAMPLES</span>=<span class="number">100000</span></div><div class="line">    <span class="keyword">val</span>   count=sc.parallelize(<span class="number">1</span> to <span class="type">NUM_SAMPLES</span>).map&#123;i=&gt;</div><div class="line">       <span class="keyword">val</span> x=<span class="type">Math</span>.random()</div><div class="line">      <span class="keyword">val</span>  y=<span class="type">Math</span>.random()</div><div class="line">      <span class="keyword">if</span>(x*x+y*y&lt;<span class="number">1</span>)<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">    &#125;.reduce(_+_)</div><div class="line">    println(<span class="string">"pi is rougly"</span>+<span class="number">4.0</span>*count/<span class="type">NUM_SAMPLES</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="读取外部文件和链接数据库"><a href="#读取外部文件和链接数据库" class="headerlink" title="读取外部文件和链接数据库"></a>读取外部文件和链接数据库</h1><p>（用spark 1.6的版本）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span>;</div><div class="line"><span class="keyword">import</span>  org.apache.spark.<span class="type">SparkContext</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">LogisticRegression</span></div><div class="line"><span class="keyword">import</span>  org.apache.spark.sql.<span class="type">SQLContext</span></div><div class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Map</span></div><div class="line"><span class="keyword">case</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var name:<span class="type">String</span></span>)</span></div><div class="line"><span class="class"><span class="keyword">object</span>   <span class="title">SparkTest</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</div><div class="line">    <span class="comment">//    val conf = new SparkConf().setAppName("Spark Pi").setMaster("spark://hadoop:7070")   //关键</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Spark Pi"</span>).setMaster(<span class="string">"local"</span>)   <span class="comment">//关键</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</div><div class="line"><span class="comment">//     val  textfile=sc.textFile("C:\\Users\\Administrator\\Desktop\\分词.txt")</span></div><div class="line"><span class="comment">//      textfile.collect().foreach(println)</span></div><div class="line">    <span class="keyword">val</span> sqlContext=<span class="keyword">new</span>  <span class="type">SQLContext</span>(sc)</div><div class="line">   <span class="keyword">val</span>  df=sqlContext.read.json(<span class="string">"F:\\people.json"</span>)</div><div class="line">    df.cache()</div><div class="line">   println(df.select(<span class="string">"age"</span>).show())</div><div class="line">    df.registerTempTable(<span class="string">"df1"</span>)</div><div class="line">    println(sqlContext.sql(<span class="string">"select * from  df1  where  age=19"</span>))</div><div class="line">    <span class="keyword">val</span>  map=<span class="type">Map</span>(<span class="string">"url"</span> -&gt; <span class="string">"jdbc:mysql://localhost:3306/test"</span>,</div><div class="line">      <span class="string">"user"</span>-&gt;<span class="string">"root"</span>,<span class="string">"password"</span>-&gt;<span class="string">""</span>)</div><div class="line">     map+=(<span class="string">"dbtable"</span> -&gt;<span class="string">"class"</span>)</div><div class="line">     <span class="string">"dbtable"</span> -&gt; <span class="string">"SELECT * FROM iteblog"</span></div><div class="line">    <span class="keyword">val</span>  jdbc=sqlContext.read.format(<span class="string">"jdbc"</span>).options(map).load()</div><div class="line">    println(jdbc.show(<span class="number">1</span>))</div><div class="line"><span class="comment">//    val lr = new LogisticRegression().setMaxIter(10)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="创建DataFrame并简单操作DataFrame"><a href="#创建DataFrame并简单操作DataFrame" class="headerlink" title="创建DataFrame并简单操作DataFrame"></a>创建DataFrame并简单操作DataFrame</h1><p>spark2.0就可以直接用RDD.toDF</p>
<p>spark1.6需要sqlContext.createDataFrame(sc.parallelize(data)).toDF(“id”, “features”, “clicked”)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span>;</div><div class="line"><span class="keyword">import</span>  org.apache.spark.<span class="type">SparkContext</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.ml.classification.<span class="type">LogisticRegression</span></div><div class="line"><span class="keyword">import</span>  org.apache.spark.sql.<span class="type">SQLContext</span></div><div class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Map</span></div><div class="line"><span class="keyword">case</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var name:<span class="type">String</span></span>)</span></div><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">age: <span class="type">Int</span>, name: <span class="type">String</span></span>)</span></div><div class="line"><span class="class"><span class="keyword">object</span>   <span class="title">SparkTest</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</div><div class="line">    <span class="comment">//    val conf = new SparkConf().setAppName("Spark Pi").setMaster("spark://hadoop:7070")   //关键</span></div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"Spark Pi"</span>).setMaster(<span class="string">"local"</span>)   <span class="comment">//关键</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</div><div class="line">    <span class="keyword">val</span> sqlContext=<span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</div><div class="line">    <span class="comment">//第一种方式就创建DataFrame，读取外部文件</span></div><div class="line">    println(<span class="string">"第一种方式就创建DataFrame，读取外部文件"</span>)</div><div class="line">     <span class="keyword">val</span>  textfile=sc.textFile(<span class="string">"C:\\Users\\Administrator\\Desktop\\分词.txt"</span>)</div><div class="line">     <span class="keyword">val</span>  df_person=textfile.map(x=&gt;<span class="type">Person</span>(x))</div><div class="line">    <span class="keyword">val</span>  df_test=sqlContext.createDataFrame(df_person).withColumnRenamed(<span class="string">"name"</span>,<span class="string">"anmoyi"</span>)</div><div class="line">    println(df_test.filter(df_test(<span class="string">"anmoyi"</span>).contains(<span class="string">"使用"</span>)).count())</div><div class="line">    <span class="comment">//第二种方式创建DataFrame</span></div><div class="line">    println(<span class="string">"第二种方式创建DataFrame，通过List和case类的方式创建"</span>)</div><div class="line">    <span class="keyword">val</span>  listOfEmployee=<span class="type">List</span>(<span class="type">Employee</span>(<span class="number">1</span>,<span class="string">"zhou"</span>),<span class="type">Employee</span>(<span class="number">1</span>,<span class="string">"zhou"</span>),<span class="type">Employee</span>(<span class="number">2</span>,<span class="string">"mei"</span>),<span class="type">Employee</span>(<span class="number">3</span>,<span class="string">"xu"</span>))</div><div class="line">    <span class="keyword">val</span>  emFrame=sqlContext.createDataFrame(listOfEmployee)</div><div class="line">    println(emFrame.show())</div><div class="line">    emFrame.registerTempTable(<span class="string">"employeeTable"</span>)</div><div class="line">    <span class="keyword">val</span> sortedByNameEmployees = sqlContext.sql(<span class="string">"select * from employeeTable order by name desc"</span>)</div><div class="line">    println(sortedByNameEmployees.show())</div><div class="line">    println(emFrame.groupBy(<span class="string">"age"</span>).count().show())</div><div class="line">    println(emFrame.select(emFrame(<span class="string">"name"</span>),emFrame(<span class="string">"age"</span>),(emFrame(<span class="string">"age"</span>)+<span class="number">1</span>).as(<span class="string">"age1"</span>)).show())</div><div class="line">    println(sortedByNameEmployees.show())</div><div class="line">    <span class="comment">//第三种方式通过TupleN来创建DataFrame</span></div><div class="line">    println(<span class="string">"第三种方式通过TupleN，元祖的方式来创建DataFrame"</span>)</div><div class="line">    <span class="keyword">val</span> mobiles=sqlContext.createDataFrame(<span class="type">Seq</span>((<span class="number">1</span>,<span class="string">"Android"</span>), (<span class="number">2</span>, <span class="string">"iPhone"</span>))).toDF(<span class="string">"age"</span>,<span class="string">"mobile"</span>)</div><div class="line">    println(mobiles.show())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="DataFrame转列的数据类型"><a href="#DataFrame转列的数据类型" class="headerlink" title="DataFrame转列的数据类型"></a>DataFrame转列的数据类型</h1><p><a href="https://blog.csdn.net/dkl12/article/details/80256585" target="_blank" rel="noopener">https://blog.csdn.net/dkl12/article/details/80256585</a></p>
<p>转所有列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import org.apache.spark.sql.functions._</div><div class="line"></div><div class="line">val cols = colNames.map(f =&gt; col(f).cast(DoubleType))</div><div class="line">df.select(cols: _*).show()</div></pre></td></tr></table></figure>
<p>转指定列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val name = &quot;col1,col3,col5&quot;</div><div class="line">df.select(name.split(&quot;,&quot;).map(name =&gt; col(name)): _*).show()</div><div class="line">df.select(name.split(&quot;,&quot;).map(name =&gt; col(name).cast(DoubleType)): _*).show()</div></pre></td></tr></table></figure>
<h1 id="Spark中统计相关的东西"><a href="#Spark中统计相关的东西" class="headerlink" title="Spark中统计相关的东西"></a>Spark中统计相关的东西</h1><p>spark shell中增加依赖包   <code>bin/spark-shell --packages com.databricks:spark-csv_2.10:1.0.3</code>  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span>  org.apache.spark.<span class="type">SparkConf</span></div><div class="line"><span class="keyword">import</span>  org.apache.spark.<span class="type">SparkContext</span></div><div class="line"><span class="keyword">import</span>  org.apache.spark.sql.<span class="type">SQLContext</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.sql.functions._   <span class="comment">//包含了常见的统计函数和数学函数</span></div><div class="line"><span class="keyword">import</span> org.apache.log4j.&#123;<span class="type">Level</span>, <span class="type">Logger</span>&#125;</div><div class="line"><span class="comment">//import com.databricks.spark.csv._</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span>=&#123;</div><div class="line"><span class="comment">// 屏蔽不必要的日志显示在终端上</span></div><div class="line"><span class="type">Logger</span>.getLogger(<span class="string">"org.apache.spark"</span>).setLevel(<span class="type">Level</span>.<span class="type">WARN</span>)</div><div class="line"><span class="type">Logger</span>.getLogger(<span class="string">"org.eclipse.jetty.server"</span>).setLevel(<span class="type">Level</span>.<span class="type">OFF</span>)</div><div class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"stastic"</span>).setMaster(<span class="string">"local"</span>)   <span class="comment">//关键</span></div><div class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</div><div class="line">    <span class="keyword">val</span> sqlContext=<span class="keyword">new</span> <span class="type">SQLContext</span>(sc)</div><div class="line">    <span class="keyword">import</span> sqlContext.implicits._ <span class="comment">//用于隐式转化，可以由RDD直接转换为DataFrame</span></div><div class="line">    <span class="keyword">val</span> df = sc.parallelize(<span class="number">0</span> until <span class="number">10</span>).toDF(<span class="string">"id"</span>).withColumn(<span class="string">"rand1"</span>, rand(<span class="number">10</span>))</div><div class="line">      .withColumn(<span class="string">"rand2"</span>, rand(seed=<span class="number">27</span>)).withColumn(<span class="string">"rand3"</span>,rand(<span class="number">20</span>))</div><div class="line">    println(df.columns)</div><div class="line">    println(df.describe().show())</div></pre></td></tr></table></figure>
<h1 id="Spark中的多对多JOIN"><a href="#Spark中的多对多JOIN" class="headerlink" title="Spark中的多对多JOIN"></a>Spark中的多对多JOIN</h1><p>如果存在多对多的情况下，则是以乘法得到最后结果，并不是以某列多的情况</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span>  df2=sc.parallelize(<span class="number">0</span> until <span class="number">6</span>).toDF(<span class="string">"id"</span>).withColumn(<span class="string">"age"</span>,rand(<span class="number">10</span>))</div><div class="line">println(df.join(df2,df(<span class="string">"id"</span>)===df2(<span class="string">"id"</span>),<span class="string">"left"</span>).show())  <span class="comment">//左链接</span></div><div class="line">println(df.join(df2,df(<span class="string">"id"</span>)===df2(<span class="string">"id"</span>),<span class="string">"right"</span>).show())  <span class="comment">//右链接</span></div><div class="line">println(df.join(df2,df(<span class="string">"id"</span>)===df2(<span class="string">"id"</span>),<span class="string">"outer"</span>).show()) <span class="comment">//全链接</span></div><div class="line">println(df.join(df2,df(<span class="string">"id"</span>)===df2(<span class="string">"id"</span>),<span class="string">"inner"</span>).show())  <span class="comment">//inner 链接</span></div><div class="line">df.join(df2, $<span class="string">"df1Key"</span> === $<span class="string">"df2Key"</span>)</div><div class="line">df.join(df2).where($<span class="string">"df1Key"</span> === $<span class="string">"df2Key"</span>)</div><div class="line">df.join(df2, <span class="type">Seq</span>(<span class="string">"user_id"</span>, <span class="string">"user_name"</span>))</div><div class="line">    println(<span class="string">"统计函数开始"</span>)</div><div class="line">    println(df.groupBy($<span class="string">"id"</span>).agg(<span class="type">Map</span>(</div><div class="line">      <span class="string">"rand1"</span> -&gt; <span class="string">"avg"</span>,</div><div class="line">      <span class="string">"rand2"</span> -&gt; <span class="string">"max"</span>,</div><div class="line">      <span class="string">"rand3"</span> -&gt; <span class="string">"min"</span></div><div class="line">    )).show())</div><div class="line">    println(df.drop(<span class="string">"rand1"</span>).show())</div><div class="line">    println(df.stat.corr(<span class="string">"rand1"</span>,<span class="string">"rand2"</span>))</div><div class="line">    println(df.stat.cov(<span class="string">"rand1"</span>, <span class="string">"rand2"</span>))</div><div class="line">    <span class="keyword">val</span>  df1=sqlContext.createDataFrame(<span class="type">Seq</span>((<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">2</span>),</div><div class="line">      (<span class="number">3</span>, <span class="number">3</span>))).toDF(<span class="string">"key"</span>, <span class="string">"value"</span>)</div><div class="line">    println(df1.stat.crosstab(<span class="string">"key"</span>,<span class="string">"value"</span>).show())</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="pyspark"><a href="#pyspark" class="headerlink" title="pyspark"></a>pyspark</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkContext</div><div class="line">sc = SparkContext(<span class="string">"local"</span>, <span class="string">"Simple App"</span>)</div><div class="line">rdd = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">rdd.collect()</div><div class="line"><span class="comment">#[1, 2, 3]</span></div><div class="line">rdd1 = rdd.map(<span class="keyword">lambda</span> x : x+<span class="number">1</span>)</div><div class="line">rdd1.collect()</div><div class="line"><span class="comment">#[2, 3, 4]</span></div></pre></td></tr></table></figure>
<h1 id="spark作业提交"><a href="#spark作业提交" class="headerlink" title="spark作业提交"></a>spark作业提交</h1><p>以WordCount为例说明RDD从转换到作业提交的过程</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc.textFile(<span class="string">"/User/david/key.txt"</span>).flatMap(line=&gt;line.split(<span class="string">" "</span>)).map(word=&gt;(word,<span class="number">1</span>)).reduceByKey(_+_)</div></pre></td></tr></table></figure>
<p>步骤1：<code>val rawFile = sc.textFile(&quot;/User/david/key.txt&quot;)</code></p>
<p>textFile先生成HadoopRDD，然后再通过map操作生成MappedRDD。在spark-shell中可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scala&gt; val rawFile = sc.textFile(&quot;/User/david/key.txt&quot;)</div><div class="line">rawFile: org.apache.spark.rdd.RDD[String] = /User/david/key.txt MapPartitionsRDD[3] at textFile at &lt;console&gt;:27</div><div class="line">1.6.3版本变成了MapPartitionsRDD</div></pre></td></tr></table></figure>
<p>步骤2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val splittedText = rawFile.flatMap(line=&gt;line.split(&quot; &quot;))</div></pre></td></tr></table></figure>
<p>flatMap将原来的MappedRDD转换为FlatMappedRDD。</p>
<p>步骤3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val wordCount = splittedText.map(word=&gt;(word,1))</div></pre></td></tr></table></figure>
<p>步骤4：<code>reduceByKey</code></p>
<h2 id="作业执行"><a href="#作业执行" class="headerlink" title="作业执行"></a>作业执行</h2><p>spark执行中相关概念</p>
<p><a href="https://blog.csdn.net/u013013024/article/details/72876427" target="_blank" rel="noopener">Spark中Task，Partition，RDD、节点数、Executor数、core数目的关系和Application，Driver，Job，Task，Stage理解</a></p>
<p><img src="http://www.zezhi.net/wp-content/uploads/2016/04/spark-learning.png" alt=""></p>
<p>若干个block合并成一个输入分片InputSplit，一个InputSplit对应一个Task，一个Task生成一个Partition。</p>
<p>随后这些具体的Task每个都会被分配到集群上的某个节点的某个<strong>Executor</strong>去执行。</p>
<ul>
<li>每个节点可以启一个或多个Executor。</li>
<li>每个Executor由若干<strong>core</strong>组成，每个Executor的每个core<strong>一次只能执行一个</strong>Task。</li>
<li>每个<strong>Task</strong>执行的结果就是生成了目标<strong>RDD</strong>的一个<strong>partiton</strong>。每个partition再下一步又由一个task来执行。</li>
</ul>
<p><strong>注意: </strong>这里的core是虚拟的core而不是机器的物理CPU核，可以理解为就是Executor的一个工作线程。</p>
<p>而 Task被执行的并发度 = Executor数目 * 每个Executor核数。</p>
<p>所以，如果一共要执行8个task，但只有一个Executor，2个core，则并发度是2。那么需要分成4个批次，每次并发执行两个Task。</p>
<p>至于<strong>partition的数目</strong>：</p>
<ul>
<li>对于数据读入阶段，例如sc.textFile，输入文件被划分为多少InputSplit就会需要多少初始Task。</li>
<li>在Map阶段partition数目保持不变。</li>
<li>在Reduce阶段，RDD的聚合会触发shuffle操作，聚合后的RDD的partition数目跟具体操作有关，例如repartition操作会聚合成指定分区数，还有一些算子是可配置的。</li>
</ul>
<p>在任务提交中主要涉及Driver和Executor两个节点。</p>
<p><strong>Driver</strong>可以理解为我们自己编写的程序。主要解决</p>
<ul>
<li>RDD依赖性分析，以生成DAG</li>
<li>根据RDD DAG将Job分割为多个stage</li>
<li>Stage确认后，生成相应的task，分发到Executor执行。</li>
</ul>
<p><strong>Executor</strong>：在每个WorkerNode上为某应用启动的一个进程，是一个执行task的容器。一个Executor执行多个Task。</p>
<p>另外</p>
<p><strong>Job</strong>：包含很多task的并行计算，可以认为<strong>是Spark RDD 里面的action</strong>,每个action的计算会生成一个job。</p>
<p>　　用户提交的Job会提交给DAGScheduler，Job会被分解成Stage和Task。</p>
<p> Spark中的Job和MR中Job不一样。MR中Job主要是Map或者Reduce Job。而<strong>Spark的Job其实很好区别，一个action算子就算一个Job</strong>，比方说count，first等。</p>
<p><strong>Stage</strong>：</p>
<p><strong>一个Job会被拆分为多组Task，每组任务被称为一个Stage就像Map Stage， Reduce Stage</strong>。</p>
<p>　　Stage的划分在RDD的论文中有详细的介绍，简单的说是以shuffle和result这两种类型来划分。在Spark中有两类task，一类是shuffleMapTask，一类是resultTask，第一类task的输出是shuffle所需数据，第二类task的输出是result，stage的划分也以此为依据，shuffle之前的所有变换是一个stage，shuffle之后的操作是另一个stage。比如 rdd.parallize(1 to 10).foreach(println) 这个操作没有shuffle，直接就输出了，那么只有它的task是resultTask，stage也只有一个；如果是rdd.map(x =&gt; (x, 1)).reduceByKey(<em> + </em>).foreach(println), 这个job因为有reduce，所以有一个shuffle过程，那么reduceByKey之前的是一个stage，执行shuffleMapTask，输出shuffle所需的数据，reduceByKey到最后是一个stage，直接就输出结果了。如果job中有多次shuffle，那么每个shuffle之前都是一个stage。</p>
<p><strong>Task</strong></p>
<p>即 stage 下的一个任务执行单元，一般来说，<strong>一个 rdd 有多少个 partition，就会有多少个 task</strong>，因为每一个 task 只是处理一个 partition 上的数据.</p>
<h3 id="依赖性分析和stage划分"><a href="#依赖性分析和stage划分" class="headerlink" title="依赖性分析和stage划分"></a>依赖性分析和stage划分</h3><p>RDD之间的依赖分为窄依赖和宽依赖。</p>
<p>窄依赖是指父RDD所有输出都会被执行的子RDD消费，也就是输出路径固定。例如如下的Transformation：</p>
<p>map、flatMap、filter、sample</p>
<p>宽依赖是指父RDD输出会由不同子RDD消费，输出路径不固定。例如：</p>
<p>sortByKey、reduceByKey、groupByKey、cogroupByKey、join、cartensian</p>
<p>调度器（Scheduler）会计算RDD之间的依赖关系，将窄依赖的RDD归并到同一个stage，而宽依赖则作为划分不同Stage的判断标准。<strong>宽依赖和窄依赖的边界就是stage的划分点</strong></p>
<h2 id="任务的创建和分发"><a href="#任务的创建和分发" class="headerlink" title="任务的创建和分发"></a>任务的创建和分发</h2><p>由Executor执行的Task分为ShuffleMapTask和ResultTask两种，相当于Map和Reduce。</p>
<h1 id="RDD-API合集"><a href="#RDD-API合集" class="headerlink" title="RDD API合集"></a>RDD API合集</h1><p><a href="https://blog.csdn.net/xiefu5hh/article/details/51781074" target="_blank" rel="noopener">Spark JAVA RDD API 最全合集整理</a></p>
<p><a href="https://blog.csdn.net/guotong1988/article/details/50555185" target="_blank" rel="noopener">Spark API 详解/大白话解释 之 map、mapPartitions、mapValues、mapWith、flatMap、flatMapWith、flatMapValues</a></p>
<p><a href="https://blog.csdn.net/guotong1988/article/details/50554034" target="_blank" rel="noopener">Spark API 详解/大白话解释 之 RDD、partition、count、collect</a></p>
<h1 id="flatMap和map"><a href="#flatMap和map" class="headerlink" title="flatMap和map"></a>flatMap和map</h1><p><a href="http://blog.csdn.net/sicofield/article/details/50914050" target="_blank" rel="noopener">Spark之中map与flatMap的区别</a></p>
<p>map的作用就是对rdd之中的元素进行逐一进行函数操作映射为另外一个rdd。</p>
<p>flatMap的操作是将函数应用于rdd之中的每一个元素，将返回的<strong>迭代器</strong>的所有内容构成新的rdd。通常用来切分单词。</p>
<p><img src="http://img.blog.csdn.net/20160317150619505" alt=""></p>
<p>传递给flatMap的函数返回的类型是一个可迭代的类型（例如list）。</p>
<p><img src="http://img.blog.csdn.net/20160317151021948" alt=""></p>
<p><em>map会返回多个数组对象，flatmap返回一个</em></p>
<p>map函数会对每一条输入进行指定的操作，然后为每一条输入返回一个对象；而flatMap函数则是两个操作的集合——正是“先映射后扁平化”：</p>
<p>操作1：同map函数一样：对每一条输入进行指定的操作，然后为每一条输入返回一个对象</p>
<p>操作2：最后将所有对象合并为一个对象</p>
<h1 id="reduce和reduceByKey"><a href="#reduce和reduceByKey" class="headerlink" title="reduce和reduceByKey"></a>reduce和reduceByKey</h1><p>转自<a href="https://blog.csdn.net/guotong1988/article/details/50555671" target="_blank" rel="noopener">https://blog.csdn.net/guotong1988/article/details/50555671</a></p>
<p>reduce</p>
<p>reduce将RDD中元素前两个传给输入函数，产生一个新的return值，新产生的return值与RDD中下一个元素（第三个元素）组成两个元素，再被传给输入函数，直到最后只有一个值为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val c = sc.parallelize(1 to 10)</div><div class="line">c.reduce((x, y) =&gt; x + y)//结果55</div></pre></td></tr></table></figure>
<p>具体过程，RDD有1 2 3 4 5 6 7 8 9 10个元素，<br>1+2=3<br>3+3=6<br>6+4=10<br>10+5=15<br>15+6=21<br>21+7=28<br>28+8=36<br>36+9=45<br>45+10=55</p>
<p>reduceByKey</p>
<p>reduceByKey就是对元素为KV对的RDD中Key相同的元素的Value进行binary_function的reduce操作，因此，Key相同的多个元素的值被reduce为一个值，然后与原RDD中的Key组成一个新的KV对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val a = sc.parallelize(List((1,2),(1,3),(3,4),(3,6)))</div><div class="line">a.reduceByKey((x,y) =&gt; x + y).collect</div></pre></td></tr></table></figure>
<p>结果 Array((1,5), (3,10))</p>
<h1 id="设置打印日志级别"><a href="#设置打印日志级别" class="headerlink" title="设置打印日志级别"></a>设置打印日志级别</h1><p>如果是log4j日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import org.apache.log4j.&#123; Level, Logger &#125;</div><div class="line"></div><div class="line">Logger.getLogger(&quot;org.apache.spark&quot;).setLevel(Level.WARN)</div><div class="line">Logger.getLogger(&quot;org.eclipse.jetty.server&quot;).setLevel(Level.OFF)</div></pre></td></tr></table></figure>
<p>如果是console日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val sc = new SparkContext(conf)</div><div class="line">sc.setLogLevel(&quot;WARN&quot;)</div></pre></td></tr></table></figure>
<h1 id="ml和mllib"><a href="#ml和mllib" class="headerlink" title="ml和mllib"></a>ml和mllib</h1><p><a href="https://www.cnblogs.com/itboys/p/6860953.html" target="_blank" rel="noopener">https://www.cnblogs.com/itboys/p/6860953.html</a></p>
<p>ml主要操作的是DataFrame, 而mllib操作的是RDD，也就是说二者面向的数据集不一样。相比于mllib在RDD提供的基础操作，ml在DataFrame上的抽象级别更高，数据和操作耦合度更低。</p>
<p> ml中的操作可以使用pipeline, 跟sklearn一样，可以把很多操作(算法/特征提取/特征转换)以管道的形式串起来，然后让数据在这个管道中流动。</p>
<p>ml中无论是什么模型，都提供了统一的算法操作接口，比如模型训练都是<code>fit</code>；不像mllib中不同模型会有各种各样的<code>trainXXX</code>。</p>
<p>mllib在spark2.0之后进入<code>维护状态</code>, 这个状态通常只修复BUG不增加新功能。</p>
<h1 id="cache的作用"><a href="#cache的作用" class="headerlink" title="cache的作用"></a>cache的作用</h1><p><a href="https://blog.csdn.net/Allenalex/article/details/79431047" target="_blank" rel="noopener">https://blog.csdn.net/Allenalex/article/details/79431047</a></p>
<p>如果要缓存的RDD太大的话，即使调用cache()，Spark也可能会丢掉和重新计算RDD的部分。所以在大的程序中，最后是使用RDD.filter(x=&gt;x&gt;0).persist(StorageLevel.MEMORY_AND_DISK)。</p>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><p><a href="https://blog.csdn.net/u014236541/article/details/78834148" target="_blank" rel="noopener">Spark性能调优之合理设置并行度</a></p>
<p><a href="https://www.iteblog.com/archives/1657.html" target="_blank" rel="noopener">Spark性能优化：开发调优篇</a></p>
<p><a href="https://blog.csdn.net/stark_summer/article/details/42981201" target="_blank" rel="noopener">spark内核揭秘-14-Spark性能优化的10大问题及其解决方案</a></p>
<p><a href="https://blog.csdn.net/dax1n/article/details/53431373" target="_blank" rel="noopener">Spark 重分区函数：coalesce和repartition区别与实现，可以优化Spark程序性能</a></p>
<p><a href="https://blog.csdn.net/lalaguozhe/article/details/9053645" target="_blank" rel="noopener">Hive小文件合并调研</a></p>
<p><a href="https://blog.csdn.net/u010039929/article/details/68067194" target="_blank" rel="noopener">数据倾斜方案-全面</a></p>
<h1 id="shuffle解析"><a href="#shuffle解析" class="headerlink" title="shuffle解析"></a>shuffle解析</h1><p><a href="https://www.cnblogs.com/cenyuhai/p/3826227.html" target="_blank" rel="noopener">Spark源码系列（六）Shuffle的过程解析</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.math.BigDecimal cannot be cast to java.lang.String</div></pre></td></tr></table></figure>
<p>但是并没有bigDecimal类型的数据</p>
<h1 id="如何避免spark-dataframe的JOIN操作之后产生重复列"><a href="#如何避免spark-dataframe的JOIN操作之后产生重复列" class="headerlink" title="如何避免spark dataframe的JOIN操作之后产生重复列"></a>如何避免spark dataframe的JOIN操作之后产生重复列</h1><p><a href="https://blog.csdn.net/sparkexpert/article/details/52837269" target="_blank" rel="noopener">https://blog.csdn.net/sparkexpert/article/details/52837269</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.join(df2, Seq(&quot;key1&quot;, &quot;key2&quot;), &quot;left_outer&quot;).show()</div></pre></td></tr></table></figure>
<h1 id="DataFrame-Join"><a href="#DataFrame-Join" class="headerlink" title="DataFrame Join"></a>DataFrame Join</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val baseinfoContactDF = baseinfoDF.join(gpsDF, Seq(&quot;app_no&quot;), &quot;left_outer&quot;).na.fill(0.0)</div><div class="line"></div><div class="line">personDataFrame.join(orderDataFrame, personDataFrame(&quot;id_person&quot;) === orderDataFrame(&quot;id_person&quot;), &quot;inner&quot;).show()</div></pre></td></tr></table></figure>
<h1 id="spark-dataframe新增一列的四种方法"><a href="#spark-dataframe新增一列的四种方法" class="headerlink" title="spark dataframe新增一列的四种方法"></a>spark dataframe新增一列的四种方法</h1><p><a href="https://blog.csdn.net/li3xiao3jie2/article/details/81317249" target="_blank" rel="noopener">https://blog.csdn.net/li3xiao3jie2/article/details/81317249</a></p>
<h1 id="spark序列化问题"><a href="#spark序列化问题" class="headerlink" title="spark序列化问题"></a>spark序列化问题</h1><p><a href="https://blog.csdn.net/HFUTLXM/article/details/78621406" target="_blank" rel="noopener">https://blog.csdn.net/HFUTLXM/article/details/78621406</a></p>
<p>（一）理解spark闭包</p>
<p>什么叫闭包： 跨作用域访问函数变量。又指的一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>Spark闭包的问题引出：<br>在spark中实现统计List(1,2,3)的和。如果使用下面的代码，程序打印的结果不是6，而是0。这个和我们编写单机程序的认识有很大不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">object Test &#123;</div><div class="line">  def main(args:Array[String]):Unit = &#123;</div><div class="line">      val conf = new SparkConf().setAppName(&quot;test&quot;);</div><div class="line">      val sc = new SparkContext(conf)</div><div class="line"> </div><div class="line">      val rdd = sc.parallelize(List(1,2,3))</div><div class="line">      var counter = 0</div><div class="line">      //warn: don&apos;t do this</div><div class="line">      rdd.foreach(x =&gt; counter += x)</div><div class="line">      println(&quot;Counter value: &quot;+counter)</div><div class="line">      sc.stop()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我也遇到类似情况，在RDD中实例化一个类并赋值，最后出来的结果会有问题</p>
<p>问题分析：<br>counter是在foreach函数外部定义的，也就是<strong>在driver程序中定义</strong>，而foreach函数是属于rdd对象的，rdd函数的执行位置是各个worker节点（或者说worker进程），main函数是在driver节点上（或者说driver进程上）执行的，所以当counter变量在driver中定义，被在rdd中使用的时候，出现了变量的“跨域”问题，也就是闭包问题。</p>
<h1 id="spark输出的part文件数量"><a href="#spark输出的part文件数量" class="headerlink" title="spark输出的part文件数量"></a>spark输出的part文件数量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new SparkConf().setAppName(&quot;InstallAndPickup&quot;).set(&quot;spark.sql.shuffle.partitions&quot;, &quot;5&quot;)</div></pre></td></tr></table></figure>
<p>通过这个参数控制</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/" class="post-title-link" itemprop="url">浅谈在线最优化求解算法-以CTR预测模型为例</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-03-17 20:50:31" itemprop="dateModified" datetime="2018-03-17T20:50:31+08:00">2018-03-17</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="1、最优化求解问题"><a href="#1、最优化求解问题" class="headerlink" title="1、最优化求解问题"></a>1、最优化求解问题</h1><p>通常，我们需要求解的最优化问题有如下三类：</p>
<p><strong>（1）无约束优化问题</strong>：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)</script><p>含义是求解X，令目标函数$f(X)$最小。</p>
<p>对于这类问题，在$f(X)$ 是凸函数的前提下，通常做法就是对$f(X)$ 求导，并令$\frac {\partial} {\partial X} f(X) =0$ ，求解可以得到最优值。</p>
<blockquote>
<p> <strong>凸函数</strong></p>
<p> 如果$f(x)$是定义在N维向量空间上的实变量函数，对于在$f(x)$的定义域C上的任意两个点$x_1$和$x_2$，以及任意[0,1]之间的值t都有：</p>
<script type="math/tex; mode=display">
 f(tX_1 + (1-t)X_2) \leq tf(X_1)+(1-t)f(X_2)\\
 \forall X_1,X_2 \in C,\ \ 0 \leq t \leq 1</script><p> 则称$f(x)$是凸函数。一个函数是凸函数是其存在最优解的充要条件。</p>
<p> 此外，如果$f(x)$满足</p>
<script type="math/tex; mode=display">
 f(tX_1 + (1-t)X_2)< tf(X_1)+(1-t)f(X_2)\\
 \forall X_1,X_2 \in C,\ \ 0 \leq t \leq 1</script><p> 则$f(x)$为严格凸函数。如下图所示，左边是严格凸函数，右边是凸函数</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/凸函数.png" alt="凸函数"></p>
</blockquote>
<p><strong>（2）有等式约束的最优化问题</strong>：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)\\
s.t. h_k(X)=0;k=1,2,...,n</script><p>含义是在n个等式约束$h_k(X)$ 的条件下求解X，另目标函数$f(X)$最小。</p>
<p>针对有等式的最优化问题，采用<strong>拉格朗日乘数法</strong>进行求解，通过拉格朗日系数$A=[a_1,a_2,…,a_n]^T$ 把等式约束和目标函数组合成一个式子</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}[f(X)+ A^TH(X)]</script><p>相当于转化成无约束最优化求解问题，解决方法是分别对X，A求偏导并令其等于0。</p>
<p><strong>（3）不等式约束的优化问题求解</strong> ：</p>
<script type="math/tex; mode=display">
X=\arg \underset{X}{min}f(X)\\
s.t. h_k(X)=0;k=1,2,...,n\\
g_l(X)\leq 0;l=1,2,...,m</script><p>对于不等式约束，通过KKT条件求解。将所有的约束和目标函数写为一个式子</p>
<script type="math/tex; mode=display">
L(X,A,B)=f(X)+A^TH(X)+B^TG(X)</script><p>KKT条件是说最优值必须满足以下条件：</p>
<script type="math/tex; mode=display">
\frac \partial {\partial X} L(X,A,B)=0\\
H(X)=0\\
B^TG(X)=0</script><p>KKT条件是求解最优值的必要条件，要使其成为充要条件，还需要f(x)为凸函数。</p>
<h1 id="2、批量最优化求解算法"><a href="#2、批量最优化求解算法" class="headerlink" title="2、批量最优化求解算法"></a>2、批量最优化求解算法</h1><p>一些定义：</p>
<p>$i=1,2,…,N$表示向量维度</p>
<p>$j=1,2,…,M$表示样本个数</p>
<p>$t=1,2,…$表示迭代次数</p>
<h2 id="2-1-批量和随机求解"><a href="#2-1-批量和随机求解" class="headerlink" title="2.1 批量和随机求解"></a>2.1 批量和随机求解</h2><p>我们面对的最优化问题都是无约束的最优化问题（有约束的也可以转成无约束的），因此通常可以将其描述为</p>
<script type="math/tex; mode=display">
W=\arg \underset{W}{min}\   l(W,Z)\\
Z=\{ (X_j,y_j) | j=1,2,...,M  \}\\
y_j=h(W,X_j)
\tag {2-1-1}</script><p>就是<strong>在已知训练集的情况下，求使得目标函数最小的权重矩阵</strong>。其中，$Z$是训练集，$\mathbf{X}$是特征向量，$X_j$是其中一个样本，$Y$是预测值，$y_j$是其中一个样本对应的预测值。一共有M个样本。$h(W,X_j)$ 是特征向量到预测值的<strong>映射函数</strong>，$ l(W,Z)$ 最优化求解的目标函数，也称为<strong>损失函数</strong>，$W$ 为特征权重，也就是在损失函数中需要求解的参数。</p>
<blockquote>
<p> 损失函数一般包括损失项和正则项</p>
</blockquote>
<p>常用的损失函数有：</p>
<p>（1）<strong>平方损失函数</strong>（线性回归）</p>
<p>最小二乘法（Ordinary Least Squares）是常用的一种平方损失函数，最小二乘的基本原理是：最优拟合直线应该是使各点到回归直线的距离和最小的直线，即平方和最小。</p>
<p>线性回归的映射函数为：</p>
<script type="math/tex; mode=display">
h(W,X_j)=W^TX_j</script><p>损失函数可以表示为</p>
<script type="math/tex; mode=display">
l(W,Z)=\sum_{j=1}^M (y_j-W^TX_j)^2</script><p>（2）<strong>Logistics损失函数</strong>（逻辑回归）</p>
<p>逻辑回归的映射函数为：</p>
<script type="math/tex; mode=display">
h(W,X_j)=\frac 1 {1+e^{-W^TX_j}}</script><blockquote>
<p>logistic函数的优点是：</p>
<p>1、他的输入范围是$-\infty \rightarrow  + \infty $ ，<strong>输出范围是(0,1)，正好满足概率分布为（0，1）的要求</strong>。我们用概率去描述分类器，自然比单纯的某个阈值要方便很多； </p>
<p>2、是一个单调上升的函数，具有良好的连续性，<strong>不存在不连续点</strong>。</p>
</blockquote>
<p>由于该函数服从伯努利分布（0-1分布），通过最大似然估计，对于每一维的权重W，损失函数可以表示为</p>
<script type="math/tex; mode=display">
l(W,Z)=(Y-h_W(\mathbf X))X</script><blockquote>
<p><strong>推导过程</strong></p>
<p>令</p>
<script type="math/tex; mode=display">
h_W(X) = \frac 1 {1+e^{-W^T\mathbf X}}</script><p>该函数服从伯努利分布（一次点击要么成功，要么失败，通过训练集可以知道不同特征组合下成功和失败的概率）</p>
<script type="math/tex; mode=display">
P(Y=1 | \mathbf X;W) = h_W(\mathbf X)\\
P(Y=0 | \mathbf X;W) = 1-h_W(\mathbf X)</script><p>则概率分布函数为</p>
<script type="math/tex; mode=display">
P(Y|\mathbf X;W) = (h_W(\mathbf X))^Y*(1-h_W(\mathbf X))^{1-Y}</script><p>（<strong>也就是说，我们有样本，通过样本能知道概率分布，那么我们需要知道得到这个概率分布的最有可能的参数W。即我们通过样本知道一些特征组合下的点击率，现在需要求概率函数中的系数。</strong>）</p>
<p>我们假设样本数据相互独立，所以它们的联合分布可以表示为各边际分布的乘积，用似然函数表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
L(W)=P(Y|\mathbf X;W) &= (h_W(\mathbf X))^Y(1-h_W(\mathbf X))^{1-Y}\\
&=\prod_{j=1}^M(h_W(X_j))^{y_j}(1-h_W(X_j))^{1-y_j}
\end{aligned}
\tag {2-1-2}</script><p>从而，损失函数的求解，可以转化为求最有可能导致这样概率分布的W，也就是求L(W)的最大值。最简单的方法就是对W求偏导，并令导数为零。</p>
<p>在多数情况下，直接对变量进行求导反而会使得计算式子更加的复杂，此时可以借用对数函数。由于对数函数是单调增函数，因此与（2-1-2）具有相同的最大值，上式变为</p>
<script type="math/tex; mode=display">
\begin{aligned} 
l(W) &= Log\ L(W)\\
&=\sum_{j=1}^M(y_jln\ h(X_j)+(1-y_j)ln\ (1-h(X_j)))
\end{aligned}</script><p>对其求关于W的偏导</p>
<p>首先求logistic函数的导数，得（最后一个X是对$W^TX$的求导）</p>
<script type="math/tex; mode=display">
h_W^{'}(\mathbf X) = h_W(\mathbf X)(1-h_W(\mathbf X))</script><blockquote>
<p><strong>推导过程如下</strong></p>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/求导的推导.jpg" alt="求导的推导"></p>
</blockquote>
<p>为了求解方便，将l(W)转为（其实1/M没用，完全可以去掉，不懂为何要加上）</p>
<script type="math/tex; mode=display">
J(W) = -\frac {1}{M} l(W)</script><p>则就变成求J(W)的最小值。求偏导的过程如下：</p>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/最大似然估计求偏导.png" alt="最大似然估计求偏导"></p>
<p>最后得到目标函数（损失函数）为：</p>
<script type="math/tex; mode=display">
\frac {\partial }{\partial W}J(W) =-\frac{1}{M} (Y-h_W(\mathbf X))X</script></blockquote>
<p>对于损失函数的求解，一个典型的方法就是梯度下降法，由于损失函数是凸函数，因此沿着梯度下降的方向找到最小点。</p>
<p>假设样本总数为m，<strong>批量梯度下降</strong>是：</p>
<script type="math/tex; mode=display">
Repeat\ until\ convergence \{ \\
W^{(t+1)} := W^t - \eta^t\triangledown  _{W}l(W^{t},Z) \\
\}\\
 \tag{1-2}</script><p>而<strong>随机梯度下降（SGD）</strong>是：</p>
<script type="math/tex; mode=display">
Repeat\ until\ convergence \{ \\
      for\ j=1\ to\ M, \{ \\
          W^{(t+1)} := W^t - \eta^t\triangledown  _{W}l(W^{t},Z_j) \\
\}</script><p>两者的区别是：</p>
<p>前者每次更新$W$都需要遍历一次整个样本集合；而后者在遍历样本集合的时候，每个样本都能改变$W$ ，有更快的收敛速度 。由于SGD针对观测到的随机一条数据进行权重的更新，很适合进行增量计算，实现梯度下降的online模式。</p>
<h2 id="2-2-正则化"><a href="#2-2-正则化" class="headerlink" title="2.2 正则化"></a>2.2 正则化</h2><p>正则化的主要目的是防止过拟合。对于损失函数构成的模型，可能会出现有些权重很大，有些权重很小的情况，导致过拟合，使得模型的复杂度提高，泛化能力较差（对未知数据的预测能力）。</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/过拟合1.png" alt="过拟合1"></p>
<p>而正则化就是对损失函数中权重的限制，限制其模不要太大：</p>
<script type="math/tex; mode=display">
W=\arg \underset{W}{min}\   l(W,Z)\\
s.t. \Psi(W)<\delta</script><p>其中，$\Psi(W)$称为正则化因子，是一个关于W求模的函数，常用的正则化因子有L1和L2正则化。</p>
<script type="math/tex; mode=display">
L1\ Regularization \ \ \ \ \ \ \ \ \Psi(W)=||W||_1=\sum_{i=1}^N|w_i|\\
L2 \ Regularization\ \ \ \ \ \ \ \Psi(W)=||W||_2^2=\sum_{i=1}^N(w_i)^2=W^TW</script><p>L1和L2的主要区别有两个：</p>
<p>（1）L1在0处不可导，而L2可导。</p>
<p>（2）L1通常能产生更稀疏的模型，也就是W的更多维度是0。这些为0的权重就代表了不是很重要的维度，所以能起到特征选择的目的。</p>
<p>（3）L2能限制特征权重各个维度的模不要太大，解决过拟合。</p>
<blockquote>
<p><img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/正则化解空间.png" alt="正则化解空间"><br> 其中，左图的圆形区域是L2正则化的单位圆，右图的方形区域是L1正则化的单位圆。<br><strong>单位圆</strong></p>
<p>使$||X||_p=1$的图形，当p=1和2时，单位圆分别为$|x|+|y|=1$和$x^2+y^2=1$。</p>
</blockquote>
<p>但是在SGD中，由于每次W的更新并不是沿着全局梯度进行下降，而是沿着某个样本产生的梯度方向进行下降，这样即使采用L1的方式也很难产生稀疏解。因此在接下来的在线最优化求解算法中，稀疏性是一个主要的追求目标。</p>
<p>参考：</p>
<p><a href="http://www.mamicode.com/info-detail-517504.html【正则化方法：L1和L2" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-517504.html【正则化方法：L1和L2</a> regularization、数据集扩增、dropout】</p>
<p><a href="http://blog.csdn.net/zouxy09/article/details/24971995/【机器学习中的范数规则化之（一）L0、L1与L2范数】" target="_blank" rel="noopener">http://blog.csdn.net/zouxy09/article/details/24971995/【机器学习中的范数规则化之（一）L0、L1与L2范数】</a></p>
<h1 id="3、在线最优化求解算法"><a href="#3、在线最优化求解算法" class="headerlink" title="3、在线最优化求解算法"></a>3、在线最优化求解算法</h1><h2 id="3-1-截断梯度法TG"><a href="#3-1-截断梯度法TG" class="headerlink" title="3.1 截断梯度法TG"></a>3.1 截断梯度法TG</h2><p>为了使特征权重W有更多的0，最简单的方法就是设一个阈值，当W的某个维度值小于这个阈值的时候置为0，这个称为<strong>简单截断法</strong>。但实际中W的某个系数比较小可能是由于该维度训练不足引起，所以这么做会导致这部分特征的丢失。于是又改进为<strong>截断梯度法Truncated Gradient</strong>。</p>
<h3 id="3-1-1-简单截断法"><a href="#3-1-1-简单截断法" class="headerlink" title="3.1.1 简单截断法"></a>3.1.1 简单截断法</h3><p>以$k$为窗口，当$t/k$不为整数时，采用标准的SGD；否则，采用如下的权重更新方式：</p>
<script type="math/tex; mode=display">
W^{t+1}=T_0(W^t - \eta^tG^t,\theta) \\
T_0(v_i,\theta) = \begin{Bmatrix}
0\ if\ |v_i|\leqslant \theta\\ 
v_i\ otherwise
\end{Bmatrix}</script><p>其中，$G^t=\triangledown  _{W}l(W^{t},Z^{t})$ 代表第t次迭代中损失函数的梯度，$\eta^{t}$ 是学习率，通常将其设置为 $1/\sqrt{t}$ 的函数。可以看出，简单截断法的思路是，如果某个维度的权重变化小于设定的$\theta$ ，则直接置为0。</p>
<h3 id="3-1-2-截断梯度法"><a href="#3-1-2-截断梯度法" class="headerlink" title="3.1.2 截断梯度法"></a>3.1.2 截断梯度法</h3><p>在前一种方法上的改进。加入了L1正则化项$\eta^{t}\lambda sgn(W^{t})$ 。</p>
<script type="math/tex; mode=display">
W^{t+1}=W^t-\eta ^tG^t-\eta^t\lambda sgn(W^t)</script><p>其中$sgn(v)$是符号函数。由于每次仅根据一个样本进行更新，因此也不再使用区分样本的下表$j$。</p>
<p>采用类似的方式表示为：</p>
<script type="math/tex; mode=display">
W^{t+1}=T_1(W^t - \eta^tG^t,\eta^t\lambda^t,\theta) \\
T_1(v_i,\alpha,\theta) = \begin{Bmatrix}
\begin{aligned}
& max(0,v_i-\alpha)\ if\ v_i\in [0,\theta]\\ 
& min(0,v_i+\alpha)\ if\ v_i\in [-\theta,0]\\
& v_i\ otherwise
\end{aligned}
\end{Bmatrix}</script><p>其中，$\lambda^{t} \in \mathbb{R}$且$\lambda^{t}\geqslant0 $ 。同样以k为窗口，每k步进行一次截断。当t/k不为整数时，$\lambda^{t}=0$， 否则，$\lambda^{t}=k\lambda$。可以看出，$\lambda$和$\theta$决定了权重的稀疏程度，这两个值越大越稀疏。</p>
<h2 id="3-2-前向后向切分FOBOS"><a href="#3-2-前向后向切分FOBOS" class="headerlink" title="3.2 前向后向切分FOBOS"></a>3.2 前向后向切分FOBOS</h2><h3 id="3-2-1-FOBOS算法原理"><a href="#3-2-1-FOBOS算法原理" class="headerlink" title="3.2.1 FOBOS算法原理"></a>3.2.1 FOBOS算法原理</h3><p>在FOBOS（Forward-backward Splitting）中，将权重的更新分为两个步骤：</p>
<script type="math/tex; mode=display">
W^{t+\frac{1}{2}} = W^t-\eta^tG^{t}\\
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t+\frac{1}{2}}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}
\tag {3-2-1}</script><p>前一个步骤还是标准的梯度下降，后一个步骤可以理解为对梯度下降的结果进行微调，其中第一项是L2正则化，表示不能离损失迭代结果太远，第二项$\Psi (W)$是正则化项。</p>
<p>将上面两个式子合并，有</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t}-\eta^{t}G^{t}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}</script><p>令</p>
<script type="math/tex; mode=display">
F(W)=\frac {1} {2} ||W- W^{t}-\eta^{t}G^{t}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)</script><p>如果$W^{t+1}$存在一个最优解，<strong><em>那么可以推断0向量一定属于$F(W)$的一维次梯度集合</em>。</strong></p>
<script type="math/tex; mode=display">
0 \in \partial F(W)=W-W^{t}+\eta^{t}G^{t}+\eta^{t+\frac 1 2}\partial \Psi(W)</script><blockquote>
<p><strong>次导数和次梯度</strong></p>
<p>参考SubGradient.pdf</p>
<p>次导数是一个区间，一维次梯度就是次导数</p>
</blockquote>
<p>由于$W^{t+1}=\arg \underset{x}{min} F(W)$，则有：</p>
<script type="math/tex; mode=display">
0=\left \{ W-W^{t} - \eta^{t}G^{t}+\eta^{t+\frac {1}{2}}\partial\Psi(W) \right \}|_{W=W^{t+1}}</script><p>便可以得到另一种更新权重的方式</p>
<script type="math/tex; mode=display">
W^{t+1}=W^{t}+ \eta^{t}G^{t}-\eta^{t+\frac {1}{2}}\partial\Psi(W^{t+1})</script><p>从上式可以看到权重的更新不仅与迭代前的状态有关，也与迭代后的$W^{t+1}$有关。</p>
<h3 id="3-2-2-L1-FOBOS"><a href="#3-2-2-L1-FOBOS" class="headerlink" title="3.2.2 L1-FOBOS"></a>3.2.2 L1-FOBOS</h3><p>在L1正则化下，有$\Psi (W)=\lambda||w||_1$ 。对于（2-3-1），</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^{t+\frac{1}{2}}||_2^2+\eta^{t+\frac {1}{2}}\Psi (W)\}</script><p>用向量V来表示$W^{t+\frac 1 2}$ ，用标量$\tilde{\lambda} \in \mathbb{R}$来表示$\eta^{t+\frac 1 2}\lambda$ ，将公式展开，并改写为</p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min}\sum_{i=1}^N (\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)
\tag {3-2-2}</script><p>可以看到，在求和公式中的每一项都是大于0的，所以公式（3-2-2）可以拆解成对特征权重W的每一维度单独求解</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\arg \underset{w_i}{min}(\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)
\tag {3-2-3}</script><p>假设$w_i^<em>$是一个维度上的最优解，通过反证法证明$w_i^</em>v_i\geq0$（证明略）。再分$v_i\geq0$和$v_i&lt;0$来讨论。</p>
<p><strong>（1）当$v_i\geq0$时</strong>，</p>
<p>由于$w_i^<em>v_i\geq0$，所以$w_i^</em> \geq0$ 。相当于给（2-3-3）增加了一个不等式约束条件：</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\arg \underset{w_i}{min}(\frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|)\\
s.t. -w_i\leq 0</script><p>通过拉格朗日乘子求解这个含不等式的约束问题。</p>
<p>引入拉格朗日系数$\beta \geq 0$ ，由KKT条件，有</p>
<script type="math/tex; mode=display">
\frac \partial {\partial w_i}\left ( \frac {1} {2}(w_i-v_i)^2+ \tilde{\lambda}|w_i|-\beta w_i \right )|_{w_i=w_i^*}=0 \\
\beta w_i^*=0</script><p>根据上面的求导可得</p>
<script type="math/tex; mode=display">
w_i^*=v_i-\tilde{\lambda}+\beta</script><p>再分为两种情况</p>
<p>① 当$w_i^<em> &gt; 0$ 时，由于$\beta w_i^</em>=0$ 所以$\beta=0$，此时有$w_i^*=v_i-\tilde{\lambda}$ ，从而$v_i-\tilde{\lambda} &gt; 0$ 。</p>
<p>② 当$w_i^* = 0$ 时，有$v_i-\tilde{\lambda}+\beta=0$ 。由于$\beta \geq 0$ ，所以$v_i-\tilde{\lambda} \leq 0$  。</p>
<p>可以得出，当$v_i\geq0$ 时，</p>
<script type="math/tex; mode=display">
w_i^* = max(0, v_i-\tilde{\lambda})</script><p><strong>（2）当$v_i&lt;0$时</strong>，</p>
<p>采用同样的分析方法，得到</p>
<script type="math/tex; mode=display">
w_i^* =- max(0, -v_i-\tilde{\lambda})</script><p>综上，可得FOBOS在L1正则化条件下，特征权重各个维度的更新方式为：</p>
<script type="math/tex; mode=display">
\begin{aligned} 
w_i^{t+1} &= sgn(v_i)max(0,|v_i|-\tilde{\lambda})\\
& = sgn(w_i^{t}-\eta^{t}g_i^{t})max \left \{ 0, |w_i^{t}-\eta^{t}g_i^{t}|-\eta^{t+ \frac {1} {2}} \lambda \right \}
 \end{aligned}
 \tag{3-2-4}</script><p>其中，$g_i^{t}$就是梯度在维度i上的取值。</p>
<p><strong>从公式（3-2-4）可以看出，L1-FOBOS每次更新W的时候，对W的每个维度都会进行判定，当$|w_i^{t}-\eta^{t}g_i^{t}|-\eta^{t+ \frac {1} {2}} \lambda&lt;0$的时候对齐进行截断，即权重置为0。</strong></p>
<p>换一种写法，</p>
<script type="math/tex; mode=display">
|w_i^{t}-\eta^{t}g_i^{t}|<\eta^{t+ \frac {1} {2}} \lambda
\tag {3-2-5}</script><p>可以看出截断的意义是，<strong>当一条样本产生的梯度不足以令对应维度上的权重值发生足够大的变大（$\eta^{t+ \frac {1} {2}} \lambda$ ），则认为在本次更新过程中该维度不重要，令其权重为0</strong>。</p>
<p>若对L1-FOBOS进行适当的变换，可以发现，L1-FOBOS就是TG在特定条件下的特殊形式。</p>
<h2 id="3-3-RDA"><a href="#3-3-RDA" class="headerlink" title="3.3 RDA"></a>3.3 RDA</h2><h3 id="3-3-1-RDA算法原理"><a href="#3-3-1-RDA算法原理" class="headerlink" title="3.3.1 RDA算法原理"></a>3.3.1 RDA算法原理</h3><p>TG和FOBOS都是建立在SGD的基础之上，属于梯度下降类型的方法，这类型方法的优点就是精度比较高，并且 TG、 FOBOS 也都能在稀疏性上得到提升。 但是有些其它类型的算法，例如 RDA，是从另一个方面来求解 Online Optimization 并且更有效地提升了特征权重的稀疏性。 </p>
<p>正则对偶平均（ RDA, Regularized Dual Averaging） 是微软十年的研究成果， RDA 是 Simple Dual Averaging Scheme 的一个扩展， 由 Lin Xiao 发表于 2010 年 。</p>
<p>在 RDA 中， 特征权重的更新策略为： </p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\Psi(W)+\frac {\beta^{t}}{t}h(W) \right \}
\tag {3-3-1}</script><p>本质上，公式（3-3-1）包括了3个部分：</p>
<p>（1）线性函数$\frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle$ 包含了之前所有梯度（或次梯度）的平均值（dual average），$G^r$ 是梯度；</p>
<p>（2）$\Psi(W)$ 为正则项；</p>
<p>（3）额外正则项$\frac {\beta^{t}}{t}h(W)$。其中$h(W)$是一个辅助的严格凸函数。${\beta^{t}|t\geq 1}$ 是一个非负且非自减序列。</p>
<h3 id="3-3-2-L1-RDA"><a href="#3-3-2-L1-RDA" class="headerlink" title="3.3.2 L1-RDA"></a>3.3.2 L1-RDA</h3><p>在L1正则化下，有$\Psi (W)=\lambda||w||_1$，并且由于$h(W)$是一个关于W的严格凸函数，就令$h(W)=\frac {1} {2} ||W||_2^2 $ 。此外，将${\beta^{t}|t\geq 1}$定义为$\beta^{t}=\gamma \sqrt t $ 。再代入（2-4-1），有</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\lambda||w||_1+\frac {\gamma} {2\sqrt t}||W||_2^2 \right \}
\tag {3-3-2}</script><p>分解到每一个权重的维度上</p>
<script type="math/tex; mode=display">
w_i^{t+1} = \arg \underset{w_i}{min} \left \{ \bar{g_i}^{t}w_i +\lambda|w_i|+\frac {\gamma} {2\sqrt t}w_i^2 \right \}
\tag {3-3-3}</script><p>这里$\lambda &gt;0,\ \frac {\gamma} {\sqrt t}&gt;0,\  \bar{g<em>i}^{t} = \frac 1 t \sum</em>{r=1}^t g_i^{(r)}$ 。公式（2-4-3）就是一个无约束的非平滑最优化问题（因为第二项$\lambda|w_i|$ 在0处不可导）。所以用次导数求解。</p>
<p>假设$w_i^<em>$ 是其最优解，并且定义$\xi \in \partial  |w_i|$为$|w_i|$ 在$w_i^</em>$ 的次导数，则有</p>
<script type="math/tex; mode=display">
\partial |w_i^*| =  \left\{\begin{matrix}
-1<\xi<1  & if w_i^*=0\\ 
1 & if w_i^*>0\\ 
-1 & if w_i^*<0
\end{matrix}\right.</script><p>对公式（3-3-3）求次导数，并令其为0，则有</p>
<script type="math/tex; mode=display">
\bar{g_i}^{t} + \lambda\xi + \frac {\gamma} {\sqrt t} w_i = 0</script><p>由于$\lambda &gt;0$，再分情况讨论（略），可以得到L1-RDA特征权重的各个维度更新的方式为：</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\begin{Bmatrix}
0 & if |\bar{g_i}^{t}|<\lambda\\ 
-\frac {\sqrt t}{\gamma}\left (\bar{g_i}^{t}-\lambda sgn(\bar{g_i}^{t})  \right ) & otherwise
\end{Bmatrix}
\tag {3-3-4}</script><p><strong>这里可以看出，当某个维度上累积梯度平均值的绝对值小于阈值$\lambda$ 时，产生截断</strong>。</p>
<h3 id="3-3-3-L1-RDA和L1-FOBOS的比较"><a href="#3-3-3-L1-RDA和L1-FOBOS的比较" class="headerlink" title="3.3.3 L1-RDA和L1-FOBOS的比较"></a>3.3.3 L1-RDA和L1-FOBOS的比较</h3><p>在L1-FOBOS中，进行截断的条件是</p>
<script type="math/tex; mode=display">
|w_i^{t}-\eta^{t}g_i^{t}|<\eta^{t+ \frac {1} {2}} \lambda</script><p>通常会定义$\eta$为与$\frac 1 {\sqrt t}$ 正相关的函数$\eta=\Theta \left ( \frac {1} {\sqrt t} \right )$ 。因此L1-FOBOS的<strong>截断阈值为$\Theta \left ( \frac {1} {\sqrt t} \right )\lambda$  ，</strong>随着**t的增加，这个阈值会逐渐降低。</p>
<p>相比较而言，L1-RDA的<strong>截断阈值是$\lambda$ </strong>。是一个常数，并不随着t变化，因此相对于L1-FOBOS更简单粗暴。这种性质使得L1-RDA更容易产生稀疏性。此外， RDA 中判定截断的对象是梯度的累加平均值$\bar{g_i}^{t} $ ， 不同于 TG或L1-FOBOS 中针对单次梯度计算的结果进行判定，避免了由于某些维度由于训练不足导致截断的问题。 并且通过调节一个参数$\lambda$，很容易在精度和稀疏性上进行权衡 。</p>
<h2 id="3-4-FTRL"><a href="#3-4-FTRL" class="headerlink" title="3.4 FTRL"></a>3.4 FTRL</h2><p>有实验证明， <strong>L1-FOBOS 这一类基于梯度下降的方法有比较高的精度，但是 L1-RDA 却能在损失一定精度的情况下产生更好的稀疏性。 FTRL则是结合了两者的优点</strong>。</p>
<h3 id="3-4-1-L1-FOBOS和L1-RDA在形式上的统一"><a href="#3-4-1-L1-FOBOS和L1-RDA在形式上的统一" class="headerlink" title="3.4.1 L1-FOBOS和L1-RDA在形式上的统一"></a>3.4.1 L1-FOBOS和L1-RDA在形式上的统一</h3><p>之前提到，L1-FOBOS可以表示为（这里令$\eta^{t+\frac 1 2}=\eta^t=\Theta(\frac 1 {\sqrt t})$  是一个随t变化的非增正序列） </p>
<script type="math/tex; mode=display">
W^{t+1}=\arg \underset{W}{min} \{\frac {1} {2} ||W- W^t-\eta^tG^t||^2+\eta^{t}\lambda||w||_1\}</script><p>将其按W的维度分解为N个独立的最优化步骤</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize} \left \{  \frac 1 2 (w_i-w_i^t+\eta^tg_i^t)^2+\eta^t\lambda|w_i| \right \}\\
=\underset{w_i}{minimize}\left \{  \frac 1 2 (w_i-w_i^t)^2 + \frac 1 2(\eta^tg_i^t)^2+w_i\eta^tg_i^t- w_i^t\eta^tg_i^t+    \eta^t\lambda|w_i| \right \}\\</script><p>同时除以$\eta^t$ ，得到</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize}\left \{ w_ig_i^t+\lambda|w_i|+\frac 1 {2\eta^t}(w_i-w_i^t)^2 + [\frac {\eta^t}{2}(g_i^t)2+w_i^tg_i^t] \right \}</script><p>由于$\frac {\eta^t}{2}(g_i^t)2+w_i^tg_i^t$ 与变量$w_i$ 无关，因此上式可以等价于</p>
<script type="math/tex; mode=display">
\underset{w_i}{minimize}\left \{ w_ig_i^t+\lambda|w_i|+\frac 1 {2\eta^t}(w_i-w_i^t)^2 +  \right \}</script><p>再将这N个独立的合并，则L1-FOBOS可以写成</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ G^t\cdot W+\lambda||W||_1+\frac 1 {2\eta^t}||W-W^t||_2^2 \right \}</script><p>而对于L1-RDA的公式（3-3-2）</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ \frac 1 t \sum_{r=1}^t \left \langle G^r,W \right \rangle  +\lambda||w||_1+\frac {\gamma} {2\sqrt t}||W||_2^2 \right \} \\</script><p>同时乘以t，得到</p>
<script type="math/tex; mode=display">
\begin{aligned} 
W^{t+1} & = \arg \underset{W}{min} \left \{ \sum_{r=1}^t  G^r \cdot W  +t\lambda||w||_1+\frac {1} {2\eta^t}||W-0||_2^2 \right \}\\
& =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +t\lambda||w||_1+\frac {1} {2\eta^t}||W-0||_2^2 \right \}
\end{aligned}</script><p>如果令$\sigma ^s = \frac 1 {\eta^s}-\frac 1 {\eta^{s-1}}$  ，则$\sigma^{1:t} = \frac 1 {\eta^t}$ 。L1-FOBOS和L1-RDA的公式可以写成</p>
<script type="math/tex; mode=display">
W^{t+1} = \arg \underset{W}{min} \left \{ G^t\cdot W+\lambda||W||_1+\frac 1 2\sigma^{1:t}||W-W^t||_2^2 \right \}\\
W^{t+1} =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +t\lambda||W||_1+\frac 1 2\sigma^{1:t}||W-0||_2^2 \right \}
\tag {3-4-1}</script><p>比较这两个公式，可以看出L1-FOBOS和L1-RDA的区别在于：</p>
<p>（1）前者对梯度只考虑当前的状态，而后者的梯度是累加的形式；</p>
<p>（2）前者的第三项限制了W的变化不能离已经迭代过的解太远，后者限制W不能离0太远。</p>
<h3 id="3-4-2-FTRL算法原理"><a href="#3-4-2-FTRL算法原理" class="headerlink" title="3.4.2 FTRL算法原理"></a>3.4.2 FTRL算法原理</h3><p>FTRL综合考虑了L1-FOBOS和L1-RDA中对正则项和W限制的区别，其特征权重的更新公式为</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  G^{1:t} \cdot W  +\lambda_1||W||_1+\lambda_2||W||_2^2+\frac 1 2\sum_{s=1}^t \sigma^s ||W-W^s||_2^2 \right \}
\tag {3-4-2}</script><p>其中L2的正则项在论文中并没有出现，但是2013年的FTRL工程化实现的论文却使用。事实上该项的引入并不影响FRTL<br>的稀疏性， 后面的推导过程会显示这一点。 L2正则项的引入仅仅相当于对最优化过程多了一个约束，使得结果求解结果更加“平滑”。 </p>
<p>对（3-4-2）进行变换，将其的最后一项展开</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  (G^{1:t}-\sum_{s=1}^t\sigma^sW^s) \cdot W  +\lambda_1||W||_1+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)||W||_2^2+\frac 1 2\sum_{s=1}^t \sigma^s ||W^s||_2^2 \right \}</script><p>其中，由于$\frac 1 2\sum_{s=1}^t \sigma^s ||W^s||_2^2$ 相对于W是常数项，再令</p>
<script type="math/tex; mode=display">
Z^{t} =G^{1:t}-\sum_{s=1}^t\sigma^sW^s
\tag {3-4-3}</script><p>上式等价于</p>
<script type="math/tex; mode=display">
W^{t+1} =\arg \underset{W}{min} \left \{  Z^t \cdot W  +\lambda_1||W||_1+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)||W||_2^2 \right \}</script><p>再针对每个维度将其拆解成N个独立的标量最小化问题</p>
<script type="math/tex; mode=display">
 \underset{w_i}{minimize} \left \{  z_i^tw_i  +\lambda_1|w_i|+\frac 1 2 (\lambda_2+\sum_{s=1}^t\sigma^s)w_i^2 \right \}</script><p>到这里，遇到了与L1-RDA的（3-3-3）类似的优化问题，用相同的分析方法可以得到</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\left\{\begin{matrix}
0 & if\ |z_i^t|<\lambda_1\\ 
-\left ( \lambda_2+\sum_{s=1}^t\sigma^s \right )^{-1}\ \left ( z_i^t-\lambda_1 sgn(z_i^t) \right ) & otherwise
\end{matrix} \right.
\tag {3-4-4}</script><p>可以看出，引入L2并没有对FTRL结果的稀疏性产生影响。</p>
<h3 id="3-4-3-学习率"><a href="#3-4-3-学习率" class="headerlink" title="3.4.3 学习率"></a>3.4.3 学习率</h3><p>前面的推导中，学习率的选择和计算没有被提及。事实上在FTRL中，每个维度的学习率都是单独考虑的。</p>
<p>考虑特征维度的变化率：如果特征 1 比特征 2 的变化更快，那么在维度 1 上的学习率应该下降得更快。我们很容易就可以想到可以用某个维度上梯度分量来反映这种变化率。在FTRL 中，维度 i上的学习率是这样计算的<strong>（原作者没有推导过程）</strong>：</p>
<script type="math/tex; mode=display">
\eta_i^t=\frac {\alpha}{\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}</script><p>由于$\sum_{s=1}^t\sigma^s=\frac 1 {\eta^t}$ ，因此（3-4-4）就变成</p>
<script type="math/tex; mode=display">
w_i^{t+1}=\left\{\begin{matrix}
0 & if\ |z_i^t|<\lambda_1\\ 
-\left ( \lambda_2 + \frac {\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}{\alpha}  \right )^{-1}\ \left ( z_i^t-\lambda_1 sgn(z_i^t) \right ) & otherwise
\end{matrix} \right.
\tag {3-4-5}</script><p>这里的$\alpha, \beta$ 都是要输入的参数。</p>
<h3 id="2-5-4-伪代码解读"><a href="#2-5-4-伪代码解读" class="headerlink" title="2.5.4 伪代码解读"></a>2.5.4 伪代码解读</h3><p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/FTRL伪代码.png" alt="FTRL伪代码"></p>
<p>首先设置各个参数的初始值，包括</p>
<ul>
<li>更新学习率的$\alpha,\beta$。</li>
<li>L1和L2正则化的参数$\lambda_1,\ \lambda_2$ </li>
<li>更新权重时用到的$z_i$ 一维数组（数组的长度是特征项个数），初始值是0</li>
<li>存放梯度累加的$n_i$ 一维数组（数组的长度是特征项个数），初始值是0</li>
</ul>
<p>算法步骤中：</p>
<p>（1）第一阶段，计算第t次迭代的预测值</p>
<p><strong>S1</strong>：用给定的初始值计算权重$w_{t,i}$，并计算出预测值$p_t$ 。见①</p>
<p>（2）第二阶段，更新第t+1次的权重，对当前样本不为0的每个特征项都要进行一次更新。在第i个特征项中，</p>
<p><strong>S1</strong>：采用logloss计算损失函数的梯度$g_{t+1}$，见②</p>
<p><strong>S2</strong>：可以看出①里面还需要计算$n_i$  和$z_i$ 在第t+1次的值。</p>
<p>对于$z_i$，根据公式（2-5-3）</p>
<script type="math/tex; mode=display">
Z^{t} =G^{1:t}-\sum_{s=1}^t\sigma^sW^s</script><p>可以看出z的更新可以通过下式计算</p>
<script type="math/tex; mode=display">
\begin {aligned}
Z^{t+1}& =G^{1:t+1}-\sum_{s=1}^{t+1}\sigma^sW^s\\
&=G^{1:t}-\sum_{s=1}^t\sigma^sW^s + G^{t+1} - \sigma^{t+1}W^{t+1}\\
&=Z^t + G^{t+1} - \sigma^{t+1}W^{t+1}
 \end{aligned}
 \tag {3-4-6}</script><p>则需要计算$\sigma^{t+1}$ 的值。而根据上文的推导</p>
<script type="math/tex; mode=display">
\sigma ^s = \frac 1 {\eta^s}-\frac 1 {\eta^{s-1}}</script><p>又</p>
<script type="math/tex; mode=display">
\eta_i^t=\frac {\alpha}{\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}</script><p>则</p>
<script type="math/tex; mode=display">
\begin {aligned}
\sigma ^{t+1}& = \frac 1 {\eta^{t+1}}-\frac 1 {\eta^t}\\
&=\frac {\beta + \sqrt {\sum_{s=1}^{t+1} (g_i^s)^2}}{\alpha}-\frac {\beta + \sqrt {\sum_{s=1}^t (g_i^s)^2}}{\alpha}\\
&=\frac 1 \alpha \left ( \sqrt {\sum_{s=1}^{t+1} (g_i^s)^2}- \sqrt {\sum_{s=1}^t (g_i^s)^2}\right )
 \end{aligned}</script><p>由于用$n_i$ 记录$g_i$ 的累加和，上式可以变成</p>
<script type="math/tex; mode=display">
\sigma ^{t+1} = \sqrt {n^t+(g^{t+1})^2}-\sqrt {n^t}
\tag {3-4-7}</script><p>见③。再根据公式（3-4-6），计算$z_i$ 的值，见④。</p>
<p><strong>S3</strong>：对于$n_i$ ，根据公式（3-4-7），</p>
<script type="math/tex; mode=display">
n^{t+1} = n^t +(g^{t+1})^2</script><p>见⑤。</p>
<h3 id="2-5-5-实现代码"><a href="#2-5-5-实现代码" class="headerlink" title="2.5.5 实现代码"></a>2.5.5 实现代码</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span></span>(x: <span class="type">Array</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</div><div class="line">  <span class="keyword">var</span> wTx = <span class="number">0.0</span></div><div class="line"></div><div class="line">  x foreach &#123; x =&gt;</div><div class="line">    <span class="keyword">val</span> sign = <span class="keyword">if</span> (z(x) &lt; <span class="number">0</span>) <span class="number">-1.0</span> <span class="keyword">else</span> <span class="number">1.0</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sign * z(x) &lt;= <span class="type">L1</span>)</div><div class="line">      w(x) = <span class="number">0.0</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      w(x) = (sign * <span class="type">L1</span> - z(x)) / ((beta + math.sqrt(n(x))) / alpha + <span class="type">L2</span>)</div><div class="line"></div><div class="line">    wTx = wTx + w(x)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1.0</span> + math.exp(-math.max(math.min(wTx, <span class="number">35.0</span>), <span class="number">-35.0</span>)))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(x: <span class="type">Array</span>[<span class="type">Int</span>], p: <span class="type">Double</span>, y: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> g = p - y</div><div class="line"></div><div class="line">  x foreach &#123; x =&gt;</div><div class="line">    <span class="keyword">val</span> sigma = (math.sqrt(n(x) + g * g) - math.sqrt(n(x))) / alpha</div><div class="line">    z(x) = z(x) + g - sigma * w(x)</div><div class="line">    n(x) = n(x) + g * g</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码可以看出，在更新权重时，SGD和FTRL的区别在于：</p>
<p><del>SGD在遍历每个样本的时候，都会更新所有维度的权重，而FTRL在遍历每个样本的时候只会更新样本对应维度的权重。从而可以节省训练的时间</del></p>
<p>并不是节省时间。SGD也可以用于在线学习，过拟合的限制上没有FTRL好。参数太多，会导致模型复杂度上升，容易过拟合。</p>
<h3 id="3-4-6-实验及结论"><a href="#3-4-6-实验及结论" class="headerlink" title="3.4.6 实验及结论"></a>3.4.6 实验及结论</h3><p>1、</p>
<p>训练：16-10-22的前7天数据</p>
<p>预测：16-10-22当天数据</p>
<p>维度：1048576</p>
<p>参数：默认</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc3.png" alt="roc3"></p>
<p>logloss：</p>
<p>线上方法：0.274321867859</p>
<p>FRTL：0.0326626593411</p>
<p>2、</p>
<p>训练：16-10-22的前7天数据</p>
<p>预测：16-10-22当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：1048576</p>
<p>参数：默认</p>
<p>训练时间：11:54-12:18</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc1.png" alt="roc1"></p>
<p>logloss：</p>
<p>线上方法：0.275704770725</p>
<p>FRTL：0.032281346379</p>
<p>3、</p>
<p>训练集：16-10-18的前10天数据</p>
<p>预测：16-10-18当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：4194304</p>
<p>参数：默认</p>
<p>训练时间：13:50-14:19</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc2.png" alt="roc2"></p>
<p>logloss</p>
<p>线上方法：0.073087783303</p>
<p>FTRL：0.022967801811</p>
<p>4、</p>
<p>训练集：16-10-18的前10天数据</p>
<p>预测：16-10-18当天数据，其中每9条用于在线学习，预测第10条</p>
<p>维度：4194304</p>
<p>参数：训练的特征项改为1-10</p>
<p>训练时间：17:07-17:45</p>
<p> <img src="/2017/07/12/机器学习/浅谈在线最优化求解算法-以CTR预测模型为例/roc4.png" alt="roc4"></p>
<p>logloss</p>
<p>线上方法：0.073087783303</p>
<p>FTRL：0.0221369813697</p>
<p>特征权重不为0的维度有11301个</p>
<h2 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h2><p>FTRL在线训练时间长了效果往往会下降，因为学习率会逐渐降低，必须要offline结合online。</p>
<h1 id="主要参考资料"><a href="#主要参考资料" class="headerlink" title="主要参考资料"></a>主要参考资料</h1><p>【在线最优化求解(Online Optimization)-冯扬】</p>
<p>【逻辑回归从入门到精通-腾讯柳超】</p>
<p>【FTRL的理论论文】Factorization machines with follow-the-regularized-leader for CTR prediction in display advertising  <a href="http://www0.cs.ucl.ac.uk/staff/w.zhang/rtb-papers/fm-ftrl.pdf" target="_blank" rel="noopener">http://www0.cs.ucl.ac.uk/staff/w.zhang/rtb-papers/fm-ftrl.pdf</a></p>
<p>【FTRL的工程实现论文】<a href="https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf" target="_blank" rel="noopener">https://www.eecs.tufts.edu/~dsculley/papers/ad-click-prediction.pdf</a> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://schwimmer.github.io/2017/07/12/机器学习/模型集成/"/>

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Schwimmer"/>
      <meta itemprop="description" content="Record and Think!"/>
      <meta itemprop="image" content="/images/avatar.gif"/>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Schwimmer's Blog"/>
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2017/07/12/机器学习/模型集成/" class="post-title-link" itemprop="url">模型集成</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-12 11:49:53" itemprop="dateCreated datePublished" datetime="2017-07-12T11:49:53+08:00">2017-07-12</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-02-11 09:26:22" itemprop="dateModified" datetime="2018-02-11T09:26:22+08:00">2018-02-11</time>
              </span>
            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2017/07/12/机器学习/模型集成/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/12/机器学习/模型集成/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br/>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.jiqizhixin.com/articles/2018-01-14-8" target="_blank" rel="noopener">每个Kaggle冠军的获胜法门：揭秘Python中的模型集成</a></p>
<p><img src="https://image.jiqizhixin.com/uploads/wangeditor/c897487a-bf02-4023-9355-24c747d7ef62/43133image%20(1" alt="">.png)</p>
<p>Example Schematics of an ensemble.  An input array X is fed through two proprocessing pipelines and then to a set of base learners f(i). The ensemble combines all base learner predictions into a final prediction array P. </p>
<p>By the end of the post, you will:</p>
<ul>
<li>understand the fundamentals of ensembles</li>
<li>know how to code them</li>
<li>understand the main pitfalls and drawbacks of ensembles</li>
</ul>
<h2 id="Predicting-Republican-and-Democratic-donations"><a href="#Predicting-Republican-and-Democratic-donations" class="headerlink" title="Predicting Republican and Democratic donations"></a>Predicting Republican and Democratic donations</h2><p>we’ll use a data set on U.S. political contributions. The <a href="https://github.com/fivethirtyeight/data/tree/master/science-giving" target="_blank" rel="noopener">original data set</a> was prepared by <a href="https://fivethirtyeight.com/contributors/ben-wieder/" target="_blank" rel="noopener">Ben Wieder</a> at <a href="https://fivethirtyeight.com/" target="_blank" rel="noopener">FiveThirtyEight</a>, who dug around the U.S. government’s political contribution registry and found that when <a href="https://fivethirtyeight.com/features/when-scientists-donate-to-politicians-its-usually-to-democrats/" target="_blank" rel="noopener">scientists donate to politician, it’s usually to Democrats</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line"><span class="comment">### Import data</span></div><div class="line"><span class="comment"># Always good to set a seed for reproducibility</span></div><div class="line">SEED = <span class="number">222</span></div><div class="line">np.random.seed(SEED)</div><div class="line"></div><div class="line">df = pd.read_csv(<span class="string">'input.csv'</span>)</div><div class="line"></div><div class="line"><span class="comment">### Training and test set</span></div><div class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_test</span><span class="params">(test_size=<span class="number">0.95</span>)</span>:</span></div><div class="line">    <span class="string">"""Split Data into train and test sets."""</span></div><div class="line">    y = <span class="number">1</span> * (df.cand_pty_affiliation == <span class="string">"REP"</span>)</div><div class="line">    X = df.drop([<span class="string">"cand_pty_affiliation"</span>], axis=<span class="number">1</span>)</div><div class="line">    X = pd.get_dummies(X, sparse=<span class="keyword">True</span>)</div><div class="line">    X.drop(X.columns[X.std() == <span class="number">0</span>], axis=<span class="number">1</span>, inplace=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> train_test_split(X, y, test_size=test_size, random_state=SEED)</div><div class="line"></div><div class="line">xtrain, xtest, ytrain, ytest = get_train_test()</div><div class="line"></div><div class="line"><span class="comment"># A look at the data</span></div><div class="line">print(<span class="string">"\nExample data:"</span>)</div><div class="line">df.head()</div><div class="line"></div><div class="line">df.cand_pty_affiliation.value_counts(normalize=<span class="keyword">True</span>).plot(</div><div class="line">    kind=<span class="string">"bar"</span>, title=<span class="string">"Share of No. donations"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p>This claim is based on the observation on the share of donations being made to Republicans and Democrats. However, there’s plenty more that can be said: for instance, which scientific discipline is most likely to make a Republican donation, and which state is most likely to make Democratic donations? We will go one step further and <em>predict</em> whether a donation is most likely to be a to a Republican or Democrat.</p>
<h2 id="What-is-an-ensemble"><a href="#What-is-an-ensemble" class="headerlink" title="What is an ensemble?"></a>What is an ensemble?</h2><p>Combining predictions from several models averages out idiosyncratic errors and yield better overall predictions.</p>
<p>How to combine predictions?</p>
<p>Machine learning is remarkably similar in classification problems: <strong>taking the most common class label prediction is equivalent to a majority voting rule</strong>. But there are many other ways to combine predictions, and more generally we can use a <strong>model to <em>learn</em></strong> how to best combine predictions.</p>
<h3 id="Understanding-ensembles-by-combining-decision-trees"><a href="#Understanding-ensembles-by-combining-decision-trees" class="headerlink" title="Understanding ensembles by combining decision trees"></a>Understanding ensembles by combining decision trees</h3><p>The deeper the tree, the more complex the patterns it can capture, but the <strong>more prone</strong> to overfitting it will be. Because of this, we will need an alternative way of building complex models of decision trees, and an ensemble of different decision trees is one such way.</p>
<p>We’ll use the below helper function to visualize our decision rules:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pydotplus  <span class="comment"># you can install pydotplus with: pip install pydotplus </span></div><div class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</div><div class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier, export_graphviz</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_graph</span><span class="params">(clf, feature_names)</span>:</span></div><div class="line">    <span class="string">"""Print decision tree."""</span></div><div class="line">    graph = export_graphviz(</div><div class="line">        clf,</div><div class="line">        label=<span class="string">"root"</span>,</div><div class="line">        proportion=<span class="keyword">True</span>,</div><div class="line">        impurity=<span class="keyword">False</span>, </div><div class="line">        out_file=<span class="keyword">None</span>, </div><div class="line">        feature_names=feature_names,</div><div class="line">        class_names=&#123;<span class="number">0</span>: <span class="string">"D"</span>, <span class="number">1</span>: <span class="string">"R"</span>&#125;,</div><div class="line">        filled=<span class="keyword">True</span>,</div><div class="line">        rounded=<span class="keyword">True</span></div><div class="line">    )</div><div class="line">    graph = pydotplus.graph_from_dot_data(graph)  </div><div class="line">    <span class="keyword">return</span> Image(graph.create_png())</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/28/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/30/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Schwimmer</p>
              <div class="site-description motion-element" itemprop="description">Record and Think!</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">313</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Schwimmer</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.5.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.2.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  
  
<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-schwimmer-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>







  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
